
/*
 *@@sourcefile xtrash.c:
 *      This file contains SOM code for the following XWorkplace classes:
 *
 *      --  XWPTrashCan: a subclass of WPFolder, which implements
 *             the actual trash can object. There must only be one
 *             instance of this class, which must have the object ID
 *             <XWORKPLACE_TRASHCAN> for the XFldObject "delete"
 *             support to work.
 *
 *             The trash can folder itself never contains the "real"
 *             WPS objects which have been deleted, but only instances
 *             of XWPTrashObject, which "mirror" the deleted objects.
 *             The actual deleted objects reside in the hidden
 *             "\trash" directories on each drive.
 *
 *             Deleting objects is done by XWPTrashCan::xwpDeleteIntoTrashCan.
 *             See the notes there for details.
 *
 *             XWPTrashCan::wpPopulate creates as many instances of
 *             XWPTrashObject as objects exist in the "\Trash"
 *             directories of all drives on the system.
 *
 *      --  XWPTrashObject: a subclass of WPTransient. One instance
 *             of this class is created by XWPTrashCan for every object
 *             that was placed into the trash can.
 *
 *             We use WPTransient in order not to clutter up OS2.INI
 *             with abstract objects which have no data to save anyways.
 *
 *      There are two ways to delete an object using the trash can:
 *      1)  selecting "Delete" from an object's context menu;
 *          this behavior is implemented by the XFldObject class,
 *          if this feature has been enabled by the user;
 *      2)  dropping an object onto the trash can object or into
 *          an open trash can view (using XWPTrashCan::wpDrop).
 *
 *@@somclass XWPTrashCan xtrc_
 *@@somclass M_XWPTrashCan xtrcM_
 *@@somclass XWPTrashObject xtro_
 *@@somclass M_XWPTrashObject xtroM_
 */

/*
 *      Copyright (C) 1997-99 Ulrich M”ller.
 *      This file is part of the XWorkplace source package.
 *      XWorkplace is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published
 *      by the Free Software Foundation, in version 2 as it comes in the
 *      "COPYING" file of the XWorkplace main distribution.
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

/*
 *@@todo:
 *
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitctm: 2.41
 */

#ifndef SOM_Module_xtrash_Source
#define SOM_Module_xtrash_Source
#endif
#define XWPTrashCan_Class_Source
#define M_XWPTrashCan_Class_Source

/*
 *  Suggested #include order:
 *  1)  os2.h
 *  2)  C library headers
 *  3)  setup.h (code generation and debugging options)
 *  4)  headers in helpers\
 *  5)  at least one SOM implementation header (*.ih)
 *  6)  dlgids.h, headers in shared\ (as needed)
 *  7)  headers in implementation dirs (e.g. filesys\, as needed)
 *  8)  #pragma hdrstop and then more SOM headers which crash with precompiled headers
 */

#define INCL_DOS
#define INCL_DOSERRORS
#define INCL_WIN
#include <os2.h>

// C library headers
#include <stdio.h>              // needed for except.h
#include <setjmp.h>             // needed for except.h
#include <assert.h>             // needed for except.h

// generic headers
#include "setup.h"                      // code generation and debugging options

// headers in /helpers
#include "helpers\dosh.h"               // Control Program helper routines
#include "helpers\winh.h"               // PM helper routines
#include "helpers\stringh.h"            // string helper routines
#include "helpers\except.h"             // exception handling
#include "helpers\linklist.h"           // linked list helper routines

// SOM headers which don't crash with prec. header files
#include "xtrash.ih"

// XWorkplace implementation headers
#include "dlgids.h"                     // all the IDs that are shared with NLS
#include "shared\common.h"              // the majestic XWorkplace include file
#include "shared\kernel.h"              // XWorkplace Kernel
#include "shared\notebook.h"            // generic XWorkplace notebook handling
#include "shared\wpsh.h"                // some pseudo-SOM functions (WPS helper routines)

#include "filesys\xthreads.h"           // extra XWorkplace threads

// other SOM headers
#pragma hdrstop
#include "xfobj.h"
#include <wprootf.h>
#include "helpers\undoc.h"              // some undocumented stuff

/* ******************************************************************
 *                                                                  *
 *   Global variables                                               *
 *                                                                  *
 ********************************************************************/

/*
 *@@ XTRO_DETAILS:
 *      extended object details for XWPTrashObject
 *      (used in trash can Details view)
 */

typedef struct _XTRO_DETAILS
{
   PSZ     pszSourcePath;       // where object was deleted from
   CDATE   cdateDeleted;        // deletion date
   CTIME   ctimeDeleted;        // deletion date
   ULONG   ulSize;              // size of object; we won't use a double here, because
                                // this would require us to do container owner draw
} XTRO_DETAILS, *PXTRO_DETAILS;

// extra data fields for XWPTrashObject object details;
// we add one field, which is the "Original path"
// where the object was deleted from.
#define XTRO_EXTRAFIELDS 4
CLASSFIELDINFO acfiTrashObject[XTRO_EXTRAFIELDS];
        // we add three fields
// See XWPTrashObject::wpclsQueryDetailsInfo for details.

#define XTRC_INVALID            0
#define XTRC_SUPPORTED          1
#define XTRC_UNSUPPORTED        2

#define CB_SUPPORTED_DRIVES     23

/*
 * abSupportedDrives:
 *      drives support for trash can.
 *      Index 0 is for drive C:, 1 is for D:, and so on.
 *      Each item can be one of the following:
 *      --  XTRC_SUPPORTED: drive is supported.
 *      --  XTRC_SUPPORTED: drive is not supported.
 *      --  XTRC_INVALID: drive letter doesn't exist.
 */

BYTE abSupportedDrives[CB_SUPPORTED_DRIVES] = "";

/* ******************************************************************
 *                                                                  *
 *   Helper functions                                               *
 *                                                                  *
 ********************************************************************/

/*
 *@@ AddTrashObjectsForTrashDir:
 *      this routine gets called from XWPTrashCan::wpPopulate
 *      for each "?:\Trash" directory which exists on all
 *      drives. pTrashDir must be the corresponding WPFolder
 *      object for that directory.
 *
 *      We then query the folder's contents and create trash
 *      objects in pTrashCan accordingly. If another folder
 *      is found (which is probable), we recurse.
 *
 *      This returns the total number of trash objects that were
 *      created.
 */

ULONG AddTrashObjectsForTrashDir(XWPTrashCan *pTrashCan,  // in: trashcan to add objects to
                                 WPFolder *pTrashDir,     // in: trash directory to examine
                                 double *pdTotalSize)     // in/out: total trash can size
{
    BOOL        fTrashDirSemOwned = FALSE;
    WPObject    *pObject;
    ULONG       ulObjectCount = 0;

    #ifdef DEBUG_TRASHCAN
        _Pmpf(("  Entering AddTrashObjectsForTrashDir for %s", _wpQueryTitle(pTrashDir)));
    #endif

    TRY_LOUD(excpt1, NULL)
    {
        wpshCheckIfPopulated(pTrashDir);

        fTrashDirSemOwned = !_wpRequestObjectMutexSem(pTrashDir, SEM_INDEFINITE_WAIT);

        #ifdef DEBUG_TRASHCAN
            _Pmpf(("  wpPopulate: fTrashDirSemOwned = %d", fTrashDirSemOwned));
        #endif

        for (   pObject = _wpQueryContent(pTrashDir, NULL, (ULONG)QC_FIRST);
                (pObject);
                pObject = _wpQueryContent(pTrashDir, pObject, (ULONG)QC_NEXT)
            )
        {
            BOOL    fAddTrashObject = TRUE;
            if (_somIsA(pObject, _WPFolder))
            {
                // another folder found:
                // check the attributes if it's one of the
                // \TRASH subdirectories added by the trashcan
                // or maybe a "real" WPS folder that had been
                // deleted
                CHAR    szFolderPath[CCHMAXPATH] = "";
                ULONG   ulAttrs = 0;
                _wpQueryFilename(pObject, szFolderPath, TRUE);
                if (doshQueryPathAttr(szFolderPath, &ulAttrs) == NO_ERROR)
                    if (ulAttrs & FILE_HIDDEN)
                    {
                        // hidden directory: this is a trash directory,
                        // so recurse!
                        #ifdef DEBUG_TRASHCAN
                            _Pmpf(("    Recursing with %s", _wpQueryTitle(pObject)));
                        #endif

                        ulObjectCount += AddTrashObjectsForTrashDir(pTrashCan,
                                                                    pObject, // new trash dir
                                                                    pdTotalSize);
                        // skip the following
                        fAddTrashObject = FALSE;
                    }
            }

            if (fAddTrashObject)
            {
                // non-folder:
                // add to trashcan!
                #ifdef DEBUG_TRASHCAN
                    _Pmpf(("    Adding %s, _XWPTrashObject: 0x%lX",
                                _wpQueryTitle(pObject),
                                _XWPTrashObject));
                #endif

                if (_XWPTrashObject)
                {
                    XWPTrashObject *pTrashObject = 0;
                    // note that M_XWPTrashObject::xwpclsCreateTrashObject
                    // will automatically check for whether a trash
                    // object exists for a given related object
                    if (pTrashObject = _xwpclsCreateTrashObject(_XWPTrashObject,
                                             pTrashCan,
                                             pObject))  // related object
                    {
                        // successfully created:
                        ulObjectCount++;
                        *pdTotalSize += _xwpQueryRelatedSize(pTrashObject);
                    }
                }
            }
        } // end for (   pObject = _wpQueryContent(...
    }
    CATCH(excpt1) { } END_CATCH();

    if (fTrashDirSemOwned)
    {
        _wpReleaseObjectMutexSem(pTrashDir);
        fTrashDirSemOwned = FALSE;

        #ifdef DEBUG_TRASHCAN
            _Pmpf(("  wpPopulate: fTrashDirSemOwned = %d", fTrashDirSemOwned));
        #endif
    }

    if (ulObjectCount == 0)
    {
        // no objects found in this trash folder and
        // subfolders (if any):
        // delete this folder, it's useless
        _wpFree(pTrashDir);
    }

    #ifdef DEBUG_TRASHCAN
        _Pmpf(("  End of AddTrashObjectsForTrashDir for %s", _wpQueryTitle(pTrashDir)));
    #endif

    return (ulObjectCount);
}

/*
 *@@ CreateTrashObjectsList:
 *      this creates a new linked list (PLINKLIST, linklist.c,
 *      which is returned) containing all the trash objects in
 *      the specified trash can.
 *
 *      The list's item data pointers point to the XWPTrashObject*
 *      instances directly.
 *
 *      Note that the list is created in any case, even if the
 *      trash can is empty. lstFree must therefore always be
 *      used to free this list.
 */

PLINKLIST CreateTrashObjectsList(XWPTrashCan* somSelf)
{
    PLINKLIST       pllTrashObjects = lstCreate(FALSE);
                                // FALSE: since we store the XWPTrashObjects directly,
                                // the list node items must not be free()'d
    XWPTrashObject* pTrashObject = 0;

    for (   pTrashObject = _wpQueryContent(somSelf, NULL, (ULONG)QC_FIRST);
            (pTrashObject);
            pTrashObject = _wpQueryContent(somSelf, pTrashObject, (ULONG)QC_NEXT)
        )
    {
        // pTrashObject now has the XWPTrashObject to delete
        lstAppendItem(pllTrashObjects, pTrashObject);
    }

    return (pllTrashObjects);
}

/*
 *@@ fncbTrashCanSettingsInitPage:
 *      notebook callback function (notebook.c) for the
 *      "TrashCan" settings page.
 *      Sets the controls on the page according to the
 *      Global Settings.
 */

VOID fncbTrashCanSettingsInitPage(PCREATENOTEBOOKPAGE pcnbp,   // notebook info struct
                          ULONG flFlags)        // CBI_* flags (notebook.h)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();

    if (flFlags & CBI_INIT)
    {
        if (pcnbp->pUser == NULL)
        {
            // first call: backup Global Settings for "Undo" button;
            // this memory will be freed automatically by the
            // common notebook window function (notebook.c) when
            // the notebook page is destroyed
            pcnbp->pUser = malloc(sizeof(GLOBALSETTINGS));
            memcpy(pcnbp->pUser, pGlobalSettings, sizeof(GLOBALSETTINGS));
        }
    }

    if (flFlags & CBI_ENABLE)
    {
        PCKERNELGLOBALS pKernelGlobals = krnQueryGlobals();
        WinEnableControl(pcnbp->hwndPage, ID_XTDI_DELETE,
                          (pKernelGlobals->fXFldObject));
    }

    if (flFlags & CBI_SET)
    {
        winhSetDlgItemChecked(pcnbp->hwndPage, ID_XTDI_DELETE,
                              pGlobalSettings->fTrashDelete);
        winhSetDlgItemChecked(pcnbp->hwndPage, ID_XTDI_EMPTYSTARTUP,
                              pGlobalSettings->fTrashEmptyStartup);
        winhSetDlgItemChecked(pcnbp->hwndPage, ID_XTDI_EMPTYSHUTDOWN,
                              pGlobalSettings->fTrashEmptyShutdown);
        winhSetDlgItemChecked(pcnbp->hwndPage, ID_XTDI_CONFIRMEMPTY,
                              pGlobalSettings->fTrashConfirmEmpty);
    }
}

/*
 *@@ fncbTrashCanSettingsItemChanged:
 *      notebook callback function (notebook.c) for the
 *      "TrashCan" settings page.
 *      Reacts to changes of any of the dialog controls.
 */

MRESULT fncbTrashCanSettingsItemChanged(PCREATENOTEBOOKPAGE pcnbp,
                                USHORT usItemID, USHORT usNotifyCode,
                                ULONG ulExtra)      // for checkboxes: contains new state
{
    GLOBALSETTINGS *pGlobalSettings = cmnLockGlobalSettings(5000);
    MRESULT mrc = (MPARAM)0;
    BOOL fSave = TRUE;

    switch (usItemID)
    {
        case ID_XTDI_DELETE:
            pGlobalSettings->fTrashDelete = ulExtra;
        break;

        case ID_XTDI_EMPTYSTARTUP:
            pGlobalSettings->fTrashEmptyStartup = ulExtra;
        break;

        case ID_XTDI_EMPTYSHUTDOWN:
            pGlobalSettings->fTrashEmptyShutdown = ulExtra;
        break;

        case ID_XTDI_CONFIRMEMPTY:
            pGlobalSettings->fTrashConfirmEmpty = ulExtra;
        break;

        case DID_UNDO:
        {
            // "Undo" button: get pointer to backed-up Global Settings
            GLOBALSETTINGS *pGSBackup = (GLOBALSETTINGS*)(pcnbp->pUser);

            // and restore the settings for this page
            pGlobalSettings->fTrashDelete = pGSBackup->fTrashDelete;
            pGlobalSettings->fTrashEmptyStartup = pGSBackup->fTrashEmptyStartup;
            pGlobalSettings->fTrashEmptyShutdown = pGSBackup->fTrashEmptyShutdown;
            pGlobalSettings->fTrashConfirmEmpty = pGSBackup->fTrashConfirmEmpty;

            // update the display by calling the INIT callback
            (*(pcnbp->pfncbInitPage))(pcnbp, CBI_SET | CBI_ENABLE);
        break; }

        case DID_DEFAULT:
        {
            // set the default settings for this settings page
            // (this is in common.c because it's also used at
            // WPS startup)
            cmnSetDefaultSettings(pcnbp->ulPageID);
            // update the display by calling the INIT callback
            (*(pcnbp->pfncbInitPage))(pcnbp, CBI_SET | CBI_ENABLE);
        break; }

        default:
            fSave = FALSE;
    }

    cmnUnlockGlobalSettings();

    if (fSave)
        cmnStoreGlobalSettings();

    return (mrc);
}

/*
 *@@ fncbTrashCanDrivesInitPage:
 *      notebook callback function (notebook.c) for the
 *      trash can "Drives" settings page.
 *      Sets the controls on the page according to the
 *      Global Settings.
 */

VOID fncbTrashCanDrivesInitPage(PCREATENOTEBOOKPAGE pcnbp,   // notebook info struct
                                ULONG flFlags)        // CBI_* flags (notebook.h)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();

    if (flFlags & CBI_INIT)
    {
        if (pcnbp->pUser == NULL)
        {
            // first call: backup drives array for "Undo" button;
            // this memory will be freed automatically by the
            // common notebook window function (notebook.c) when
            // the notebook page is destroyed
            pcnbp->pUser = malloc(sizeof(abSupportedDrives));
            memcpy(pcnbp->pUser, abSupportedDrives, sizeof(abSupportedDrives));
        }
    }

    if (flFlags & CBI_ENABLE)
    {
        // enable "Add" button if items are selected
        // in the "Unsupported" listbox
        WinEnableControl(pcnbp->hwndPage, ID_XTDI_ADD_SUPPORTED,
                          (winhQueryLboxSelectedItem(WinWindowFromID(pcnbp->hwndPage,
                                                                     ID_XTDI_UNSUPPORTED_LB),
                                                     LIT_FIRST)
                                != LIT_NONE));
        // enable "Remove" button if items are selected
        // in the "Supported" listbox
        WinEnableControl(pcnbp->hwndPage, ID_XTDI_REMOVE_SUPPORTED,
                          (winhQueryLboxSelectedItem(WinWindowFromID(pcnbp->hwndPage,
                                                                     ID_XTDI_SUPPORTED_LB),
                                                     LIT_FIRST)
                                != LIT_NONE));
    }

    if (flFlags & CBI_SET)
    {
        ULONG   bIndex = 0;
        CHAR    szDriveName[3] = "C:";
        HWND    hwndSupportedLB = WinWindowFromID(pcnbp->hwndPage, ID_XTDI_SUPPORTED_LB),
                hwndUnsupportedLB = WinWindowFromID(pcnbp->hwndPage, ID_XTDI_UNSUPPORTED_LB);

        winhDeleteAllItems(hwndSupportedLB);
        winhDeleteAllItems(hwndUnsupportedLB);

        for (bIndex = 0;
             bIndex < CB_SUPPORTED_DRIVES;
             bIndex++)
        {
            if (abSupportedDrives[bIndex] != XTRC_INVALID)
            {
                // if drive is supported, insert into "supported",
                // otherwise into "unsupported"
                HWND    hwndLbox = (abSupportedDrives[bIndex] == XTRC_SUPPORTED)
                                        ? hwndSupportedLB
                                        : hwndUnsupportedLB;
                // insert
                LONG lInserted = WinInsertLboxItem(hwndLbox,
                                                   LIT_END,
                                                   szDriveName);
                // set item's handle to array index
                winhSetLboxItemHandle(hwndLbox,
                                      lInserted,
                                      bIndex);
            }

            // raise drive letter
            (szDriveName[0])++;
        }
    }
}

/*
 *@@ StoreSupportedDrives:
 *      this gets called from fncbTrashCanDrivesItemChanged
 *      to read the (un)supported drives from the listbox.
 *
 *@@added V0.9.1 (99-12-14) [umoeller]
 */

BOOL StoreSupportedDrives(HWND hwndSupportedLB, // in: list box with supported drives
                          HWND hwndUnsupportedLB) // in: list box with unsupported drives
{
    BOOL    brc = FALSE;

    if ((hwndSupportedLB) && (hwndUnsupportedLB))
    {
        BYTE    abSupportedDrivesNew[CB_SUPPORTED_DRIVES];
        SHORT   sIndexThis = 0;
        SHORT   sItemCount;

        // set all drives to "invalid"; only those
        // items will be overwritten which are in the
        // listboxes
        memset(abSupportedDrivesNew, XTRC_INVALID, sizeof(abSupportedDrivesNew));

        // go thru "supported" listbox
        sItemCount = winhQueryLboxItemCount(hwndSupportedLB);
        for (sIndexThis = 0;
             sIndexThis < sItemCount;
             sIndexThis++)
        {
            ULONG   ulIndexHandle = winhQueryLboxItemHandle(hwndSupportedLB,
                                                            sIndexThis);
            abSupportedDrivesNew[ulIndexHandle] = XTRC_SUPPORTED;
        }

        // go thru "unsupported" listbox
        sItemCount = winhQueryLboxItemCount(hwndUnsupportedLB);
        for (sIndexThis = 0;
             sIndexThis < sItemCount;
             sIndexThis++)
        {
            ULONG   ulIndexHandle = winhQueryLboxItemHandle(hwndUnsupportedLB,
                                                            sIndexThis);
            abSupportedDrivesNew[ulIndexHandle] = XTRC_UNSUPPORTED;
        }

        // update trash can with that data
        _xwpclsSetDrivesSupport(_XWPTrashCan,
                                abSupportedDrivesNew);
    }

    return (brc);
}

/*
 *@@ fncbTrashCanDrivesItemChanged:
 *      notebook callback function (notebook.c) for the
 *      trash can "Drives" settings page.
 *      Reacts to changes of any of the dialog controls.
 */

MRESULT fncbTrashCanDrivesItemChanged(PCREATENOTEBOOKPAGE pcnbp,
                                      USHORT usItemID, USHORT usNotifyCode,
                                      ULONG ulExtra)      // for checkboxes: contains new state
{
    MRESULT mrc = (MPARAM)0;
    BOOL fSave = TRUE;

    static BOOL fNoDeselection = FALSE;

    switch (usItemID)
    {
        /*
         * ID_XTDI_UNSUPPORTED_LB:
         * ID_XTDI_SUPPORTED_LB:
         *      if list box selections change,
         *      re-enable "Add"/"Remove" buttons
         */

        case ID_XTDI_UNSUPPORTED_LB:
        case ID_XTDI_SUPPORTED_LB:
            if (usNotifyCode == LN_SELECT)
            {
                // deselect all items in the other listbox
                if (!fNoDeselection)
                {
                    fNoDeselection = TRUE;
                            // this recurses
                    winhLboxSelectAll(WinWindowFromID(pcnbp->hwndPage,
                                                      ((usItemID == ID_XTDI_UNSUPPORTED_LB)
                                                        ? ID_XTDI_SUPPORTED_LB
                                                        : ID_XTDI_UNSUPPORTED_LB)),
                                      FALSE); // deselect
                    fNoDeselection = FALSE;
                }

                // re-enable items
                (*(pcnbp->pfncbInitPage))(pcnbp, CBI_ENABLE);
            }
        break;

        /*
         * ID_XTDI_ADD_SUPPORTED:
         *      "Add" button: move item(s)
         *      from "unsupported" to "supported"
         *      list box
         */

        case ID_XTDI_ADD_SUPPORTED:
        {
            SHORT   sItemStart = LIT_FIRST;
            HWND    hwndSupportedLB = WinWindowFromID(pcnbp->hwndPage, ID_XTDI_SUPPORTED_LB),
                    hwndUnsupportedLB = WinWindowFromID(pcnbp->hwndPage, ID_XTDI_UNSUPPORTED_LB);
            CHAR    szItemText[10];

            fNoDeselection = TRUE;
            while (TRUE)
            {
                sItemStart = winhQueryLboxSelectedItem(hwndUnsupportedLB,
                                                       sItemStart);
                if (sItemStart == LIT_NONE)
                    break;

                // move item
                winhMoveLboxItem(hwndUnsupportedLB,
                                 sItemStart,
                                 hwndSupportedLB,
                                 LIT_SORTASCENDING,
                                 TRUE);         // select
            }
            fNoDeselection = FALSE;

            // re-enable buttons
            (*(pcnbp->pfncbInitPage))(pcnbp, CBI_ENABLE);

            // update internal drives data
            StoreSupportedDrives(hwndSupportedLB,
                                 hwndUnsupportedLB);
        break; }

        /*
         * ID_XTDI_REMOVE_SUPPORTED:
         *      "Add" button: move item(s)
         *      from "unsupported" to "supported"
         *      list box
         */

        case ID_XTDI_REMOVE_SUPPORTED:
        {
            SHORT   sItemStart = LIT_FIRST;
            HWND    hwndSupportedLB = WinWindowFromID(pcnbp->hwndPage, ID_XTDI_SUPPORTED_LB),
                    hwndUnsupportedLB = WinWindowFromID(pcnbp->hwndPage, ID_XTDI_UNSUPPORTED_LB);
            CHAR    szItemText[10];

            fNoDeselection = TRUE;
            while (TRUE)
            {
                sItemStart = winhQueryLboxSelectedItem(hwndSupportedLB,
                                                       sItemStart);
                if (sItemStart == LIT_NONE)
                    break;

                // move item
                winhMoveLboxItem(hwndSupportedLB,
                                 sItemStart,
                                 hwndUnsupportedLB,
                                 LIT_SORTASCENDING,
                                 TRUE);         // select
            }
            fNoDeselection = FALSE;

            // re-enable buttons
            (*(pcnbp->pfncbInitPage))(pcnbp, CBI_ENABLE);

            // update internal drives data
            StoreSupportedDrives(hwndSupportedLB,
                                 hwndUnsupportedLB);
        break; }

        case DID_UNDO:
        {
            // copy array back which was stored in init callback
            _xwpclsSetDrivesSupport(_XWPTrashCan,
                                    pcnbp->pUser);  // backup data
            // update the display by calling the INIT callback
            (*(pcnbp->pfncbInitPage))(pcnbp, CBI_SET | CBI_ENABLE);
        break; }

        case DID_DEFAULT:
        {
            // set defaults
            _xwpclsSetDrivesSupport(_XWPTrashCan,
                                    NULL);     // defaults
            // update the display by calling the INIT callback
            (*(pcnbp->pfncbInitPage))(pcnbp, CBI_SET | CBI_ENABLE);
        break; }

        default:
            fSave = FALSE;
    }

    if (fSave)
        cmnStoreGlobalSettings();

    return (mrc);
}

/* ******************************************************************
 *                                                                  *
 *   XWPTrashCan instance methods                                   *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpDeleteIntoTrashCan:
 *            this new instance method takes any WPS object and
 *            "deletes" it into the trash can (somSelf).
 *
 *            This gets called in two situations:
 *            1)  when XFldObject::wpMenuItemSelected reacts to
 *                the "Delete" context menu item;
 *            2)  from XWPTrashCan::wpDrop.
 *
 *            When an object is thus "deleted" into the trashcan,
 *            this method does the following:
 *
 *            1)  create a hidden directory "\Trash" on the drive
 *                where the object resides, if that directory doesn't
 *                exist already;
 *
 *            2)  create a path in "\Trash" according to the path of
 *                the object; i.e., if "F:\Tools\XFolder\xfldr.dll"
 *                is moved into the trash can, "F:\Trash\Tools\XFolder"
 *                will be created;
 *
 *            3)  move the object which is being deleted into that
 *                directory (using wpMoveObject, so that all WPS
 *                shadows etc. remain valid);
 *
 *            4)  create a new instance of XWPTrashObject in the
 *                trash can (somSelf) which should represent the
 *                object by calling M_XWPTrashObject::xwpclsCreateTrashObject.
 *                However, this is only done if the trash can has
 *                already been populated (otherwise we'd get duplicate
 *                trash objects in the trash can when populating).
 */

SOM_Scope ULONG  SOMLINK xtrc_xwpDeleteIntoTrashCan(XWPTrashCan *somSelf,
                                                    WPObject* pObject)
{
    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpDeleteIntoTrashCan");

    if (pObject)
    {
        WPFolder *pFolder = _wpQueryFolder(pObject),
                 *pFolderInTrash;
        if (pFolder)
        {
            CHAR szFolder[CCHMAXPATH];
            if (_wpQueryFilename(pFolder, szFolder, TRUE))
            {
                // now we have the directory name where pObject resides
                // in szFolder;
                // get the drive
                CHAR szTrashDir[CCHMAXPATH];

                #ifdef DEBUG_TRASHCAN
                    _Pmpf(("Source folder: %s", szFolder));
                #endif

                sprintf(szTrashDir, "%c:\\Trash%s",
                        szFolder[0],    // drive letter
                        &(szFolder[2]));   // rest of path

                #ifdef DEBUG_TRASHCAN
                    _Pmpf(("Creating dir %s", szTrashDir));
                #endif

                doshCreatePath(szTrashDir,
                               TRUE);   // hide that directory

                pFolderInTrash = _wpclsQueryFolder(_WPFolder,
                                                   szTrashDir,
                                                   TRUE);       // lock object
                if (pFolderInTrash)
                {
                    if (_wpMoveObject(pObject, pFolderInTrash))
                    {
                        // successfully moved:
                        // set original object's deletion data
                        // to current date/time
                        _xwpSetDeletion(pObject, TRUE);

                        // if the trash can has been populated
                        // already, add a matching trash object;
                        // otherwise wpPopulate will do this
                        // later
                        if (_wpQueryFldrFlags(somSelf) & FOI_POPULATEDWITHALL)
                        {
                            #ifdef DEBUG_TRASHCAN
                                _Pmpf(("Trash can is populated: creating trash object"));
                            #endif
                            if (_xwpclsCreateTrashObject(_XWPTrashObject,
                                                         somSelf,    // trash can
                                                         pObject))
                                #ifdef DEBUG_TRASHCAN
                                    _Pmpf(("  Created trash object successfully"))
                                #endif
                                ;
                        }
                        else
                        {
                            // not populated yet:
                            #ifdef DEBUG_TRASHCAN
                                _Pmpf(("Trash can not populated, skipping trash object"));
                            #endif

                            // just raise the number of trash items
                            // and change the icon, wpPopulate will
                            // later correct this number
                            (_ulTrashObjectCount)++;
                            _xwpSetCorrectTrashIcon(somSelf);
                        }
                    }
                }
            }
        }
    }

    /* Return statement to be customized: */
    return (0);
}

/*
 *@@ xwpAddTrashCanSettingsPage:
 *      this adds the "Trash can" page to the
 *      settings notebook.
 */

SOM_Scope ULONG  SOMLINK xtrc_xwpAddTrashCanSettingsPage(XWPTrashCan *somSelf,
                                                         HWND hwndDlg)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */

    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
    memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpAddTrashCanSettingsPage");

    pcnbp->somSelf = somSelf;
    pcnbp->hwndNotebook = hwndDlg;
    pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
    pcnbp->ulDlgID = ID_XTD_SETTINGS;
    pcnbp->ulPageID = SP_TRASHCAN_SETTINGS;
    pcnbp->usPageStyleFlags = BKA_MAJOR;
    pcnbp->pszName = pNLSStrings->pszTrashSettings;
    pcnbp->ulDefaultHelpPanel = ID_XSH_SETTINGS_TRASHCAN + 1;

    pcnbp->pfncbInitPage    = fncbTrashCanSettingsInitPage;
    pcnbp->pfncbItemChanged = fncbTrashCanSettingsItemChanged;

    return (ntbInsertPage(pcnbp));
}

/*
 *@@ xwpAddTrashCanDrivesPage:
 *      this adds the "Drives support" page to
 *      the trash can settings notebook.
 *
 *@@added V0.9.1 (99-12-19) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xtrc_xwpAddTrashCanDrivesPage(XWPTrashCan *somSelf,
                                                       HWND hwndDlg)
{
    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
    memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

    // XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpAddTrashCanDrivesPage");

    pcnbp->somSelf = somSelf;
    pcnbp->hwndNotebook = hwndDlg;
    pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
    pcnbp->ulDlgID = ID_XTD_DRIVES;
    pcnbp->ulPageID = SP_TRASHCAN_DRIVES;
    pcnbp->usPageStyleFlags = BKA_MAJOR;
    pcnbp->pszName = pNLSStrings->pszTrashSettings;
    pcnbp->ulDefaultHelpPanel = ID_XSH_SETTINGS_TRASHCAN + 1;

    pcnbp->pfncbInitPage    = fncbTrashCanDrivesInitPage;
    pcnbp->pfncbItemChanged = fncbTrashCanDrivesItemChanged;

    return (ntbInsertPage(pcnbp));
}

/*
 *@@ xwpAddTrashCanGeneralPage:
 *      this gets called by XWPTrashCan::wpAddObjectGeneralPage
 *      (which has been replaced) to add our replacement "General"
 *      page to the settings notebook.
 */

SOM_Scope ULONG  SOMLINK xtrc_xwpAddTrashCanGeneralPage(XWPTrashCan *somSelf,
                                                        HWND hwndDlg)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpAddTrashCanGeneralPage");

    /* Return statement to be customized: */
    return (TRUE);
}

/*
 *@@ xwpQueryTrashObjectsCount:
 *      this will return the no. of trash objects in the
 *      trash can.
 *
 *      Note that this information is only accurate if the
 *      trash can has been fully populated. Otherwise,
 *      you will get a number too, but this might not
 *      reflect the precise no.of objects, since that no.
 *      is stored internally to be able to set the correct
 *      trash can icon even without populating.
 */

SOM_Scope ULONG  SOMLINK xtrc_xwpQueryTrashObjectsCount(XWPTrashCan *somSelf)
{
    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpQueryTrashObjectsCount");

    return (_ulTrashObjectCount);
}

/*
 *@@ xwpSetCorrectTrashIcon:
 *      this sets the trash can's icon according
 *      to its current state by calling wpSetIcon
 *      with either the "empty" or "not empty" icon.
 */

SOM_Scope BOOL  SOMLINK xtrc_xwpSetCorrectTrashIcon(XWPTrashCan *somSelf)
{
    HPOINTER hptr = NULLHANDLE;
    ULONG    ulIconID = 0;
    BOOL     brc = FALSE;
    BOOL     fTrashFilled = FALSE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();

    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpSetCorrectTrashIcon");

    if (!_fCorrectIconSet)
    {
        // very first call (probably at system startup):
        // get the last trash objects count from the global
        // settings (we don't have to populate the trash can
        // at this point)
        _fCorrectIconSet = TRUE;
    }

    if (_ulTrashObjectCount)
        fTrashFilled = TRUE;

    /* if (pGlobalSettings->fReplaceIcons)
    {
        // attempt to load user-defined replacement icon
        // from ICONS.DLL
        if (fTrashFilled)
            ulIconID = 113;
        else
            ulIconID = 112;

        hptr = WinLoadPointer(HWND_DESKTOP,
                              cmnQueryIconsDLL(),
                              ulIconID);
    } */

    if (hptr == NULLHANDLE)
    {
        // no user icons or user icon not found:
        // then load the icon from XFLDR.DLL
        if (fTrashFilled)
            ulIconID = ID_ICONXWPTRASHFILLED;
        else
            ulIconID = ID_ICONXWPTRASHEMPTY;

        hptr = WinLoadPointer(HWND_DESKTOP,
                              cmnQueryMainModuleHandle(),
                              ulIconID);
    }

    if (hptr)
        brc = _wpSetIcon(somSelf, hptr);

    return (brc);
}

/*
 *@@ xwpEmptyTrashCan:
 *      this will empty the trashcan.
 *
 *      This should get called on a second thread, such
 *      as the XWorkplace File thread, in order
 *      not to block PM, because this will work synchronously
 *      (i.e. not return until the trash can is empty).
 *
 *      Normally, this method gets called from the
 *      XWorkplace file thread (fnwpFileObject, kernel.c)
 *      when XWPTrashCan::wpMenuItemSelected intercepts
 *      the "empty trash can" command.
 *
 *      If (pfnwpCallback != NULL), this callback will
 *      get called to allow for displaying the progress
 *      of the delete operation.
 *
 *      This callback gets called for every object
 *      _before_ it gets deleted. You can therefore
 *      invoke all SOM methods on it.
 *
 *      Parameters passed to the callback:
 *
 *      -- HWND hwnd:        hwndUser passed to this func
 *      -- MPARAM mp1:       trash object (XWPTrashObject instance)
 *      -- MPARAM mp2:       related object ("real" object)
 *
 *      To display a status window, create that window
 *      before calling this function, pass that window to
 *      this function in hwndUser, and destroy it after
 *      this function is done. Again, this operates
 *      synchroneously.
 *
 *      This returns the no. of objects deleted or
 *      0 if the trash can was empty or -1 upon errors.
 */

SOM_Scope ULONG  SOMLINK xtrc_xwpEmptyTrashCan(XWPTrashCan *somSelf,
                                               PFNWP pfnwpCallback,
                                               HWND hwndUser)
{
    ULONG       ulrc = 0;
    WPObject*   pTrashObject = 0;
    BOOL        fTrashCanSemOwned = FALSE;

    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpEmptyTrashCan");

    TRY_LOUD(excpt1, NULL)
    {
        PLINKLIST pllTrashObjects;
        PLISTNODE pNode = 0;

        // make sure the trash objects are up-to-date
        wpshCheckIfPopulated(somSelf);

        // we must build a list of trash objects first,
        // because if we deleted the trash objects in this
        // loop already, the next items would not be found
        fTrashCanSemOwned = !_wpRequestObjectMutexSem(somSelf, SEM_INDEFINITE_WAIT);
        pllTrashObjects = CreateTrashObjectsList(somSelf);

        // now delete the items
        pNode = lstQueryFirstNode(pllTrashObjects);
        while (pNode)
        {
            pTrashObject = (XWPTrashObject*)(pNode->pItemData);

            if (_xwpDestroyTrashObject(pTrashObject))
                ulrc++;

            // go for next
            pNode = pNode->pNext;
        }

        lstFree(pllTrashObjects);

        // now reconstruct the list and check whether
        // we have successfully destroyed all objects
        _ulTrashObjectCount = 0;
        pllTrashObjects = CreateTrashObjectsList(somSelf);
        _ulTrashObjectCount = lstCountItems(pllTrashObjects);
        lstFree(pllTrashObjects);
        _xwpSetCorrectTrashIcon(somSelf);
    }
    CATCH(excpt1) { } END_CATCH();

    if (fTrashCanSemOwned)
    {
        _wpReleaseObjectMutexSem(somSelf);
        fTrashCanSemOwned = FALSE;
    }

    return (ulrc);
}

/*
 *@@ xwpUpdateStatusBar:
 *      this XFolder instance method gets called when the status
 *      bar needs updating. This gets called using name-lookup
 *      resolution, so XFolder does not have to be installed
 *      for this to work. However, if it is, this method will
 *      be called. See xfldr.idl for details.
 */

SOM_Scope BOOL  SOMLINK xtrc_xwpUpdateStatusBar(XWPTrashCan *somSelf,
                                                HWND hwndStatusBar,
                                                HWND hwndCnr)
{
    CHAR        szText[1000] = "",
                szNum[100];
    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_xwpUpdateStatusBar");

    sprintf(szText,
            "Total size of all objects: %s bytes",
            strhThousandsDouble(szNum, _dTotalSize, '.'));

    WinSetWindowText(hwndStatusBar, szText);

    return (TRUE);
}

/*
 *@@ wpInitData:
 *      this instance method gets called when the object
 *      is being initialized. We initialize our instance
 *      data here.
 */

SOM_Scope void  SOMLINK xtrc_wpInitData(XWPTrashCan *somSelf)
{
    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpInitData");

    XWPTrashCan_parent_WPFolder_wpInitData(somSelf);

    _ulTrashObjectCount = 0;
    _fCorrectIconSet = FALSE;
    _dTotalSize = 0;
}

/*
 *@@ wpObjectReady:
 *      this is called upon an object when its creation
 *      or awakening is complete. This is the last method
 *      which gets called during instantiation of a
 *      WPS object when it has completely initialized
 *      itself. ulCode signifies the cause of object
 *      instantiation.
 *
 *      For trash cans, we need to call
 *      XWPTrashCan::xwpSetCorrectTrashIcon.
 */

SOM_Scope void  SOMLINK xtrc_wpObjectReady(XWPTrashCan *somSelf,
                                           ULONG ulCode, WPObject* refObject)
{
    // XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpObjectReady");

    XWPTrashCan_parent_WPFolder_wpObjectReady(somSelf, ulCode,
                                              refObject);

    _xwpSetCorrectTrashIcon(somSelf);
}

/*
 *@@ wpUnInitData:
 *      this instance method is called to allow the object
 *      to free allocated resources.
 *
 *      The parent method must always be called last.
 */

SOM_Scope void  SOMLINK xtrc_wpUnInitData(XWPTrashCan *somSelf)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpUnInitData");

    XWPTrashCan_parent_WPFolder_wpUnInitData(somSelf);
}

/*
 *@@ wpSetup:
 *      this instance method is called to allow the newly
 *      created object to initialize itself based on an input
 *      setup string.
 *
 *      We need to support the new XWPTrashCan settings strings here.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpSetup(XWPTrashCan *somSelf, PSZ pszSetupString)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpSetup");

    return (XWPTrashCan_parent_WPFolder_wpSetup(somSelf, pszSetupString));
}

/*
 *@@ wpSaveState:
 *      this WPObject instance method saves an object's state
 *      persistently.
 *
 *      We store the trash can item count here so we don't have to
 *      populate the trash can at WPS startup already to set the
 *      correct trash icon.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpSaveState(XWPTrashCan *somSelf)
{
    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpSaveState");

    if (_ulTrashObjectCount != 0)
        _wpSaveLong(somSelf,
                    "XWPTrashCan", 1,
                    (ULONG)_ulTrashObjectCount);

    return (XWPTrashCan_parent_WPFolder_wpSaveState(somSelf));
}

/*
 *@@ wpRestoreState:
 *      this WPObject instance method gets called during object
 *      initialization to restore the data which was stored with
 *      wpSaveState.
 *
 *      We restore the trash can item count here so we don't have to
 *      populate the trash can at WPS startup already to set the
 *      correct trash icon.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpRestoreState(XWPTrashCan *somSelf,
                                            ULONG ulReserved)
{
    ULONG               ul;
    XWPTrashCanData     *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpRestoreState");

    if (_wpRestoreLong(somSelf,
                       "XWPTrashCan", 1,
                       &ul))
        _ulTrashObjectCount = ul;
    else
        _ulTrashObjectCount = 0;

    return (XWPTrashCan_parent_WPFolder_wpRestoreState(somSelf,
                                                       ulReserved));
}

/*
 *@@ wpFilterPopupMenu:
 *      this instance method allows the object to filter out
 *      unwanted menu items from the context menu.
 *
 *      We remove the "Open tree view" item.
 */

SOM_Scope ULONG  SOMLINK xtrc_wpFilterPopupMenu(XWPTrashCan *somSelf,
                                                ULONG ulFlags,
                                                HWND hwndCnr,
                                                BOOL fMultiSelect)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpFilterPopupMenu");

    return (XWPTrashCan_parent_WPFolder_wpFilterPopupMenu(somSelf,
                                                          ulFlags,
                                                          hwndCnr,
                                                          fMultiSelect)
                    &~ CTXT_TREE);
}

/*
 *@@ wpModifyPopupMenu:
 *      this instance methods allows the object to manipulate
 *      its context menu.
 *
 *      We add the trash can menu items here.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpModifyPopupMenu(XWPTrashCan *somSelf,
                                               HWND hwndMenu,
                                               HWND hwndCnr,
                                               ULONG iPosition)
{
    BOOL brc = 0;
    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpModifyPopupMenu");

    brc = XWPTrashCan_parent_WPFolder_wpModifyPopupMenu(somSelf,
                                                          hwndMenu,
                                                          hwndCnr,
                                                          iPosition);

    if ((brc) && (_ulTrashObjectCount))
    {
        PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
        PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();

        winhInsertMenuSeparator(hwndMenu, MIT_END,
                                (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_SEPARATOR));

        winhInsertMenuItem(hwndMenu, MIT_END,
                           (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_TRASHEMPTY),
                           pNLSStrings->pszTrashEmpty, MIS_TEXT, 0);

    }

    return (brc);
}

/*
 *@@ wpMenuItemSelected:
 *      this instance method gets called when a menu item
 *      was selected in the object's context menu.
 *
 *      We need to react to our new menu items here.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpMenuItemSelected(XWPTrashCan *somSelf,
                                                HWND hwndFrame,
                                                ULONG ulMenuId)
{
    BOOL                brc = TRUE;
    PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
    ULONG               ulMenuId2 = ulMenuId - pGlobalSettings->VarMenuOffset;

    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpMenuItemSelected");

    // "empty trashcan"
    if (ulMenuId2 == ID_XFMI_OFS_TRASHEMPTY)
    {
        xthrPostFileMsg(FIM_EMPTYTRASH,
                       (MPARAM)somSelf,
                       (MPARAM)NULL);
    }
    // swallow "open tree view"
    else if (ulMenuId == WPMENUID_TREE)
    {
        brc = FALSE;
    }
    else brc = XWPTrashCan_parent_WPFolder_wpMenuItemSelected(somSelf,
                                                              hwndFrame,
                                                              ulMenuId);

    return (brc);
}

/*
 *@@ wpMenuItemHelpSelected:
 *      this instance method gets called when help is
 *      requested for a menu item in the object's context menu.
 *
 *      We need to display help for our new menu items here.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpMenuItemHelpSelected(XWPTrashCan *somSelf,
                                                    ULONG MenuId)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpMenuItemHelpSelected");

    return (XWPTrashCan_parent_WPFolder_wpMenuItemHelpSelected(somSelf,
                                                               MenuId));
}

/*
 *@@ wpQueryDefaultHelp:
 *      this instance method specifies the default
 *      help panel for this instance; display some
 *      help for the trash can.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpQueryDefaultHelp(XWPTrashCan *somSelf,
                                                PULONG pHelpPanelId,
                                                PSZ HelpLibrary)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpQueryDefaultHelp");

    strcpy(HelpLibrary, cmnQueryHelpLibrary());
    *pHelpPanelId = ID_XSH_SETTINGS_TRASHCAN;
    return (TRUE);

    /* return (XWPTrashCan_parent_WPFolder_wpQueryDefaultHelp(somSelf,
                                                           pHelpPanelId,
                                                           HelpLibrary)); */
}

/*
 *@@ wpPopulate:
 *      this instance method populates a folder, in this
 *      case, the trash can object.
 *
 *      This method only does anything if the trash can
 *      has not yet been populated. If so, we go over the
 *      "\TRASH" directories on all drives and recurse into
 *      the subdirectories to create XWPTrashObject instances
 *      in the trashcan.
 *
 *      After a call to this method, if objects are found,
 *      there will be instances of XWPTrashObject in the
 *      trash can, which can be queried using the normal
 *      wpQueryContent method. There will never be any
 *      instances of classes other than XWPTrashObject
 *      in the trash can.
 *
 *      Note that when objects are deleted into the trash can,
 *      xwpDeleteIntoTrashCan will add trash objects only if
 *      the trash can has been populated already.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpPopulate(XWPTrashCan *somSelf,
                                        ULONG ulReserved, PSZ pszPath,
                                        BOOL fFoldersOnly)
{
    BOOL brc = TRUE;
    ULONG ulFldrFlags = _wpQueryFldrFlags(somSelf);

    XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpPopulate");

    // we must call the parent first;
    // otherwise, we'll get a "Wait" pointer all the time
    if (XWPTrashCan_parent_WPFolder_wpPopulate(somSelf,
                                               ulReserved,
                                               pszPath,
                                               fFoldersOnly))
    {
        #ifdef DEBUG_TRASHCAN
            _Pmpf(("%s -> wpPopulate, fFoldersOnly: %d, Flags: 0x%lX",
                        _wpQueryTitle(somSelf),
                        fFoldersOnly,
                        ulFldrFlags));
        #endif

        _wpSetFldrFlags(somSelf, ulFldrFlags | FOI_POPULATEINPROGRESS);

        if (!fFoldersOnly)
        {
            // populate with all:
            if ((ulFldrFlags & FOI_POPULATEDWITHALL) == 0)
            {
                // PGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
                CHAR        szTrashDir[30],
                            cDrive;
                BYTE        bIndex;     // into abSupportedDrives[]

                // not yet populated: this does not necessarily mean
                // that no trash objects currently reside in the
                // trash can, because apparently, this method also
                // gets called by wpRefresh (after FOI_POPULATEDWITHALL
                // has been reset), so we better validate the objects
                // in the trash can.

                PLINKLIST   pllTrashObjects = CreateTrashObjectsList(somSelf);
                PLISTNODE   pNode = lstQueryFirstNode(pllTrashObjects);

                // reset trash objects count
                _ulTrashObjectCount = 0;
                _dTotalSize = 0;

                // now go thru the list
                while (pNode)
                {
                    XWPTrashObject* pTrashObject = (XWPTrashObject*)pNode->pItemData;

                    if (_xwpValidateTrashObject(pTrashObject) == NO_ERROR)
                        _ulTrashObjectCount++;
                    // else error: means that item has been destroyed

                    // go for next
                    pNode = pNode->pNext;
                }
                lstFree(pllTrashObjects);

                #ifdef DEBUG_TRASHCAN
                    _Pmpf(("  Checked all objects, found %d", _ulTrashObjectCount));
                #endif

                // now go over all drives and create
                // trash objects for all the objects
                // in the "\Trash" directories.
                // Note that M_XWPTrashObject::xwpclsCreateTrashObject
                // will automatically check for whether a trash
                // object exists for a given related object.

                cDrive = 'C';  // (bIndex == 0) = drive C:

                for (bIndex = 0;
                     bIndex < CB_SUPPORTED_DRIVES;
                     bIndex++)
                {
                    if (abSupportedDrives[bIndex] == XTRC_SUPPORTED)
                    {
                        // drive supported:
                        WPFolder    *pTrashDir;

                        sprintf(szTrashDir, "%c:\\Trash",
                                cDrive);
                        #ifdef DEBUG_TRASHCAN
                            _Pmpf(("  Getting trash dir %s", szTrashDir));
                        #endif

                        pTrashDir = _wpclsQueryFolder(_WPFolder,
                                                      szTrashDir,
                                                      TRUE);       // lock object
                        if (pTrashDir)
                            // "\Trash" exists for this drive;
                            _ulTrashObjectCount += AddTrashObjectsForTrashDir(
                                                       somSelf,     // trashcan to add objects to
                                                       pTrashDir,   // initial trash dir;
                                                                    // this routine will recurse
                                                       &_dTotalSize);
                    }
                    cDrive++;
                }

                #ifdef DEBUG_TRASHCAN
                    _Pmpf(("  Added new trash objects, now %d", _ulTrashObjectCount));
                #endif

                ulFldrFlags |= (FOI_POPULATEDWITHFOLDERS
                                  | FOI_POPULATEDWITHALL);
                ulFldrFlags &= ~FOI_POPULATEINPROGRESS;

                // save trash can's state; this will store
                // the trash object count in .CLASSINFO
                // (wpSaveState)
                _wpSaveDeferred(somSelf);
            }
        }

        #ifdef DEBUG_TRASHCAN
            _Pmpf(("End of %s -> wpPopulate, fFoldersOnly: %d",
                        _wpQueryTitle(somSelf),
                        fFoldersOnly));
        #endif

        _wpSetFldrFlags(somSelf, ulFldrFlags);
    }

    _xwpSetCorrectTrashIcon(somSelf);

    return (brc);
}

/*
 *@@ wpRefresh:
 *      this updates a folder's contents. The default WPFolder
 *      version of this unsets the FOI_POPULATEDWITHALL folder
 *      flag and calls wpPopulate in turn, which is fine
 *      with us. However, for some stupid reason, the icon
 *      is also reset to the default icon, so we need to
 *      call XWPTrashCan::xwpSetCorrectTrashIcon again.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpRefresh(XWPTrashCan *somSelf,
                                       ULONG ulView, PVOID pReserved)
{
    BOOL brc = FALSE;
    // XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf);
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpRefresh");

    brc = XWPTrashCan_parent_WPFolder_wpRefresh(somSelf, ulView,
                                                pReserved);
    _xwpSetCorrectTrashIcon(somSelf);

    return (brc);
}

/*
 *@@ wpDragOver:
 *      this instance method is called to inform the object
 *      that other objects are being dragged over it.
 *      This corresponds to the DM_DRAGOVER message received by
 *      the object.
 *
 *      We check whether the object(s) are deleteable and
 *      return flags accordingly.
 */

SOM_Scope MRESULT  SOMLINK xtrc_wpDragOver(XWPTrashCan *somSelf,
                                           HWND hwndCnr, PDRAGINFO pdrgInfo)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpDragOver");

    return (XWPTrashCan_parent_WPFolder_wpDragOver(somSelf, hwndCnr,
                                                   pdrgInfo));
}

/*
 *@@ wpDrop:
 *      this instance method is called to inform an object that
 *      another object has been dropped on it.
 *      This corresponds to the DM_DROP message received by
 *      the object.
 *
 *      We delete the objects into the trash can by invoking
 *      XWPTrashCan::xwpDeleteIntoTrashCan.
 */

SOM_Scope MRESULT  SOMLINK xtrc_wpDrop(XWPTrashCan *somSelf,
                                       HWND hwndCnr, PDRAGINFO pdrgInfo,
                                       PDRAGITEM pdrgItem)
{
    MRESULT     mrc = (MRESULT)RC_DROP_ERROR;
    ULONG       ulItemNow = 0;

    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpDrop");

    #ifdef DEBUG_TRASHCAN
        _Pmpf(("pdrgInfo->hwndSource: 0x%lX", pdrgInfo->hwndSource));
            // this always has the HWND of
            // the source container
        _Pmpf(("pdrgInfo->cditem:     0x%lX", pdrgInfo->cditem));
            // this has the number of items that
            // are dropped; always >= 1
    #endif

    for (ulItemNow = 0;
         ulItemNow < pdrgInfo->cditem;
         ulItemNow++)
    {
        DRAGITEM    drgItem;
        if (DrgQueryDragitem(pdrgInfo,
                             sizeof(drgItem),
                             &drgItem,
                             ulItemNow))
            if (DrgVerifyRMF(&drgItem, "DRM_OBJECT", NULL))
            {
                // get the object pointer:
                // the WPS stores the MINIRECORDCORE in drgItem.ulItemID
                WPObject *pObject = OBJECT_FROM_PREC(drgItem.ulItemID);

                #ifdef DEBUG_TRASHCAN
                    _Pmpf(("Item %d:", ulItemNow));
                    _Pmpf(("  drgItem.hwndItem:    0x%lX", drgItem.hwndItem));
                        // == pdrgInfo->hwndSource

                    _Pmpf(("  drgItem.ulItemID:    0x%lX", drgItem.ulItemID));
                        // WPSGUIDE:
                        // --  if (DRM_OBJECT), this is the
                        //     PMINIRECORDCORE of the dropped object;
                        //     use OBJECT_FROM_PREC
                        // --  if (DRM_FILE), ulItemID is not used
                #endif

                if (pObject)
                    _xwpDeleteIntoTrashCan(somSelf, pObject);
            }

        mrc = (MRESULT)RC_DROP_DROPCOMPLETE;
                // means: _all_ items have been processed,
                // and wpDrop should _not_ be called again
                // by the WPS for the next items, if any
    }

    return (mrc);
}

/*
 *@@ wpAddObjectGeneralPage:
 *      this adds the object "General" page
 *      to the settings notebook.
 *      We use different icons for the trash can,
 *      so we replace this page with our own dialog
 *      by calling xwpAddTrashCanGeneralPage.
 */

SOM_Scope ULONG  SOMLINK xtrc_wpAddObjectGeneralPage(XWPTrashCan *somSelf,
                                                     HWND hwndNotebook)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpAddObjectGeneralPage");

    return (XWPTrashCan_parent_WPFolder_wpAddObjectGeneralPage(somSelf,
                                                               hwndNotebook));
}

/*
 *@@ wpAddObjectGeneralPage2:
 *      this adds the second object "General" page
 *      for animation icons to the settings notebook.
 *      We don't support animation icons for the trash can,
 *      so we remove that page.
 */

SOM_Scope ULONG  SOMLINK xtrc_wpAddObjectGeneralPage2(XWPTrashCan *somSelf,
                                                      HWND hwndNotebook)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpAddObjectGeneralPage2");

    return (SETTINGS_PAGE_REMOVED);
}

/*
 *@@ wpAddFolderIncludePage:
 *      this adds the folder "Include" page
 *      to the settings notebook.
 *      We remove that page.
 */

SOM_Scope ULONG  SOMLINK xtrc_wpAddFolderIncludePage(XWPTrashCan *somSelf,
                                                     HWND hwndNotebook)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpAddFolderIncludePage");

    return (SETTINGS_PAGE_REMOVED);
}

/*
 *@@ wpAddSettingsPages:
 *      this instance method adds settings pages to
 *      an object's settings notebook, in this case.
 *      the "Trash can" settings page.
 */

SOM_Scope BOOL  SOMLINK xtrc_wpAddSettingsPages(XWPTrashCan *somSelf,
                                                HWND hwndNotebook)
{
    /* XWPTrashCanData *somThis = XWPTrashCanGetData(somSelf); */
    XWPTrashCanMethodDebug("XWPTrashCan","xtrc_wpAddSettingsPages");

    XWPTrashCan_parent_WPFolder_wpAddSettingsPages(somSelf, hwndNotebook);
    _xwpAddTrashCanDrivesPage(somSelf, hwndNotebook);
    _xwpAddTrashCanSettingsPage(somSelf, hwndNotebook);

    return (TRUE);
}

/* ******************************************************************
 *                                                                  *
 *   XWPTrashCan class methods                                      *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpclsDeleteIntoTrashCan:
 *            this deletes an object into the default
 *            trash can (with the object ID &lt;XWORKPLACE_TRASHCAN&gt;
 *            by invoking XWPTrashCan::xwpDeleteIntoTrashCan upon it.
 *
 *            This allows you to simply delete an object without
 *            having to query the default trash can first: simply
 *            call _xwpclsDeleteIntoTrashCan(_XWPTrashCan, pObject).
 */

SOM_Scope ULONG  SOMLINK xtrcM_xwpclsDeleteIntoTrashCan(M_XWPTrashCan *somSelf,
                                                        WPObject* pObject)
{
    /* M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf); */
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_xwpclsDeleteIntoTrashCan");

    /* Return statement to be customized: */
    return (0);
}

/*
 *@@ xwpclsSetDrivesSupport:
 *      this sets the drives which the trash can supports.
 *
 *      pabSupportedDrives must point to an array of 23
 *      bytes, specifiying the drives support. Index 0
 *      specifies drive C:, index 1 drive D:, and so on.
 *      (This implies that drives A: and B: are never
 *      supported.)
 *
 *      Each item in the array must be one of the following:
 *      -- XTRC_INVALID (0): drive is invalid, don't even
 *                  show it in the drives list.
 *      -- XTRC_SUPPORTED (1): drive is valid and supported
 *                  by the trash can.
 *      -- XTRC_UNSUPPORTED (2): drive is valid, but not
 *                  supported by the trash can.
 *
 *      NO CHECKING will be done on the values passed to
 *      this method. If you specify an invalid drive here,
 *      the trash can will probably go crazy with white
 *      hard-error boxes when populating.
 *
 *      If (pabSupportedDrives == NULL), the trash can
 *      will reset the drives support to safe default
 *      values.
 *
 *@@added V0.9.1 (99-12-13) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xtrcM_xwpclsSetDrivesSupport(M_XWPTrashCan *somSelf,
                                                     PBYTE pabSupportedDrives)
{
    BOOL brc = FALSE;
    // M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf);
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_xwpclsSetDrivesSupport");

    if (cmnLock(5000))
    {
        if (pabSupportedDrives)
        {
            // drives specified:
            memcpy(abSupportedDrives, pabSupportedDrives, CB_SUPPORTED_DRIVES);
            // write to INI
            PrfWriteProfileData(HINI_USER,
                                INIAPP_XWORKPLACE, INIKEY_TRASHCANDRIVES,
                                abSupportedDrives,
                                sizeof(abSupportedDrives));
        }
        else
        {
            // pointer is NULL:
            CHAR    szFSType[30];
            ULONG   ulLogicalDrive = 3;     // start with drive C:
            BYTE    bIndex = 0;             // index into abSupportedDrives

            memset(abSupportedDrives, 0, sizeof(abSupportedDrives));

            for (ulLogicalDrive = 3;
                 ulLogicalDrive < CB_SUPPORTED_DRIVES + 3;
                 ulLogicalDrive++)
            {
                APIRET  arc = doshAssertDrive(ulLogicalDrive);

                switch (arc)
                {
                    case NO_ERROR:
                        abSupportedDrives[bIndex] = XTRC_SUPPORTED;
                    break;

                    case ERROR_INVALID_DRIVE:
                        abSupportedDrives[bIndex] = XTRC_INVALID;
                    break;

                    default:
                        // this includes ERROR_NOT_READY, ERROR_NOT_SUPPORTED
                        abSupportedDrives[bIndex] = XTRC_UNSUPPORTED;
                }

                bIndex++;
            }

            // delete INI key
            PrfWriteProfileString(HINI_USER,
                                  INIAPP_XWORKPLACE, INIKEY_TRASHCANDRIVES,
                                  NULL);        // delete
        }

        brc = TRUE;

        cmnUnlock();
    }

    return (brc);
}

/*
 *@@ xwpclsQueryDrivesSupport:
 *      this copies the current trash can drives support
 *      to the specified buffer.
 *
 *      pabSupportedDrives must point to an array of 23
 *      bytes, receiving the drives support. Index 0 then
 *      specifies drive C:, index 1 drive D:, and so on.
 *      (This implies that drives A: and B: are never
 *      supported.)
 *
 *      Each item in the array will be one of the following:
 *      -- XTRC_INVALID (0): drive is invalid, don't even
 *                  show it in the drives list.
 *      -- XTRC_SUPPORTED (1): drive is valid and supported
 *                  by the trash can.
 *      -- XTRC_UNSUPPORTED (2): drive is valid, but not
 *                  supported by the trash can.
 *
 *@@added V0.9.1 (99-12-13) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xtrcM_xwpclsQueryDrivesSupport(M_XWPTrashCan *somSelf,
                                                       PBYTE pabSupportedDrives)
{
    M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf);
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_xwpclsQueryDrivesSupport");

    /* Return statement to be customized: */
    return (FALSE);
}

/*
 *@@ wpclsInitData:
 *      this class methods allows the class to
 *      initialize itself.
 */

SOM_Scope void  SOMLINK xtrcM_wpclsInitData(M_XWPTrashCan *somSelf)
{
    M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf);
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_wpclsInitData");

    M_XWPTrashCan_parent_M_WPFolder_wpclsInitData(somSelf);

    // initialize class data
    _pDefaultTrashCan = NULL;

    // enforce initialization of XWPTrashObject class by
    // creating the class object
    // SOMClass *pTrashObjectClassObject = pTrashObjectClassObject =
            XWPTrashObjectNewClass(XWPTrashObject_MajorVersion,
                                   XWPTrashObject_MinorVersion);


    {
        PKERNELGLOBALS   pKernelGlobals = krnLockGlobals(5000);
        // store the class object in KERNELGLOBALS
        krnUnlockGlobals();
    }

    // initialize supported drives
    if (abSupportedDrives[0] == 0)
    {
        ULONG   cbSupportedDrives = sizeof(abSupportedDrives);
        memset(abSupportedDrives, XTRC_INVALID, cbSupportedDrives);
        if (!PrfQueryProfileData(HINI_USER,
                                 INIAPP_XWORKPLACE, INIKEY_TRASHCANDRIVES,
                                 abSupportedDrives,
                                 &cbSupportedDrives))
            // data not found:
            _xwpclsSetDrivesSupport(somSelf,
                                    NULL);     // defaults
    }
}

/*
 *@@ wpclsQueryTitle:
 *      tell the WPS the new class default title:
 *      "Trash can".
 */

SOM_Scope PSZ  SOMLINK xtrcM_wpclsQueryTitle(M_XWPTrashCan *somSelf)
{
    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    /* M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf); */
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_wpclsQueryTitle");

    return (pNLSStrings->pszTrashCan);
}

/*
 *@@ wpclsQueryStyle:
 *      we return a flag so that no trash can templates are created.
 */

SOM_Scope ULONG  SOMLINK xtrcM_wpclsQueryStyle(M_XWPTrashCan *somSelf)
{
    /* M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf); */
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_wpclsQueryStyle");

    return (CLSSTYLE_DONTTEMPLATE
                | CLSSTYLE_NEVERCOPY    // but allow move
                | CLSSTYLE_NEVERDELETE
                | CLSSTYLE_NEVERPRINT);
}

/*
 *@@ wpclsQueryIconData:
 *      this should return the class default icon,
 *      which for XWPTrashCan will be the standard
 *      trash object.
 */

SOM_Scope ULONG  SOMLINK xtrcM_wpclsQueryIconData(M_XWPTrashCan *somSelf,
                                                  PICONINFO pIconInfo)
{
    /* M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf); */
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_wpclsQueryIconData");

    if (pIconInfo) {
       pIconInfo->fFormat = ICON_RESOURCE;
       pIconInfo->resid   = ID_ICONXWPTRASHEMPTY;
       pIconInfo->hmod    = cmnQueryMainModuleHandle();
    }

    return (sizeof(ICONINFO));
}

/*
 *@@ wpclsQueryIconDataN:
 *      this should return the class default
 *      "animation" icons (for open folders).
 *      The trashcan does not use an animation
 *      icon, but only "empty" or "not empty"
 *      icons, so we return the same icon
 *      as in M_XWPTrashCan::wpclsQueryIconData.
 */

SOM_Scope ULONG  SOMLINK xtrcM_wpclsQueryIconDataN(M_XWPTrashCan *somSelf,
                                                   ICONINFO* pIconInfo,
                                                   ULONG ulIconIndex)
{
    /* M_XWPTrashCanData *somThis = M_XWPTrashCanGetData(somSelf); */
    M_XWPTrashCanMethodDebug("M_XWPTrashCan","xtrcM_wpclsQueryIconDataN");

    if (pIconInfo) {
       pIconInfo->fFormat = ICON_RESOURCE;
       pIconInfo->resid   = ID_ICONXWPTRASHEMPTY;
       pIconInfo->hmod    = cmnQueryMainModuleHandle();
    }

    return (sizeof(ICONINFO));
}

/* ******************************************************************
 *                                                                  *
 *   XWPTrashObject instance methods                                *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpSetRelatedObject:
 *      this instance method sets the object in the
 *      "\Trash" directories which this trash object
 *      should represent.
 *
 *      This method only gets called once while the
 *      trash object is being initialized (from
 *      XWPTrashObject::wpSetup) and should not be
 *      called manually.
 */

SOM_Scope BOOL  SOMLINK xtro_xwpSetRelatedObject(XWPTrashObject *somSelf,
                                                 WPObject* pObject)
{
    BOOL brc = FALSE;
    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpSetRelatedObject");

    _pRelatedObject = pObject;

    if (pObject)
    {
        // adjust our own title
        _wpSetTitle(somSelf, _wpQueryTitle(pObject));
        // and icon
        _wpSetIcon(somSelf, _wpQueryIcon(pObject));
        // and make sure this icon is not destroyed
        _wpSetStyle(somSelf,
                    _wpQueryStyle(somSelf) & ~OBJSTYLE_CUSTOMICON);
        // set size of related object
        if (_somIsA(pObject, _WPFileSystem))
            _ulSize = _wpQueryFileSize(pObject);
        else
            // abstract object:
            _ulSize = 0;
        brc = TRUE;
    }
    return (brc);
}

/*
 *@@ xwpQueryRelatedObject:
 *      this returns the object in the "\Trash"
 *      directories which this trash object
 *      represents. The result may be an instance
 *      of any WPS class.
 *
 *      Returns NULL upon errors.
 *
 *      This may be called at any time.
 */

SOM_Scope WPObject*  SOMLINK xtro_xwpQueryRelatedObject(XWPTrashObject *somSelf)
{
    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpQueryRelatedObject");

    return (_pRelatedObject);
}

/*
 *@@ xwpQueryRelatedPath:
 *      this returns a PSZ to the original path where
 *      the related object was deleted from. This PSZ
 *      points to the trash object's instance data,
 *      so you better not modify it.
 *
 *      Note that this source directory might no longer
 *      exist, if a whole folder tree was moved into
 *      the trash can.
 */

SOM_Scope PSZ SOMLINK xtro_xwpQueryRelatedPath(XWPTrashObject *somSelf)
{
    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpQueryRelatedPath");

    #ifdef DEBUG_TRASHCAN
        _Pmpf(("  Entering xwpQueryRelatedPath for %s", _wpQueryTitle(somSelf)));
    #endif

    if (_pszSourcePath == NULL)
        // source path not queried yet:
        // do it now
        #ifdef DEBUG_TRASHCAN_
            Pmpf(("    pRelatedObject: 0x%lX", _pRelatedObject));
        #endif

        if (_pRelatedObject)
        {
            WPFolder *pTrashDir = _wpQueryFolder(_pRelatedObject);

            #ifdef DEBUG_TRASHCAN
                _Pmpf(("    pTrashDir: 0x%lX", pTrashDir));
            #endif

            if (pTrashDir)
            {
                CHAR szPathInTrash[CCHMAXPATH];
                if (_wpQueryFilename(pTrashDir, szPathInTrash, TRUE))
                {
                    CHAR szSourcePath[CCHMAXPATH];

                    #ifdef DEBUG_TRASHCAN
                        _Pmpf(("    szPathInTrash: %s", szPathInTrash));
                    #endif

                    // copy drive letter
                    szSourcePath[0] = szPathInTrash[0];
                    // copy ':'
                    szSourcePath[1] = ':';
                    // copy stuff after "?:\Trash"
                    strcpy(&(szSourcePath[2]), &(szPathInTrash[8]));
                    _pszSourcePath = strdup(szSourcePath);
                }
            }
        }

    return (_pszSourcePath);
}

/*
 * @@ xwpQueryRelatedSize:
 *      returns the size of the related object. This
 *      is 0 if the related object is not a file-system
 *      object (WPFileSystem or subclasses).
 */

SOM_Scope ULONG  SOMLINK xtro_xwpQueryRelatedSize(XWPTrashObject *somSelf)
{
    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpQueryRelatedSize");

    return (_ulSize);
}

/*
 *@@ xwpValidateTrashObject:
 *      this performs all kinds of checks on the trash
 *      object and its related object. If any errors
 *      are found, a value != NO_ERROR is returned and
 *      the trash object destroys itself by calling wpFree().
 *
 *      Return values:
 *      --  ERROR_INVALID_HANDLE: internal pointer to related object
 *                                      is NULL
 *      --  ERROR_FILE_NOT_FOUND: related object no longer exists
 */

SOM_Scope APIRET  SOMLINK xtro_xwpValidateTrashObject(XWPTrashObject *somSelf)
{
    APIRET  arc = NO_ERROR;

    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpValidateTrashObject");

    if (_pRelatedObject == 0)
        // not set yet:
        arc = ERROR_INVALID_HANDLE;
    else
        if (!wpshCheckObject(_pRelatedObject))
            // pointer invalid:
            arc = ERROR_FILE_NOT_FOUND;

    if (arc != NO_ERROR)
        _wpFree(somSelf);

    return (arc);
}

/*
 *@@ xwpDestroyTrashObject:
 *      this deletes the object which this trash
 *      object represents from the "\Trash" directories
 *      by calling wpFree upon it.
 *
 *      Note that no confirmation is displayed. Also,
 *      all objects are destroyed, no matter whether
 *      they have the "no delete" style or not, or even
 *      if they are system or read-only files.
 *
 *      After that, if the delete was successful,
 *      the trash object (somSelf) destroys itself by
 *      calling wpFree (since it has no further
 *      meaning) and returns TRUE.
 *
 *      As a consequence, the somSelf pointer to the trash
 *      object is no longer valid if TRUE is returned here.
 */

SOM_Scope BOOL  SOMLINK xtro_xwpDestroyTrashObject(XWPTrashObject *somSelf)
{
    BOOL brc = FALSE;
    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpDestroyTrashObject");

    // first check whether the object is valid
    if (_xwpValidateTrashObject(somSelf) != NO_ERROR)
        // error occured: means that somSelf has been destructed already
        brc = TRUE;
    else
    {
        if (_pRelatedObject)
        {
            // get \trash directory of related object
            WPFolder* pTrashDir = _wpQueryFolder(_pRelatedObject);

            if (pTrashDir)
            {
                // unset "no delete" style flag
                ULONG ulStyle = _wpQueryStyle(_pRelatedObject);

                /* if (_somIsA(_pRelatedObject, _WPFileSystem))
                {
                    // unset system, readonly, hidden attributes
                    CHAR    szFilename[CCHMAXPATH] = "";
                    ULONG   ulAttrs = 0;
                    _wpQueryFilename(_pRelatedObject,
                                     szFilename,
                                     TRUE);    // qualified
                    if (doshQueryPathAttr(szFilename,
                                          &ulAttrs)
                                == NO_ERROR)
                        if (ulAttrs & (FILE_READONLY | FILE_SYSTEM | FILE_HIDDEN))
                            _wpSetAttr(_pRelatedObject,
                                       ulAttrs & ~(FILE_READONLY | FILE_SYSTEM | FILE_HIDDEN));
                } */

                // unset "no delete" flag
                if (ulStyle & OBJSTYLE_NODELETE)
                    _wpSetStyle(_pRelatedObject, ulStyle & ~OBJSTYLE_NODELETE);

                // destroy related object
                if (_wpFree(_pRelatedObject))
                {
                    // successfully deleted:
                    // update the trashcan (folder of trash object)
                    // by killing ourselves
                    XWPTrashCan* pTrashCan = _wpQueryFolder(somSelf);
                    if (_wpFree(somSelf))
                        if (pTrashCan)
                            if (_somIsA(pTrashCan, _XWPTrashCan))
                            {
                                // decrease trash object count in trash can
                                XWPTrashCanData *pTrashCanData = XWPTrashCanGetData(pTrashCan);
                                pTrashCanData->ulTrashObjectCount--;
                                pTrashCanData->dTotalSize -= _ulSize;
                                _xwpSetCorrectTrashIcon(pTrashCan);
                            }

                    // check if other objects still exist in
                    // the subdirectory of "\Trash" where the
                    // related object was
                    /* while (pTrashDir)
                    {
                        WPFolder* pParent = _wpQueryFolder(pTrashDir);
                        if (!_somIsA(pTrashDir, _WPRootFolder))
                        {
                            // no root folder:
                            // check contents
                            if (_wpQueryContent(pTrashDir, NULL, QC_FIRST) == NULL)
                            {
                                // no other items in there:
                                // get rid of it
                                _wpFree(pTrashDir);
                            }
                        }
                        else
                            // root folder: stop
                            break;

                        // and climb up the folder tree
                        pTrashDir = pParent;
                    } */
                }
            }
        }
    }

    return (brc);
}

/*
 *@@ xwpRestoreRelatedObject:
 *      this restores the object which this trash
 *      object represents from the "\Trash" directories.
 *
 *      If (pTargetFolder != NULL), the object will
 *      be restored in the specified folder.
 *
 *      If (pTargetFolder == NULL), the object will
 *      be restored in the folder where it was originally
 *      deleted from. If that folder no longer exists,
 *      it will be recreated as a standard folder.
 *
 *      After that, if the restore was successful,
 *      the trash object (somSelf) destroys itself by
 *      calling wpFree (since it has no further
 *      meaning) and returns TRUE.
 *
 *      As a consequence, the somSelf pointer to the trash
 *      object is no longer valid if TRUE is returned here.
 */

SOM_Scope BOOL  SOMLINK xtro_xwpRestoreRelatedObject(XWPTrashObject *somSelf,
                                                     WPFolder* pTargetFolder)
{
    BOOL        brc = FALSE;
    PSZ         pszOriginalPath = NULL;
    WPFolder*   pTargetFolder2 = 0;

    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_xwpRestoreRelatedObject");

    if (_pRelatedObject)
    {
        if (pTargetFolder)
        {
            // target folder specified: use that one
            pTargetFolder2 = pTargetFolder;
        }
        else
        {
            // target folder not specified: use the original dir
            // where the object was deleted from
            if (pszOriginalPath = _xwpQueryRelatedPath(somSelf))
            {
                // make sure that the original directory exists;
                // it might not if a whole folder (tree) was
                // moved into the trash can.
                // If it does, this func will do nothing.
                doshCreatePath(pszOriginalPath,
                               FALSE);   // do not hide those directories

                pTargetFolder2 = _wpclsQueryFolder(_WPFolder,
                                                   pszOriginalPath,
                                                   TRUE);       // lock object
            }
        }

        if (pTargetFolder2)
        {
            // folder exists:
            // check if object exists in that folder already
            // (this might call the XFldObject replacement)
            WPObject    *pReplaceThis = NULL;
            CHAR        szNewTitle[CCHMAXPATH] = "";
            BOOL        fMove = TRUE;
            ULONG       ulAction;

            strcpy(szNewTitle, _wpQueryTitle(_pRelatedObject));
            ulAction = _wpConfirmObjectTitle(_pRelatedObject,      // object
                                             pTargetFolder2,       // folder
                                             &pReplaceThis,        // object to replace (if NAMECLASH_REPLACE)
                                             szNewTitle,           // in/out: object title
                                             sizeof(szNewTitle),
                                             0x006B);              // move code

            switch (ulAction)
            {
                case NAMECLASH_CANCEL:
                    fMove = FALSE;
                break;

                case NAMECLASH_RENAME:
                    _wpSetTitle(_pRelatedObject,
                                szNewTitle);      // set by wpConfirmObjectTitle
                break;

                case NAMECLASH_REPLACE:
                    _wpReplaceObject(_pRelatedObject,
                                     pReplaceThis,       // set by wpConfirmObjectTitle
                                     TRUE);              // move and replace
                    fMove = FALSE;
                break;

                // NAMECLASH_NONE: just go on
            }

            if (fMove)
                // move related object
                if (_wpMoveObject(_pRelatedObject, pTargetFolder2))
                    // successful: destroy the trash object
                    brc = _wpFree(somSelf);
        }
    } // end if (_pRelatedObject)

    return (brc);
}

/*
 *@@ wpInitData:
 *      this instance method gets called when the object
 *      is being initialized. We initialize our instance
 *      data here.
 */

SOM_Scope void  SOMLINK xtro_wpInitData(XWPTrashObject *somSelf)
{
    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpInitData");

    XWPTrashObject_parent_WPTransient_wpInitData(somSelf);

    _pRelatedObject = NULL;
    _pszSourcePath = NULL;
    _ulSize = 0;
}

/*
 *@@ wpSetup:
 *      this instance method allows the object to set its
 *      state based on a setup string. This gets called
 *      whenever setup strings are set upon an object.
 *
 *      Most importantly to us, this method gets called
 *      during the processing of wpInitData, which in
 *      turn calls wpSetupOnce, which in turn calls this
 *      method.
 *
 *      This is where we need to set the "related object"
 *      which this trash object points to, because this
 *      must be done while the object is being initialized.
 *      For this, we use the RELATEDOBJECT setup string.
 *      If we do this later, wpQueryDetailsData would return
 *      garbage.
 *
 *      The syntax of RELATEDOBJECT is "RELATEDOBJECT=handle",
 *      with "handle" being the string representation of
 *      the hexadecimal, five-digit object handle of the
 *      related object.
 */

SOM_Scope BOOL  SOMLINK xtro_wpSetup(XWPTrashObject *somSelf,
                                     PSZ pszSetupString)
{
    CHAR    szHObject[100];
    ULONG   cbHObject = sizeof(szHObject);

    // XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpSetup");

    if (_wpScanSetupString(somSelf,
                           pszSetupString,       // as passed to us
                           "RELATEDOBJECT",
                           szHObject,
                           &cbHObject))
    {
        HOBJECT hobj = 0;
        sscanf(szHObject, "%lX", &hobj);
        _xwpSetRelatedObject(somSelf, _wpclsQueryObject(_WPObject, hobj));
    }

    return (XWPTrashObject_parent_WPTransient_wpSetup(somSelf,
                                                      pszSetupString));
}

/*
 *@@ wpUnInitData:
 *      this instance method is called to allow the object
 *      to free allocated resources.
 *      The parent method must be called after our own
 *      processing.
 */

SOM_Scope void  SOMLINK xtro_wpUnInitData(XWPTrashObject *somSelf)
{
    // XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpUnInitData");

    XWPTrashObject_parent_WPTransient_wpUnInitData(somSelf);
}

/*
 * wpQueryDetailsData:
 *      this instance method must fill in the details
 *      data which was abstractly defined by
 *      M_XWPTrashObject::wpclsQueryDetailsInfo.
 *      We'll fill in the trash object details here.
 */

SOM_Scope ULONG  SOMLINK xtro_wpQueryDetailsData(XWPTrashObject *somSelf,
                                                 PVOID* ppDetailsData,
                                                 PULONG pcp)
{
    // return value: TRUE or FALSE, even though it's a ULONG
    ULONG ulrc;

    XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpQueryDetailsData");

    // call the parent first; this moves ppDetailsData to
    // point to the new data added by XWPTrashObject
    // (in the wpclsQueryDetailsInfo structure)
    ulrc = XWPTrashObject_parent_WPTransient_wpQueryDetailsData(somSelf,
                                                                ppDetailsData,
                                                                pcp);

    // pointer valid?
    if (ppDetailsData)
    {
        PXTRO_DETAILS pDetails = (PXTRO_DETAILS)*ppDetailsData;
        pDetails->pszSourcePath = _xwpQueryRelatedPath(somSelf);
        if (_pRelatedObject)
        {
            // set deletion date and time fiels by calling
            // the XFldObject method:
            _xwpQueryDeletion(_pRelatedObject,
                              &pDetails->cdateDeleted,
                              &pDetails->ctimeDeleted);
            pDetails->ulSize = _ulSize;
        }
        // move the pointer past our details structure
        *ppDetailsData = ((PBYTE) (*ppDetailsData)) + sizeof(XTRO_DETAILS);
    }
    else
    {
        // ppDetailsData == NULL:
        // caller is querying size of buffer
        *pcp += sizeof(XTRO_DETAILS);
    }

    return (ulrc);
}

/*
 *@@ wpFilterPopupMenu:
 *      this instance method allows the object to filter out
 *      unwanted menu items from the context menu.
 */

SOM_Scope ULONG  SOMLINK xtro_wpFilterPopupMenu(XWPTrashObject *somSelf,
                                                ULONG ulFlags,
                                                HWND hwndCnr,
                                                BOOL fMultiSelect)
{
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpFilterPopupMenu");

    return (XWPTrashObject_parent_WPTransient_wpFilterPopupMenu(somSelf,
                                                                ulFlags,
                                                                hwndCnr,
                                                                fMultiSelect)
            // remove the whole "Open" menu, since
            // trash objects cannot be opened
            & ~(CTXT_OPEN)
        );
}

/*
 *@@ wpModifyPopupMenu:
 *      this instance methods allows the object to manipulate
 *      its context menu.
 *      We add the trash object menu items here.
 */

SOM_Scope BOOL  SOMLINK xtro_wpModifyPopupMenu(XWPTrashObject *somSelf,
                                               HWND hwndMenu,
                                               HWND hwndCnr,
                                               ULONG iPosition)
{
    BOOL brc = FALSE;
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpModifyPopupMenu");

    brc = XWPTrashObject_parent_WPTransient_wpModifyPopupMenu(somSelf,
                                                                hwndMenu,
                                                                hwndCnr,
                                                                iPosition);
    if (brc)
    {
        PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
        PNLSSTRINGS     pNLSStrings = cmnQueryNLSStrings();
        // insert separator
        winhInsertMenuSeparator(hwndMenu, MIT_END,
                                (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_SEPARATOR));

        // insert "Restore object"
        winhInsertMenuItem(hwndMenu, MIT_END,
                           (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_TRASHRESTORE),
                           pNLSStrings->pszTrashRestore,
                           MIS_TEXT,   // style
                           0);        // attributes

        // insert "Restore object"
        winhInsertMenuItem(hwndMenu, MIT_END,
                           (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_TRASHDESTROY),
                           pNLSStrings->pszTrashDestroy,
                           MIS_TEXT,   // style
                           0);        // attributes
    }

    return (brc);
}

/*
 *@@ wpMenuItemSelected:
 *      this instance method gets called when a menu item
 *      was selected in the object's context menu.
 *      We need to react to our new menu items here.
 */

SOM_Scope BOOL  SOMLINK xtro_wpMenuItemSelected(XWPTrashObject *somSelf,
                                                HWND hwndFrame,
                                                ULONG ulMenuId)
{
    BOOL brc = FALSE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpMenuItemSelected");

    if (ulMenuId == (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_TRASHRESTORE))
    {
        // "Restore object":
        brc = _xwpRestoreRelatedObject(somSelf,
                                       NULL);       // use original folder
    }
    else if (ulMenuId == (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_TRASHDESTROY))
    {
        // "Destroy object":
        brc = _xwpDestroyTrashObject(somSelf);
    }
    // none of our menu items: call default
    else
        brc = XWPTrashObject_parent_WPTransient_wpMenuItemSelected(somSelf,
                                                                 hwndFrame,
                                                                 ulMenuId);

    return (brc);
}

/*
 *@@ wpMenuItemHelpSelected:
 *      this instance method gets called when help is
 *      requested for a menu item in the object's context menu.
 *      We need to display help for our new menu items here.
 */

SOM_Scope BOOL  SOMLINK xtro_wpMenuItemHelpSelected(XWPTrashObject *somSelf,
                                                    ULONG MenuId)
{
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpMenuItemHelpSelected");

    return (XWPTrashObject_parent_WPTransient_wpMenuItemHelpSelected(somSelf,
                                                                     MenuId));
}

/*
 *@@ wpQueryDefaultHelp:
 *      this instance method specifies the default
 *      help panel for this instance; display some
 *      help for the trash object.
 */

SOM_Scope BOOL  SOMLINK xtro_wpQueryDefaultHelp(XWPTrashObject *somSelf,
                                                PULONG pHelpPanelId,
                                                PSZ HelpLibrary)
{
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpQueryDefaultHelp");

    strcpy(HelpLibrary, cmnQueryHelpLibrary());
    *pHelpPanelId = ID_XSH_SETTINGS_TRASHCAN;
    return (TRUE);

    /* return (XWPTrashObject_parent_WPTransient_wpQueryDefaultHelp(somSelf,
                                                                 pHelpPanelId,
                                                                 HelpLibrary)); */
}

/*
 *@@ wpMoveObject:
 *      this instance method gets called by the WPS on an
 *      object if it is to be moved.
 *
 *      Since we don't really want to move trash objects
 *      out of a trash can, but rather restore the object
 *      to the target folder instead, we will do this here.
 *      This way we need not mess with the drag'n'drop
 *      stuff, and the other move invocations will work
 *      also.
 *
 *      So we call XWPTrashObject::xwpRestoreRelatedObject
 *      here.
 */

SOM_Scope BOOL  SOMLINK xtro_wpMoveObject(XWPTrashObject *somSelf,
                                          WPFolder* Folder)
{
    // XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf);
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpMoveObject");

    return (_xwpRestoreRelatedObject(somSelf,
                                     Folder));  // move-target folder to recreate object in
        // this destroys somSelf
}

/*
 *@@ wpOpen:
 *      this instance method opens a new view of an object.
 *      Since trash objects have no views, we'll always
 *      return NULLHANDLE.
 */

SOM_Scope HWND  SOMLINK xtro_wpOpen(XWPTrashObject *somSelf,
                                    HWND hwndCnr, ULONG ulView,
                                    ULONG param)
{
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpOpen");

    return (NULLHANDLE);

}

/*
 *@@ wpDragOver:
 *      this instance method is called to inform the object
 *      that other objects are being dragged over it.
 *      We'll make sure that nothing can be dropped upon
 *      a trash object.
 */

SOM_Scope MRESULT  SOMLINK xtro_wpDragOver(XWPTrashObject *somSelf,
                                           HWND hwndCnr,
                                           PDRAGINFO pdrgInfo)
{
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpDragOver");

    return ((MRESULT)DOR_NEVERDROP   // object does not accept d'n'd
                );
}

/*
 *@@ wpDrop:
 *      this instance method is called to inform an object that
 *      another object has been dropped on it.
 *      We'll make sure that nothing can be dropped upon
 *      a trash object.
 */

SOM_Scope MRESULT  SOMLINK xtro_wpDrop(XWPTrashObject *somSelf,
                                       HWND hwndCnr,
                                       PDRAGINFO pdrgInfo,
                                       PDRAGITEM pdrgItem)
{
    /* XWPTrashObjectData *somThis = XWPTrashObjectGetData(somSelf); */
    XWPTrashObjectMethodDebug("XWPTrashObject","xtro_wpDrop");

    return ((MRESULT)RC_DROP_ERROR);
}

/* ******************************************************************
 *                                                                  *
 *   XWPTrashObject class methods                                   *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpclsCreateTrashObject:
 *            this creates a new transient "trash object" in the
 *            given trashcan by invoking wpclsNew upon the XWPTrashObject
 *            class object (somSelf of this method).
 *
 *            Arguments:
 *            -- <B>pTrashCan:</B> the trashcan to create the object in.
 *            -- <B>pRelatedObject:</B> the object which the new trash object
 *               should be related to. We use a RELATEDOBJECT settings
 *               string with wpclsNew to set the related object
 *               (see XWPTrashObject::wpSetup).
 *
 *            This returns the new trash object. If NULL is returned,
 *            either an error occured creating the trash object or
 *            a trash object with the same pRelatedObject already
 *            existed in the trash can.
 *
 *            <B>Note:</B> This does not move the related object to a trash can.
 *            This method is only used internally by XWPTrashCan to
 *            map the contents of the "\Trash" directories into the
 *            open trashcan.
 *
 *            To move an object into a trashcan, call
 *            XWPTrashCan::xwpDeleteIntoTrashCan, which automatically
 *            determines whether this method needs to be called.
 */

SOM_Scope XWPTrashObject*  SOMLINK xtroM_xwpclsCreateTrashObject(M_XWPTrashObject *somSelf,
                                                                 XWPTrashCan* pTrashCan,
                                                                 WPObject* pRelatedObject)
{
    XWPTrashObject *pTrashObject = NULL;

    /* M_XWPTrashObjectData *somThis = M_XWPTrashObjectGetData(somSelf); */
    M_XWPTrashObjectMethodDebug("M_XWPTrashObject","xtroM_xwpclsCreateTrashObject");

    if ( (pTrashCan) && (pRelatedObject) )
    {
        CHAR        szSetupString[100];
        // PLINKLIST   pllTrashObjects;
        // PLISTNODE   pNode = 0;
        BOOL        fRelatedExistsAlready = FALSE,
                    fTrashCanSemOwned = FALSE;

        TRY_LOUD(excpt1, NULL)
        {
            PLINKLIST pllTrashObjects;
            PLISTNODE pNode = 0;

            // check if the object already exists in the
            // trash can; we must do this because wpPopulate
            // gets called from wpRefresh also.
            // If the trash can has not been populated yet,
            // we need not worry, because then we definitely
            // have no trash objects in the trash can.
            fTrashCanSemOwned = !_wpRequestObjectMutexSem(pTrashCan, SEM_INDEFINITE_WAIT);
            pllTrashObjects = CreateTrashObjectsList(pTrashCan);

            // now delete the items
            pNode = lstQueryFirstNode(pllTrashObjects);
            while (pNode)
            {
                WPObject *pTestRelatedObject = _xwpQueryRelatedObject(
                            (XWPTrashObject*)pNode->pItemData); // item data is trash object

                if (pTestRelatedObject == pRelatedObject)
                {
                    // exists already: set flag and break
                    fRelatedExistsAlready = TRUE;
                    break; // while (pNode)
                }

                // go for next
                pNode = pNode->pNext;
            } // end while (pNode)

            lstFree(pllTrashObjects);
        }
        CATCH(excpt1) { } END_CATCH();

        if (fTrashCanSemOwned)
        {
            _wpReleaseObjectMutexSem(pTrashCan);
            fTrashCanSemOwned = FALSE;
        }

        if (!fRelatedExistsAlready)
        {
            // related object not found above: go!
            #ifdef DEBUG_TRASHCAN
                _Pmpf(("        Creating trash object \"%s\" in \"%s\"",
                        _wpQueryTitle(pRelatedObject),
                        _wpQueryTitle(pTrashCan)));
            #endif

            // we must pass the related object as a setup string,
            // because otherwise the Details data (which is initialized
            // at object creation only) will not know about this (duh)
            sprintf(szSetupString, "RELATEDOBJECT=%lX",
                    _wpQueryHandle(pRelatedObject));
            pTrashObject = _wpclsNew(somSelf,   // class object
                                     _wpQueryTitle(pRelatedObject),
                                     szSetupString, // setup string
                                     pTrashCan,     // where to create the object
                                     TRUE);  // lock
        }
    }

    return (pTrashObject);
}

/*
 *@@ wpclsInitData:
 *      this class methods allows the class to
 *      initialize itself.
 */

SOM_Scope void  SOMLINK xtroM_wpclsInitData(M_XWPTrashObject *somSelf)
{
    PCLASSFIELDINFO pcfi;
    ULONG           i;
    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();

    /* M_XWPTrashObjectData *somThis = M_XWPTrashObjectGetData(somSelf); */
    M_XWPTrashObjectMethodDebug("M_XWPTrashObject","xtroM_wpclsInitData");

    M_XWPTrashObject_parent_M_WPTransient_wpclsInitData(somSelf);

    {
        PKERNELGLOBALS   pKernelGlobals = krnLockGlobals(5000);
        // store the class object in KERNELGLOBALS
        pKernelGlobals->fXWPTrashCan = TRUE;
        krnUnlockGlobals();
    }

    // initialize the extra data file details
    // in the global variable at the top of this file
    for (i = 0, pcfi = acfiTrashObject;
         i < XTRO_EXTRAFIELDS;
         i++, pcfi++)
    {
        memset((PCH)pcfi, 0, sizeof(CLASSFIELDINFO));

        pcfi->cb        = sizeof(CLASSFIELDINFO);

        // data column flags
        pcfi->flData    = CFA_SEPARATOR
                            | CFA_FIREADONLY
                            | CFA_VCENTER       // vertical align
                            // | CFA_LEFT          // horizontal align
                            // | CFA_INVISIBLE
                            ;

        // column title flags
        pcfi->flTitle   = CFA_FITITLEREADONLY
                            | CFA_VCENTER
                            | CFA_CENTER
                            ;

        pcfi->pNextFieldInfo = pcfi + 1;       /* point to next CLASSFIELDINFO */

        switch (i)
        {
            // first item: original path
            case 0:
                pcfi->flCompare   = COMPARE_SUPPORTED | SORTBY_SUPPORTED;
                pcfi->pfnCompare   = 0; // (PFNCOMPARE)fnCompareExtensions;
                pcfi->flData            |= CFA_STRING | CFA_LEFT;
                pcfi->pTitleData        = pNLSStrings->pszOrigFolder;
                pcfi->offFieldData      = (ULONG)(FIELDOFFSET(XTRO_DETAILS, pszSourcePath));
                pcfi->ulLenFieldData    = sizeof(PSZ);
                pcfi->DefaultComparison = CMP_GREATER;
            break;

            // second item: deletion date
            case 1:
                pcfi->flCompare   = COMPARE_SUPPORTED | SORTBY_SUPPORTED;
                pcfi->pfnCompare   = 0; // (PFNCOMPARE)fnCompareExtensions;
                pcfi->flData            |= CFA_DATE | CFA_RIGHT;
                pcfi->pTitleData        = pNLSStrings->pszDelDate;
                pcfi->offFieldData      = (ULONG)(FIELDOFFSET(XTRO_DETAILS, cdateDeleted));
                pcfi->ulLenFieldData    = sizeof(CDATE);
                pcfi->DefaultComparison = CMP_GREATER;
            break;

            // third item: deletion time
            case 2:
                pcfi->flCompare   = COMPARE_SUPPORTED | SORTBY_SUPPORTED;
                pcfi->pfnCompare   = 0; // (PFNCOMPARE)fnCompareExtensions;
                pcfi->flData            |= CFA_TIME | CFA_RIGHT;
                pcfi->pTitleData        = pNLSStrings->pszDelTime;
                pcfi->offFieldData      = (ULONG)(FIELDOFFSET(XTRO_DETAILS, ctimeDeleted));
                pcfi->ulLenFieldData    = sizeof(CTIME);
                pcfi->DefaultComparison = CMP_GREATER;
            break;

            // fourth item: size of related object
            case 3:
                pcfi->flCompare   = COMPARE_SUPPORTED | SORTBY_SUPPORTED;
                pcfi->pfnCompare   = 0; // (PFNCOMPARE)fnCompareExtensions;
                pcfi->flData            |= CFA_ULONG | CFA_RIGHT;
                pcfi->pTitleData        = pNLSStrings->pszSize;
                pcfi->offFieldData      = (ULONG)(FIELDOFFSET(XTRO_DETAILS, ulSize));
                pcfi->ulLenFieldData    = sizeof(ULONG);
                pcfi->DefaultComparison = CMP_GREATER;
            break;
        }   // end for
    } // end for

    // finally, terminate the linked list
    acfiTrashObject[XTRO_EXTRAFIELDS-1].pNextFieldInfo = NULL;
}

/*
 *@@ wpclsCreateDefaultTemplates:
 *      this is called by the system to allow a class to
 *      create its default templates. The default WPS
 *      behavior is to create new templates if the class
 *      default title is different from the existing
 *      templates, but since we never want templates for
 *      trash objects, we'll have to suppress this
 *      behavior.
 */

SOM_Scope BOOL  SOMLINK xtroM_wpclsCreateDefaultTemplates(M_XWPTrashObject *somSelf,
                                                          WPObject* Folder)
{
    /* M_XWPTrashObjectData *somThis = M_XWPTrashObjectGetData(somSelf); */
    M_XWPTrashObjectMethodDebug("M_XWPTrashObject","xtroM_wpclsCreateDefaultTemplates");

    return (TRUE);
    // means that the Templates folder should _not_ create templates
    // by itself; we pretend that we've done this

    /* return (M_XWPTrashObject_parent_M_WPTransient_wpclsCreateDefaultTemplates(somSelf,
                                                                              Folder)); */
}

/*
 * wpclsQueryDetailsInfo:
 *      this class method is called by the WPS to find out
 *      what details info objects of this class can provide.
 *      The "abstract" data returned by this function needs
 *      to be filled with instance information by
 *      XWPTrashObject::wpQueryDetailsData.
 *      We'll define additional details for the trash objects
 *      here.
 */

SOM_Scope ULONG  SOMLINK xtroM_wpclsQueryDetailsInfo(M_XWPTrashObject *somSelf,
                                                     PCLASSFIELDINFO* ppClassFieldInfo,
                                                     PULONG pSize)
{
    ULONG ulParentColumns;
    PCLASSFIELDINFO pcfi;
    ULONG           i;

    /* M_XWPTrashObjectData *somThis = M_XWPTrashObjectGetData(somSelf); */
    M_XWPTrashObjectMethodDebug("M_XWPTrashObject","xtroM_wpclsQueryDetailsInfo");

    // always call the parent method first to retrieve the number of
    // details columns and any data already defined in the details buffer.
    // For WPTransient, these are probably only the default two fields
    // defined by WPObject (object title, object class).
    ulParentColumns = M_XWPTrashObject_parent_M_WPTransient_wpclsQueryDetailsInfo(
                                                somSelf,
                                                ppClassFieldInfo,
                                                pSize);

    // if pSize is non-NULL, we must add the size of our details
    // column data structure (that's "Query 2" in the WPS ref)
    if (pSize)
        *pSize += sizeof(XTRO_DETAILS);

    // if the request was for the chained fieldinfo structures
    // (ppClassFieldInfo is non-NULL), link the new ones in
    if (ppClassFieldInfo)
    {
        // if the beginning of the chain is 0, assign the address
        // of the first CLASSFIELDINFO structure to *ppClassFieldInfo.
        // Otherwise *pp points to the first column description in the
        // chain.  We need to walk the chain and link our CLASSFIELDINFO
        // structures at the end.
        if (*ppClassFieldInfo)
        {
            // find the last link in the chain; then add our CLASSFIELDINFO
            // structures to the chain.
            pcfi = *ppClassFieldInfo;
            for (i=0; i < ulParentColumns; i++)
            {
                pcfi = (pcfi->pNextFieldInfo)
                            ? pcfi->pNextFieldInfo
                            : pcfi;     // appears to be a security check
            }

            // append our new field info to the list;
            // this data has been initialized in wpclsInitData
            pcfi->pNextFieldInfo = acfiTrashObject;
        }
        else
            // no fields defined yet (very improbable):
            // make ours the first
            *ppClassFieldInfo = acfiTrashObject;
    }

    return (ulParentColumns + XTRO_EXTRAFIELDS);
}

/*
 *@@ wpclsQueryTitle:
 *      tell the WPS the new class default title:
 *      "Trash object".
 */

SOM_Scope PSZ  SOMLINK xtroM_wpclsQueryTitle(M_XWPTrashObject *somSelf)
{
    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    /* M_XWPTrashObjectData *somThis = M_XWPTrashObjectGetData(somSelf); */
    M_XWPTrashObjectMethodDebug("M_XWPTrashObject","xtroM_wpclsQueryTitle");

    return (pNLSStrings->pszTrashObject);
}

/*
 *@@ wpclsQueryStyle:
 *      we return lots of flags to make sure the user cannot
 *      mess with the trash objects.
 */

SOM_Scope ULONG  SOMLINK xtroM_wpclsQueryStyle(M_XWPTrashObject *somSelf)
{
    /* M_XWPTrashObjectData *somThis = M_XWPTrashObjectGetData(somSelf); */
    M_XWPTrashObjectMethodDebug("M_XWPTrashObject","xtroM_wpclsQueryStyle");

    return (CLSSTYLE_DONTTEMPLATE
                | CLSSTYLE_NEVERCOPY    // but allow move
                | CLSSTYLE_NEVERLINK
                | CLSSTYLE_NEVERDELETE  // we have a "destroy" menu item already
                | CLSSTYLE_NEVERDROPON
                | CLSSTYLE_NEVERPRINT
                | CLSSTYLE_NEVERRENAME
                | CLSSTYLE_NEVERSETTINGS);
}



