
/*
 *@@sourcefile xfobj.c:
 *      This file contains SOM code for the following XWorkplace classes:
 *
 *      --  XFldObject (WPObject replacement)
 *
 *      XFldObject gives the other classes access to WPS
 *      internals that cannot be reached otherwise. It
 *      also initializes the whole XWorkplace environment
 *      at WPS bootup by overriding M_XFldObject::wpclsInitData.
 *
 *      Also this class is needed for storing some extra data
 *      when objects have been deleted into the trash can.
 *
 *      This class must always be installed.
 *
 *      Starting with V0.9.0, the files in classes\ contain only
 *      i.e. the methods themselves.
 *      The implementation for this class is mostly in filesys\object.c.
 *
 *@@somclass XFldObject xfobj_
 *@@somclass M_XFldObject xfobjM_
 */

/*
 *      Copyright (C) 1997-2000 Ulrich M”ller.
 *      This file is part of the XWorkplace source package.
 *      XWorkplace is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published
 *      by the Free Software Foundation, in version 2 as it comes in the
 *      "COPYING" file of the XWorkplace main distribution.
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

/*
 *@@todo:
 *
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitctm: 2.42
 */

#ifndef SOM_Module_xfobj_Source
#define SOM_Module_xfobj_Source
#endif
#define XFldObject_Class_Source
#define M_XFldObject_Class_Source

/*
 *  Suggested #include order:
 *  1)  os2.h
 *  2)  C library headers
 *  3)  setup.h (code generation and debugging options)
 *  4)  headers in helpers\
 *  5)  at least one SOM implementation header (*.ih)
 *  6)  dlgids.h, headers in shared\ (as needed)
 *  7)  headers in implementation dirs (e.g. filesys\, as needed)
 *  8)  #pragma hdrstop and then more SOM headers which crash with precompiled headers
 */

#define INCL_DOSPROCESS
#define INCL_DOSEXCEPTIONS
#define INCL_DOSSEMAPHORES
#define INCL_DOSERRORS
#define INCL_WINWINDOWMGR
#define INCL_WINMENUS
#define INCL_WINDIALOGS
#define INCL_WINSTDCNR
#define INCL_WINSTDBOOK
#define INCL_WINPROGRAMLIST
#include <os2.h>

// C library headers
#include <stdio.h>
#include <setjmp.h>             // needed for except.h
#include <assert.h>             // needed for except.h

// generic headers
#include "setup.h"                      // code generation and debugging options

// headers in /helpers
#include "helpers\cnrh.h"               // container helper routines
#include "helpers\except.h"             // exception handling
#include "helpers\linklist.h"           // linked list helper routines
#include "helpers\stringh.h"            // string helper routines
#include "helpers\winh.h"               // PM helper routines

// SOM headers which don't crash with prec. header files
#include "xfobj.ih"

// XWorkplace implementation headers
#include "dlgids.h"                     // all the IDs that are shared with NLS
#include "shared\common.h"              // the majestic XWorkplace include file
#include "shared\kernel.h"              // XWorkplace Kernel
#include "shared\wpsh.h"                // some pseudo-SOM functions (WPS helper routines)

#include "shared\center.h"              // public XCenter interfaces

#include "filesys\fdrmenus.h"           // shared folder menu logic
#include "filesys\fileops.h"            // file operations implementation
#include "filesys\folder.h"             // XFolder implementation
#include "filesys\object.h"             // XFldObject implementation
#include "filesys\program.h"            // program implementation
#include "filesys\xthreads.h"           // extra XWorkplace threads

// other SOM headers
#pragma hdrstop
#include <wpfolder.h>                   // WPFolder

#include "helpers\undoc.h"              // some undocumented stuff

/* ******************************************************************
 *                                                                  *
 *   Global variables                                               *
 *                                                                  *
 ********************************************************************/

// "XFldObject" key for wpRestoreData etc.
static const char* G_pcszXFldObject = "XFldObject";

// global variable whether XWorkplace is initialized yet
static BOOL        G_fXWorkplaceInitialized = FALSE;

/* ******************************************************************
 *                                                                  *
 *   here come the XFldObject instance methods                      *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpAddObjectInternalsPage:
 *      this actually adds the "Internals" pages into all object notebooks,
 *      if the Global Settings allow it
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpAddObjectInternalsPage(XFldObject *somSelf,
                                                            HWND hwndNotebook)
{
    PAGEINFO pi;
    const char* pszHelpLibrary = cmnQueryHelpLibrary();

    /* XFldObjectData *somThis = XFldObjectGetData(somSelf); */
    XFldObjectMethodDebug("XFldObject","xfobj_xwpAddObjectInternalsPages");

    // insert Shutdown settings page
    memset((PCH)&pi, 0, sizeof(PAGEINFO));
    pi.cb                  = sizeof(PAGEINFO);
    pi.hwndPage            = NULLHANDLE;
    pi.pfnwp               = obj_fnwpSettingsObjDetails;
    pi.resid               = cmnQueryNLSModuleHandle(FALSE);
    pi.pCreateParams       = somSelf;
                // passed to obj_fnwpSettingsObjDetails in mp2
    pi.dlgid               = ID_XSD_OBJECTDETAILS;
    pi.usPageStyleFlags    = BKA_STATUSTEXTON | BKA_MAJOR;   // major tab;
    pi.usPageInsertFlags   = BKA_FIRST;
    pi.usSettingsFlags     = 0; // don't enumerate in status line
    pi.pszName             = cmnQueryNLSStrings()->pszInternals;

    pi.pszHelpLibraryName  = (PSZ)pszHelpLibrary;
    pi.idDefaultHelpPanel  = ID_XSH_SETTINGS_OBJINTERNALS;

    return (_wpInsertSettingsPage(somSelf, hwndNotebook, &pi));
}

/*
 *@@ xwpQueryDeletion:
 *      this method may be called at any time to determine if and
 *      when an object has been deleted into the trash can.
 *
 *      If this object has been deleted into the XWorkplace trash can
 *      (that is, if the actual object currently resides in the hidden
 *      \TRASH directory tree and a related XWPTrashObject exists),
 *      this returns TRUE and puts the date and time of deletion into
 *      the specified structures.
 *
 *      If this object has not been deleted, FALSE is returned and the
 *      structures are not changed.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpQueryDeletion(XFldObject *somSelf,
                                               CDATE* pcdateDeleted,
                                               CTIME* pctimeDeleted)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    BOOL    brc = _fDeleted;

    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryDeletion");

    if (brc)
    {
        if (pcdateDeleted)
            memcpy(pcdateDeleted, &_cdateDeleted, sizeof(CDATE));
        if (pctimeDeleted)
            memcpy(pctimeDeleted, &_ctimeDeleted, sizeof(CTIME));
    }

    return (brc);
}

/*
 *@@ xwpSetDeletion:
 *      this sets the deletion date and time fields for this object.
 *      This method is only to be called by the XWorkplace trash can
 *      and changes the data which is subsequently returned by
 *      XFldObject::xwpQueryDeletion.
 *
 *      If (fSet == TRUE),the object is assumed to have been moved to the
 *      invisible TRASH directory on the object's drive already.
 *
 *      The object's internal fields for deletion date and time will
 *      then be set to the current system date and time, and
 *      subsequent calls to XFldObject::xwpQueryDeletion will return
 *      this data.
 *
 *      If (fSet == FALSE), this means the obejct is no longer
 *      considered "deleted" (because it's been restored), and subsequent
 *      calls to XFldObject::xwpQueryDeletion will return FALSE only.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetDeletion(XFldObject *somSelf,
                                             BOOL fSet)
{
    // BOOL    brc = FALSE;
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetDeletion");

    if (fSet)
    {
        // set deletion data:
        DATETIME    dt;
        DosGetDateTime(&dt);
        cnrhDateTimeDos2Win(&dt, &_cdateDeleted, &_ctimeDeleted);
        _fDeleted = TRUE;
    }
    else
    {
        _fDeleted = FALSE;
    }

    return (_wpSaveDeferred(somSelf));
}

/*
 *@@ xwpSetTrashObject:
 *      sets the internal trash object field to the specified
 *      trash object (XWPTrashObject) to be able to relate a
 *      deleted object to the corresponding trash object in the
 *      trash can. Only to be called by the trash can.
 *
 *@@added V0.9.3 (2000-04-11) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetTrashObject(XFldObject *somSelf,
                                                WPObject* pTrashObject)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetTrashObject");

    _pTrashObject = pTrashObject;

    return (TRUE);
}

/*
 *@@ xwpQueryListNotify:
 *      returns the current list notification flags for this
 *      object. See XFldObject::xwpSetListNotify for details.
 *
 *@@added V0.9.6 (2000-10-23) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpQueryListNotify(XFldObject *somSelf)
{
    ULONG   ulrc = 0;
    WPSHLOCKSTRUCT Lock;
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryListNotify");

    if (wpshLockObject(&Lock, somSelf))
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);
        ulrc = _ulListNotify;
    }
    wpshUnlockObject(&Lock);

    return (ulrc);
}

/*
 *@@ xwpSetListNotify:
 *      sets the list notification flags for this object.
 *
 *      List notification flags are a new object feature
 *      with XWorkplace. These are intended to implement
 *      object-granular functions when an object has been
 *      stored in some XWP-internal list which needs to
 *      be updated in certain cases.
 *
 *      Current flags are:
 *
 *      -- OBJLIST_RUNNINGSTORED: this means that the
 *         object has been given in-use emphasis by
 *         progOpenProgram. This can happen to program
 *         objects (WPProgram or WPProgramFile) or
 *         data files. If the object is destroyed
 *         for whatever reason, the object needs to
 *         be removed from the list maintained by
 *         progOpenProgram because otherwise we'd
 *         run into problems when WM_APPTERMINATENOTIFY
 *         comes in.
 *
 *      -- OBJLIST_CONFIGFOLDER: this means that the
 *         object is a config folder or resides in
 *         one. The config folder cache must be invalidated
 *         when this object gets deleted.
 *
 *      -- OBJLIST_FAVORITEFOLDER: object is a folder
 *         on the "favorite folders" list.
 *
 *      -- OBJLIST_QUICKOPENFOLDER: object is a folder
 *         on the "quick-open folders" list.
 *
 *      Note: These flags are NOT persistent across
 *      reboots, i.e. not stored with wpSaveState.
 *      They are also cleared for the copy if the
 *      object gets copied.
 *
 *@@added V0.9.6 (2000-10-23) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetListNotify(XFldObject *somSelf,
                                               ULONG flNotifyFlags)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock;
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetListNotify");

    if (wpshLockObject(&Lock, somSelf))
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);
        _ulListNotify = flNotifyFlags;
        brc = TRUE;
    }
    wpshUnlockObject(&Lock);

    return (brc);
}

/*
 *@@ xwpModifyListNotify:
 *      this modifies the current list-notify flags for the
 *      current object in an atomic operation.
 *
 *      See XFldObject::xwpSetListNotify for details.
 *
 *      Use this method if you need to modify single flags
 *      while keeping others (instead of first querying and
 *      then setting the new flags). This function is an
 *      atomic operation, similar to wpModifyStyle.
 *
 *      This operates bit-wise. To set a flag, set it in
 *      both flNotifyFlags and flNotifyMask. To unset a
 *      flag, set it in flNotifyFlags only.
 *
 *      For example, to set FLAG1 and clear FLAG2, call:
 +
 +          _xwpModifyListNotify(...,
 +                               FLAG1 | FLAG2,     // affected flags
 +                               FLAG1);            // flags to set (i.e. clear FLAG2)
 *
 *@@added V0.9.6 (2000-10-23) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpModifyListNotify(XFldObject *somSelf,
                                                  ULONG flNotifyFlags,
                                                  ULONG flNotifyMask)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock;
    XFldObjectMethodDebug("XFldObject","xfobj_xwpModifyListNotify");

    if (wpshLockObject(&Lock, somSelf))
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);

        _ulListNotify = (
                            // copy all unaffected
                            (_ulListNotify & ~flNotifyFlags)
                            // OR with masked new ones
                            | (flNotifyFlags & flNotifyMask)
                        );
        brc = TRUE;
    }
    wpshUnlockObject(&Lock);

    return (brc);
}

/*
 *@@ xwpAddDestroyNotify:
 *      adds a window handle to the object's internal
 *      destroy-notify list.
 *
 *      When the object is destroyed for any reason
 *      (i.e. when it is deleted or made dormant), the
 *      specified HWND is posted (!) a WM_CONTROL message
 *      with the XN_OBJECTDESTROYED notify code.
 *
 *      Any XCenter widget that uses an object pointer
 *      internally (such as the built-in object button
 *      widget) should use this method to destroy itself
 *      when its related object gets destroyed.
 *
 *      Use XFldObject::xwpRemoveDestroyNotify to remove
 *      the notification again... e.g. when the widget
 *      itself is destroyed.
 *
 *@@added V0.9.7 (2001-01-03) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpAddDestroyNotify(XFldObject *somSelf,
                                                  HWND hwnd)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock;
    XFldObjectMethodDebug("XFldObject","xfobj_xwpAddDestroyNotify");

    if (wpshLockObject(&Lock, somSelf))
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);
        PLINKLIST pllNotifies = NULL;
        if (_pvllWidgetNotifies == NULL)
            // list not created yet: do it now
            _pvllWidgetNotifies = lstCreate(FALSE);     // no auto-free

        pllNotifies = (PLINKLIST)_pvllWidgetNotifies;
        if (pllNotifies)
        {
            lstAppendItem(pllNotifies, (PVOID)hwnd);
        }

        brc = TRUE;
    }
    wpshUnlockObject(&Lock);

    return (brc);
}

/*
 *@@ xwpRemoveDestroyNotify:
 *      the reverse to XFldObject::AddWidgetNotify.
 *
 *@@added V0.9.7 (2001-01-03) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpRemoveDestroyNotify(XFldObject *somSelf,
                                                     HWND hwnd)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock;
    XFldObjectMethodDebug("XFldObject","xfobj_xwpRemoveDestroyNotify");

    if (wpshLockObject(&Lock, somSelf))
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);
        PLINKLIST pllNotifies = (PLINKLIST)_pvllWidgetNotifies;
        if (pllNotifies)
        {
            lstRemoveItem(pllNotifies, (PVOID)hwnd);
        }

        brc = TRUE;
    }
    wpshUnlockObject(&Lock);

    return (brc);
}

/*
 *@@ xwpQueryObjectHotkey:
 *      this returns the global object hotkey which has been defined
 *      to be monitored for in the XWorkplace hook.
 *
 *      If this object has been assigned a hotkey to, TRUE is returned,
 *      and the hotkey data is stored in the two USHORT variables.
 *
 *      *pusFlags contains the flags for the fsFlags parameter of
 *      the WM_CHAR message (SHORT1FROMMP(mp1)). Those flags have
 *      been filtered. See GLOBALHOTKEY for the valid flags.
 *
 *      *pucScanCode contains the hardware scan code which is used
 *      to identify the hotkey in the XWorkplace hook. Since the
 *      char and virtual codes are not valid when a VIO session
 *      currently has the input focus, only the scan code can be
 *      used to identify keystrokes in the hook.
 *
 *      If *pusFlags has the KC_VIRTUALKEY flag set, *pusKeyCode has
 *      the usvk parameter of WM_CHAR; otherwise, it has the usch
 *      parameter (SHORT1/2FROMMP(mp2)). This will only be used to
 *      be able to describe the key on the dialogs, not to identify
 *      keystrokes in the XWorkplace hook.
 *
 *      If no hotkey has been assigned, FALSE is returned only.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpQueryObjectHotkey(XFldObject *somSelf,
                                                   PUSHORT pusFlags,
                                                   PUCHAR pucScanCode,
                                                   PUSHORT pusKeyCode)
{
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryObjectHotkey");

    return (objQueryObjectHotkey(somSelf, pusFlags, pucScanCode, pusKeyCode));
}

/*
 *@@ xwpSetObjectHotkey:
 *      this sets a new global object hotkey for the object.
 *      See XFldObject::xwpQueryObjectHotkey for the description
 *      of the hotkey parameters.
 *
 *      If the object was given a hotkey previously, the
 *      hotkey definition is overwritten.
 *
 *      If another object had the same object hotkey, the
 *      other object will lose its hotkey definition,
 *      because only each object must have a unique hotkey
 *      definition, if any.
 *
 *      As a special exception, if all three hotkey parameters
 *      are null, the hotkey for the object is removed from
 *      the internal hotkeys list (i.e. somSelf loses its
 *      hotkey).
 *
 *      The XWorkplace hook is automatically notified of the
 *      change, so that the new hotkey definition takes effect
 *      immediately.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetObjectHotkey(XFldObject *somSelf,
                                                 USHORT usFlags,
                                                 UCHAR ucScanCode,
                                                 USHORT usKeyCode)
{
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetObjectHotkey");

    return (objSetObjectHotkey(somSelf, usFlags, ucScanCode, usKeyCode));
}

/*
 *@@ xwpQuerySetup:
 *      this new XFldObject method composes a setup string
 *      for the given object which contains all non-default
 *      settings for this object.
 *
 *      This method is the reverse to the wpSetup method.
 *      The settings string returned by this method can be
 *      passed to wpSetup (or WinSetObjectData) to restore
 *      the setting for this object. Unfortunately, IBM
 *      has never implemented a "query setup" method, so
 *      I did this now.
 *
 *      Since you can never be sure how long the setup string
 *      will be, you'll have to call this method twice:
 *
 *      1) On the first call, pass both pszSetupString and
 *         cbSetupString as NULL. The method will then
 *         return the length of the setup string for this
 *         object, _not_ including the terminating null byte.
 *
 *      2) Then, allocate a buffer of that size (+1 for the
 *         null-terminator) and call this method again with
 *         pszSetupString being that buffer and cbSetupString
 *         the size of that buffer (including the null byte).
 *
 *      This method only returns setup strings which have
 *      non-default values.
 *
 *      This method only resolves the method pointer for
 *      the "xwpQuerySetup2" method, which must to the actual
 *      setup string composing. See XFldObject::xwpQuerySetup2
 *      for details.
 *
 *@@added V0.9.1 (2000-01-16) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpQuerySetup(XFldObject *somSelf,
                                             PSZ pszSetupString,
                                             ULONG cbSetupString)
{
    ULONG ulrc = 0;
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQuerySetup");

    {
        // obtain "xwpQuerySetup2" method pointer
        somTD_XFldObject_xwpQuerySetup2 pfn_xwpQuerySetup2
            = (somTD_XFldObject_xwpQuerySetup2)somResolveByName(somSelf,
                                                                "xwpQuerySetup2");
        if (pfn_xwpQuerySetup2)
            // method resolved: call it
            ulrc  = pfn_xwpQuerySetup2(somSelf, pszSetupString, cbSetupString);
    }

    return (ulrc);
}

/*
 *@@ xwpQuerySetup2:
 *      this is the implementation for querying setup strings
 *      which gets called by XFldObject::xwpQuerySetup.
 *
 *      This has been placed into a separate method because this
 *      method needs to be called using SOM name-lookup
 *      resolution to support overriding it in subclasses
 *      of XFldObject (WPObject), which xwpQuerySetup does.
 *
 *      --  Call xwpQuerySetup for getting a setup string.
 *
 *      --  Override xwpQuerySetup2 for adding setup-string support
 *          to your class.
 *
 *      Guidelines:
 *
 *      1.  You cannot simply use _parent_xwpQuerySetup
 *          to call the parent method, because there's no C binding
 *          for this. The SOM header files do not know that WPObject
 *          has been replaced with XFldObject and therefore have no
 *          idea that XFldObject is actually a parent class of all
 *          other WPS classes. You must manually resolve the SOM
 *          method pointer for the parent class of your class using
 *          wpshParentResolve. See the code sample below.
 *
 *      2.  You must call the parent method _after_ your implementation
 *          to make sure XFldObject gets called last, because the OBJECTID
 *          setup string must be added at the very last position in the
 *          complete setup string (IBM says), and that string is implemented
 *          by the XFldObject method.
 *
 *      3.  When calling the parent method, modify the buffer and size
 *          parameters to reflect the string you have already composed.
 *          As a result, the parent method will append its string to
 *          the data you have composed.
 *
 *      4.  Always terminate your setup strings with a semicolon (";"),
 *          even if it's the last.
 *
 *      So use the following code to call the parent method:
 *
 +          PSZ pszMySetupStringSoFar = ...;
 +                  // setup strings for your class
 +          ULONG cbMySetupStringSoFar = strlen(pszMySetupStringSoFar);
 +                  // length of that setup string or 0 if none
 +
 +          // manually resolve method for parent class
 +          somTD_XFldObject_xwpQuerySetup pfn_xwpQuerySetup2
 +              = wpshParentResolve(somSelf,    // object
 +                                     _YourClass, // class object; replace this with
 +                                          // the class you're coding this method for
 +                                     "xwpQuerySetup2"); // method name
 +          if (pfn_xwpQuerySetup2)
 +              // now call parent method
 +              if ( (pszSetupString) && (cbSetupString) )
 +                  // string buffer already specified:
 +                  // tell parent class to append to that string
 +                  cbMySetupStringSoFar += pfn_xwpQuerySetup2(somSelf,
 +                                            pszSetupString + cbMySetupStringSoFar,
 +                                              // append to existing string
 +                                            cbSetupString - cbMySetupStringSoFar);
 +                                              // remaining space in buffer
 +              else
 +                  // string buffer not yet specified: return length only
 +                  ulReturn += pfn_xwpQuerySetup2(somSelf, 0, 0);
 +
 +          return (cbMySetupStringSoFar);
 *
 *      If all methods obey these conventions, this results in a complete
 *      setup string for any object of any class, with the subclass's strings
 *      first and XFldObject's strings last.
 *
 *      See XFolder::xwpQuerySetup2 for a sample implementation
 *      which adds setup strings for a subclass of XFldObject.
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpQuerySetup2(XFldObject *somSelf,
                                              PSZ pszSetupString,
                                              ULONG cbSetupString)
{
    ULONG ulReturn = 0;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQuerySetup2");

    ulReturn += objQuerySetup(somSelf,
                              pszSetupString,
                              cbSetupString);

    return (ulReturn);

}

/*
 *@@ xwpSetNextObj:
 *      wrapper around the undocumented WPObject method
 *      "wpSetNextObj".
 *
 *      From my testing, wpSetNextObj stores the "next object"
 *      in the object's internal instance data. This is either
 *      NULL if the object is the last object in a folder, or
 *      points to the next object (the one that comes after
 *      somSelf in the folder).
 *
 *      These pointers are apparently maintained by
 *      the WPFolder methods wpAddToContent and
 *      wpDeleteFromContent.
 *
 *      This wrapper resolves the method pointer and calls
 *      that method, since we have no access to WPObject's
 *      internal instance data (and better not touch it in
 *      the first place).
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpSetNextObj(XFldObject *somSelf,
                                             WPObject* pobjNext)
{
    ULONG ulrc = 0;     // seems to be a BOOL
    WPObject **ppObjNext = NULL;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetNextObj");

    ppObjNext = wpshGetNextObjPointer(somSelf);
    if (ppObjNext)
        *ppObjNext = pobjNext;

    return (ulrc);
}

/*
 *@@ xwpQueryNextObj:
 *      the reverse to XFldObject::xwpSetNextObj.
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope WPObject*  SOMLINK xfobj_xwpQueryNextObj(XFldObject *somSelf)
{
    WPObject *pobj = NULL;
    WPObject **ppObjNext = NULL;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryNextObj");

    ppObjNext = wpshGetNextObjPointer(somSelf);
    if (ppObjNext)
        pobj = *ppObjNext;

    return (pobj);
}

/*
 *@@ wpInitData:
 *      this WPObject instance method gets called when the
 *      object is being initialized (on wake-up or creation).
 *      We initialize our additional instance data here.
 *      Always call the parent method first.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.2 (2000-03-15) [umoeller]: initializing new members
 */

SOM_Scope void  SOMLINK xfobj_wpInitData(XFldObject *somSelf)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpInitData");

    XFldObject_parent_WPObject_wpInitData(somSelf);

    _fDeleted = FALSE;

    _pWPObjectData = NULL;
    _cbWPObjectData = 0;

    _pTrashObject = NULL;

    _ulListNotify = 0;

    _pvllWidgetNotifies = NULL;
}

/*
 *@@ wpCopyObject:
 *      overridden for debugging.
 *
 *@@added V0.9.3 (2000-04-28) [umoeller]
 */

SOM_Scope WPObject*  SOMLINK xfobj_wpCopyObject(XFldObject *somSelf,
                                                WPFolder* Folder,
                                                BOOL fLock)
{
    WPObject *pCopiedObject;
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpCopyObject");

    _Pmpf(("0x%lX ++ XFldObject::wpCopyObject", somSelf));
    pCopiedObject = XFldObject_parent_WPObject_wpCopyObject(somSelf,
                                                            Folder,
                                                            fLock);
    _Pmpf(("0x%lX -- End of XFldObject::wpCopyObject", somSelf));
    return (pCopiedObject);
}

/*
 *@@ wpObjectReady:
 *      this WPObject notification method gets called by the
 *      WPS when object instantiation is complete, for any reason.
 *      ulCode and refObject signify why and where from the
 *      object was created.
 *      The parent method must be called first.
 *
 *      We will have this object's pointer stored
 *      in a global list (maintained by the Worker thread)
 *      so that XShutdown knows which objects are currently
 *      awake.
 *
 *      Note: On my Warp 4 (FP 10), this method does _not_
 *      get called for WPFolder instances, so we override
 *      XFolder::wpObjectReady also.
 *
 *      <B>Copying considerations</B>
 *
 *      Even though WPSREF doesn't really say so, this method
 *      must be used similar to a C++ copy constructor
 *      when the instance data contains pointers and the
 *      OR_REFERENCE bit is set in ulCode. When objects are
 *      copied, SOM just copies the binary instance data, so
 *      you get two objects with instance pointers pointing
 *      to the same object, which can only lead to problems.
 *
 *      According to wpobject.h, the OR_REFERENCE bit is set
 *      for OR_FROMTEMPLATE, OR_FROMCOPY, or OR_SHADOW; this
 *      means that refObject is valid.
 *
 *      When an object is copied in any way (thru wpCopyObject
 *      or wpCreateFromTemplate), the WPS first creates a
 *      new "empty" object (on which wpInitData is invoked),
 *      does a "flat" copy then,  and then invokes wpRestoreState
 *      on it. As the very last step, wpObjectReady gets called.
 *      As a result, you must only handle the instance data here
 *      which is not safely set thru wpRestoreState.
 *
 *@@changed V0.9.0: adjust for XFolder::wpObjectReady override
 *@@changed V0.9.7 (2000-12-18) [umoeller]: fixed _ulListNotify
 */

SOM_Scope void  SOMLINK xfobj_wpObjectReady(XFldObject *somSelf,
                                            ULONG ulCode,
                                            WPObject* refObject)
{
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    // XFldObjectMethodDebug("XFldObject","xfobj_wpObjectReady");

    #if defined(DEBUG_SOMMETHODS) || defined(DEBUG_AWAKEOBJECTS)
        _Pmpf(("xfobj_wpObjectReady for %s (class %s), ulCode: %s",
                _wpQueryTitle(somSelf),
                _somGetName(_somGetClass(somSelf)),
                (ulCode == OR_AWAKE) ? "OR_AWAKE"
                : (ulCode == OR_FROMTEMPLATE) ? "OR_FROMTEMPLATE"
                : (ulCode == OR_FROMCOPY) ? "OR_FROMCOPY"
                : (ulCode == OR_NEW) ? "OR_NEW"
                : (ulCode == OR_SHADOW) ? "OR_SHADOW"
                : (ulCode == OR_REFERENCE) ? "OR_REFERENCE"
                : "unknown code"
             ));
    #endif

    XFldObject_parent_WPObject_wpObjectReady(somSelf, ulCode,
                                             refObject);

    if (ulCode & OR_REFERENCE)
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);
        _ulListNotify = 0;
            // V0.9.7 (2000-12-18) [umoeller]

        _pvllWidgetNotifies = NULL;
    }

    // on my Warp 4 FP 10, this method does not get
    // called for WPFolder instances, so we override
    // WPFolder::wpObjectReady also; but we don't know
    // if this is so with all Warp versions, so we
    // better check
    if (!_somIsA(somSelf, _WPFolder))
        xthrPostWorkerMsg(WOM_ADDAWAKEOBJECT,
                         (MPARAM)somSelf,
                         MPNULL);
}

/*
 *@@ wpUnInitData:
 *      this WPObject instance method is called when the object
 *      is destroyed as a SOM object, either because it's being
 *      made dormant or being deleted. All allocated resources
 *      should be freed here.
 *      The parent method must always be called last.
 *
 *      We will have this object removed from our global list
 *      of awake objects.
 *
 *@@changed V0.9.3 (2000-04-11) [umoeller]: now destroying related trash object too
 *@@changed V0.9.6 (2000-10-23) [umoeller]: added support for progOpenProgram
 *@@changed V0.9.7 (2001-01-18) [umoeller]: added support for favorite and quick-open folders
 */

SOM_Scope void  SOMLINK xfobj_wpUnInitData(XFldObject *somSelf)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpUnInitData");

    // have object removed from awake-objects list
    xthrPostWorkerMsg(WOM_REMOVEAWAKEOBJECT,
                     (MPARAM)somSelf,
                     MPNULL);

    // destroy trash object, if there's one
    if (_pTrashObject)
        _wpFree(_pTrashObject);

    // go thru list notifications

    if (_ulListNotify)
    {
        if (_ulListNotify & OBJLIST_RUNNINGSTORED)
        {
            // this object is currently stored in the
            // "running programs" list: remove it, or
            // we'll get crashes later...
            _ulListNotify &= ~OBJLIST_RUNNINGSTORED;
            progRunningAppDestroyed(somSelf);
        }

        if (_ulListNotify & OBJLIST_CONFIGFOLDER)
        {
            // somSelf is in the config folder hierarchy:
            // invalidate the content lists for the config
            // folders so that they will be rebuilt
            _ulListNotify &= ~OBJLIST_CONFIGFOLDER;
            mnuInvalidateConfigCache();
        }

        if (_ulListNotify & OBJLIST_FAVORITEFOLDER)
        {
            _ulListNotify &= ~OBJLIST_FAVORITEFOLDER;
            objAddToList(somSelf,
                         G_pllFavoriteFolders,      // folder.h
                         FALSE,         // remove
                         INIKEY_FAVORITEFOLDERS,
                         0);            // no modify flags... we're being destroyed
        }

        if (_ulListNotify & OBJLIST_QUICKOPENFOLDER)
        {
            _ulListNotify &= ~OBJLIST_QUICKOPENFOLDER;
            objAddToList(somSelf,
                         G_pllQuickOpenFolders,      // folder.h
                         FALSE,         // remove
                         INIKEY_QUICKOPENFOLDERS,
                         0);            // no modify flags... we're being destroyed
        }
    }

    if (_pvllWidgetNotifies)
    {
        // we have windows that requested notifications:
        // go thru list
        PLISTNODE pNode = lstQueryFirstNode(_pvllWidgetNotifies);
        while (pNode)
        {
            HWND hwnd = (HWND)pNode->pItemData;
            WinPostMsg(hwnd,
                       WM_CONTROL,
                       MPFROM2SHORT(ID_XCENTER_CLIENT,
                                    XN_OBJECTDESTROYED),
                       (MPARAM)somSelf);
            pNode = pNode->pNext;
        }

        lstFree(_pvllWidgetNotifies);
    }

    XFldObject_parent_WPObject_wpUnInitData(somSelf);
}

/*
 *@@ wpSaveState:
 *      this WPObject instance method saves an object's state
 *      persistently so that it can later be re-initialized
 *      with wpRestoreState. This gets called during wpClose,
 *      wpSaveImmediate or wpSaveDeferred processing.
 *      All persistent instance variables should be stored here.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSaveState(XFldObject *somSelf)
{
    BOOL    brc = FALSE;
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSaveState");

    brc = XFldObject_parent_WPObject_wpSaveState(somSelf);

    if (_fDeleted)
    {
        // save deletion data:
        _wpSaveData(somSelf, (PSZ)G_pcszXFldObject, 1,
                    (PBYTE)&_cdateDeleted, sizeof(CDATE));
        _wpSaveData(somSelf, (PSZ)G_pcszXFldObject, 2,
                    (PBYTE)&_ctimeDeleted, sizeof(CTIME));
    }

    return (brc);
}

/*
 *@@ wpRestoreState:
 *      this WPObject instance method gets called during object
 *      initialization (after wpInitData) to restore the data
 *      which was stored with wpSaveState.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpRestoreState(XFldObject *somSelf,
                                             ULONG ulReserved)
{
    BOOL    brc = FALSE;
    ULONG   cbcdate = sizeof(CDATE),
            cbctime = sizeof(CTIME);
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpRestoreState");

    brc = XFldObject_parent_WPObject_wpRestoreState(somSelf,
                                                    ulReserved);

    if (    (_wpRestoreData(somSelf, (PSZ)G_pcszXFldObject, 1,
                            (PBYTE)&_cdateDeleted, &cbcdate))
         && (_wpRestoreData(somSelf, (PSZ)G_pcszXFldObject, 2,
                            (PBYTE)&_ctimeDeleted, &cbctime))
       )
        // both keys successfully restored:
        _fDeleted = TRUE;
    else
        _fDeleted = FALSE;
    return (brc);
}

/*
 *@@ wpRestoreData:
 *      this instance method restores a 32-bit data
 *      value for the object data upon object awakening.
 *
 *      We check the "ulKey" value after having called
 *      the parent to be able to intercept the pointer
 *      to certain WPS-internal object data, which
 *      we cannot access otherwise. That's a real ugly
 *      kludge, but there's no other way to get certain
 *      object settings. ;-)
 *
 *      It is possible to override this method for WPObject
 *      even though WPObject does not define the implementation
 *      how object data is stored and restored. This works
 *      because the implementation apparently sits in
 *      wpRestoreState, which is overridden by the WPS
 *      base storage classes (WPAbstract, WPTransient,
 *      WPFileSystem). This method is _not_ overridden.
 *
 *@@added V0.9.1 (2000-01-22) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpRestoreData(XFldObject *somSelf,
                                            PSZ pszClass, ULONG ulKey,
                                            PBYTE pValue, PULONG pcbValue)
{
    BOOL    brc = FALSE;
    XFldObjectMethodDebug("XFldObject","xfobj_wpRestoreData");

    brc = XFldObject_parent_WPObject_wpRestoreData(somSelf,
                                                   pszClass,
                                                   ulKey, pValue,
                                                   pcbValue);

    if ( (brc) && (pValue) )
    {
        switch (ulKey)
        {
            case 11:        // IDKEY_OBJDATA, not defined
            {
                XFldObjectData *somThis = XFldObjectGetData(somSelf);
                _pWPObjectData = (PVOID)pValue;
                _cbWPObjectData = *pcbValue;
            break; }
        }
    }

    return (brc);
}

/*
 *@@ wpFilterPopupMenu:
 *      this WPObject instance method allows the object to
 *      filter out unwanted menu items from the context menu.
 *      This gets called before wpModifyPopupMenu.
 *
 *      We remove default entries according to global settings.
 *
 *@@changed V0.9.5 (2000-09-20) [pr]: fixed context menu flags
 */

SOM_Scope ULONG  SOMLINK xfobj_wpFilterPopupMenu(XFldObject *somSelf,
                                                   ULONG ulFlags,
                                                   HWND hwndCnr,
                                                   BOOL fMultiSelect)
{
    ULONG ulMenuFilter = 0;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpFilterPopupMenu");

    ulMenuFilter = XFldObject_parent_WPObject_wpFilterPopupMenu(somSelf,
                                                         ulFlags,
                                                         hwndCnr,
                                                         fMultiSelect);
    #ifdef DEBUG_MENUS
        _Pmpf(("XFldObject::wpFilterPopupMenu: ulMenuFilter & CTXT_CRANOTHER: 0x%lX %d",
                ulMenuFilter, ((ulMenuFilter) & CTXT_CRANOTHER)));
    #endif

    // if object has been deleted already (ie. is in trashcan),
    // remove delete
    if (_fDeleted)
        ulMenuFilter &= ~CTXT_DELETE; // V0.9.5 (2000-09-20) [pr]

    // now suppress default menu items according to
    // Global Settings;
    // the DefaultMenuItems field in pGlobalSettings is
    // ready-made for this function; the "Workplace Shell"
    // notebook page for removing menu items sets this field with
    // the proper CTXT_xxx flags
    return ((ulMenuFilter
            // first we add "Create another", because for
            // some reason it's always disabled if XFolder
            // is installed; I don't know why
            // V0.9.5 (2000-09-20) [pr] No it's not. This causes problems
            // with objects wrongly having Create Another options.
            /*| CTXT_CRANOTHER*/ ) // V0.9.5 (2000-09-20) [pr]
            // then disable items, this may include CTXT_CRANOTHER
            & ~(pGlobalSettings->DefaultMenuItems)
        );
}

/*
 *@@ wpModifyPopupMenu:
 *      this WPObject instance methods gets called by the WPS
 *      when a context menu needs to be built for the object
 *      and allows the object to manipulate its context menu.
 *      This gets called _after_ wpFilterPopupMenu.
 *
 *      We remove the "Lock in place" item here because there's
 *      no flag for that in wpFilterPopupMenu.
 *
 *@@changed V0.9.7 (2000-12-10) [umoeller]: added "fix lock in place"
 */

SOM_Scope BOOL  SOMLINK xfobj_wpModifyPopupMenu(XFldObject *somSelf,
                                                HWND hwndMenu,
                                                HWND hwndCnr,
                                                ULONG iPosition)
{
    BOOL        rc;
    // PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpModifyPopupMenu");

    rc = (XFldObject_parent_WPObject_wpModifyPopupMenu(somSelf,
                                                       hwndMenu,
                                                       hwndCnr,
                                                       iPosition));
    if (rc)
        objModifyPopupMenu(somSelf, hwndMenu);  // V0.9.7 (2000-12-10) [umoeller]

    // now that the menu is completely built, let's add hotkey
    // descriptions, but DONT do this for folders or data files,
    // because those menu items will only be added later... for
    // folders, we call this function in XFolder::wpMenuItemSelected
    if (!_somIsA(somSelf, _WPFileSystem))
        fdrAddHotkeysToMenu(somSelf,
                            hwndCnr,
                            hwndMenu);

    return rc;
}

/*
 *@@ wpMenuItemSelected:
 *      this WPObject method processes menu selections.
 *      This must be overridden to support new menu
 *      items which have been added in wpModifyPopupMenu.
 *
 *      Note that the WPS invokes this method upon every
 *      object which has been selected in the container.
 *      That is, if three objects have been selected and
 *      a menu item has been selected for all three of
 *      them, all three objects will receive this method
 *      call. This is true even if FALSE is returned from
 *      this method.
 *
 *      In order to be able to process all objects at
 *      once, we now have XFolder::xwpProcessObjectCommand,
 *      which can intercept the menu ID even before this
 *      method is invoked on each object.
 *
 *      We override this to move objects into the
 *      trash can instead, if necessary.
 *
 *      Note: This method normally doesn't get called
 *      during the regular WPS file operations once
 *      the trash can has been enabled because XFolder
 *      intercepts all file operations commands and
 *      performs the required actions directly without
 *      calling this method. However, this method still
 *      gets called by WinDestroyObject and the REXX
 *      counterpart, SysDestroyObject.
 *
 *
 *@@changed V0.9.7 (2000-12-10) [umoeller]: added "fix lock in place"
 *@@changed V0.9.7 (2001-01-15) [umoeller]: added WPMENUID_DELETE if trash can is enabled
 */

SOM_Scope BOOL  SOMLINK xfobj_wpMenuItemSelected(XFldObject *somSelf,
                                                 HWND hwndFrame,
                                                 ULONG ulMenuId)
{
    BOOL        brc = FALSE,
                fCallDefault = FALSE;

    // PGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpMenuItemSelected");

    switch (ulMenuId)
    {
        #ifdef DEBUG_CONTEXT
            case ID_XFMI_RECORDCORE:
            {
                int                 i;
                CHAR                szMsg[1024] = "No record core.",
                                    szTitle[1024],
                                    szBuf[20] = "0x00000000";
                PMINIRECORDCORE     pMRC = _wpQueryCoreRecord(somSelf);
                PCLASSFIELDINFO     pCFI, pCFI2;
                ULONG               ulCFISize = 0, ulErr;

                strcpy(szTitle, "Record core for ");
                strcat(szTitle, _wpQueryTitle(somSelf));

                strcpy(szMsg, "Size of core record (cb): ");
                UL2H(szBuf+2, pMRC->cb);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nSize of MINIRECORDCORE:   ");
                UL2H(szBuf+2, sizeof(MINIRECORDCORE));
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nSize of RECORDCORE:       ");
                UL2H(szBuf+2, sizeof(RECORDCORE));
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nNext record:              ");
                UL2H(szBuf+2, (ULONG)pMRC->preccNextRecord);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nIcon X pos:               ");
                UL2H(szBuf+2, pMRC->ptlIcon.x);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nIcon Y pos:               ");
                UL2H(szBuf+2, pMRC->ptlIcon.y);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\n\nDetails CLASSFIELDINFO:");

                strcat(szMsg, "\nSize of structure:        ");
                _wpQueryDetailsData(somSelf, NULL, &ulCFISize);
                UL2H(szBuf+2, ulCFISize);
                strcat(szMsg, szBuf);

                pCFI = (PCLASSFIELDINFO)_wpAllocMem(somSelf, ulCFISize, &ulErr);
                pCFI2 = pCFI;
                _wpQueryDetailsData(somSelf, (PVOID)&pCFI2, &ulCFISize);

                _wpFreeMem(somSelf, (PVOID)pCFI);

                winhDebugBox(szTitle, szMsg);

                brc = TRUE;
            break; }

            case ID_XFMI_SHOWFOLDERDATA:
            {
                xthrPostWorkerMsg(WM_SHOWFOLDERDATA,
                                  (MPARAM)somSelf,
                                  MPNULL);
                brc = TRUE;
            break; }
        #endif

        case WPMENUID_DELETE:
        {
            PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
            // this is never reached, because the subclassed folder
            // frame winproc already intercepts this

            if (pGlobalSettings->fTrashDelete)
            {
                cmnMove2DefTrashCan(somSelf);
                brc = TRUE;     // processed
            }
            else
                brc = XFldObject_parent_WPObject_wpMenuItemSelected(somSelf,
                                                                    hwndFrame,
                                                                    ulMenuId);
        break; }

        case ID_WPM_LOCKINPLACE:    // V0.9.7 (2000-12-10) [umoeller]
        {
            PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
            if (pGlobalSettings->fFixLockInPlace)
            {
                // we have replaced the "lock in place" submenu:
                // we must then intercept this menu item...
                ULONG ulStyle = _wpQueryStyle(somSelf);
                if ((ulStyle & OBJSTYLE_LOCKEDINPLACE) == 0)
                    ulStyle |= OBJSTYLE_LOCKEDINPLACE;
                else
                    ulStyle &= ~OBJSTYLE_LOCKEDINPLACE;
                _wpSetStyle(somSelf, ulStyle);
                _wpSaveDeferred(somSelf);
            }
        break; }

        default:
            fCallDefault = TRUE;
    }

    if (fCallDefault)
        brc = XFldObject_parent_WPObject_wpMenuItemSelected(somSelf,
                                                            hwndFrame,
                                                            ulMenuId);
    return (brc);
}

/*
 *@@ wpAddObjectGeneralPage:
 *      this WPObject instance method adds the "Icon"
 *      page to an object's settings notebook.
 *      We'll insert the object's "Internals" page here
 *      (now called "Object" page).
 *
 *      Starting with V0.9.1, we override this method
 *      instead of wpAddSettingsPages, because e.g.
 *      the spooler doesn't call WPObject::wpAddSettingsPages.
 *
 *      Starting with V0.9.2, we add the page for all
 *      objects except folders, where XFolder::wpAddObjectGeneralPage2
 *      will do the job.
 *
 *@@added V0.9.1 (2000-02-17) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_wpAddObjectGeneralPage(XFldObject *somSelf,
                                                      HWND hwndNotebook)
{
    PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpAddObjectGeneralPage");

    if (pGlobalSettings->AddObjectPage)
        // check if this is a folder;
        // if so, XFolder will insert the page
        // because otherwise this would be between
        // the two "Icon" pages...
        if (!_somIsA(somSelf, _WPFolder))
            _xwpAddObjectInternalsPage(somSelf, hwndNotebook);

    return (XFldObject_parent_WPObject_wpAddObjectGeneralPage(somSelf,
                                                              hwndNotebook));
}

/*
 *@@ wpConfirmObjectTitle:
 *      this instance method is called by the WPS during file
 *      operations (copy, move, rename etc.) for every single
 *      object that is being processed. This method must verify
 *      that the operation is valid WRT name clashes and display
 *      a confirmation dialog in case it is not.
 *
 *      Apparently, this method is not overridden by subclasses,
 *      not even WPFileSystem.
 *
 *      XWorkplace implements its own "Object exists" dialog here,
 *      if the Global Settings allow it.
 *
 *      Like most interesting methods in the WPS, this thing is
 *      barely documented, so this is what I found out.
 *
 *      Parameters:
 *      -- *somSelf      in: the object being worked on
 *      -- *Folder       in: the folder being worked on
 *      -- **ppDuplicate out: if we return NAMECLASH_REPLACE,
 *                            we need to set this to the object to
 *                            be replaced
 *      -- pszTitle      in: title of somSelf
 *                            out: if we return NAMECLASH_RENAME,
 *                            we need to set this to somSelf's new title
 *      -- cbTitle       in: sizeof(*pszTitle)
 *      -- menuID        in: the user's operation, which is:
 *                              0x0065    create another (WPMENUID_CREATEANOTHER)
 *                              0x006B    move (WPMENUID_MOVE)
 *                              0x006C    copy (WPMENUID_COPY)
 *                              0x006E    rename (no menu ID defined in wpobject.h)
 *                              0x013C    create shadow (WPMENUID_CREATESHADOW)
 *
 *      Returns:
 *      -- NAMECLASH_CANCEL (0):
 *                  abort processing, have the WPS do nothing ("Cancel"
 *                  button pressed in confirmation dialog); this will
 *                  just skip the current file;
 *      -- NAMECLASH_NONE (1):
 *                  continue processing, but perform no further
 *                  renaming etc.; we return this if no duplicate file
 *                  exists;
 *      -- NAMECLASH_RENAME (2):
 *                  have the WPS change the title to pszTitle, which we
 *                  need to set here; note that this does NOT change
 *                  the real name! So we do the renaming ourselves here;
 *      -- NAMECLASH_REPLACE (8):
 *                  have the WPS delete *ppDuplicate, which we need to
 *                  set here if we return this code; we need to find the
 *                  duplicate in this method then.
 *
 *      Note: these constants are only defined in the Warp 4 Toolkit
 *      (some of them in wpsystem.h in Warp 3 Toolkit also). So
 *      #include helpers/undoc.h, which defines these.
 *
 *@@changed V0.9.0 [umoeller]: fixed "create another" bug
 */

SOM_Scope ULONG  SOMLINK xfobj_wpConfirmObjectTitle(XFldObject *somSelf,
                                                    WPFolder* Folder,
                                                    WPObject** ppDuplicate,
                                                    PSZ pszTitle,
                                                    ULONG cbTitle,
                                                    ULONG menuID)
{
    ULONG ulrc = NAMECLASH_NONE;

    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();

    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpConfirmObjectTitle");

    #ifdef DEBUG_TITLECLASH
    {
        CHAR szFolder2[CCHMAXPATH];
        _Pmpf(("Entering wpConfirmObjectTitle"));
        _Pmpf(("  somSelf == 0x%lX", somSelf));
        _Pmpf(("    pszTitle: %s", pszTitle));
        _wpQueryFilename(_wpQueryFolder(somSelf), szFolder2, TRUE);
        _Pmpf(("    in folder: %s", szFolder2));
        _Pmpf(("  menuID: 0x%lX", menuID));
    }
    #endif

    // first of all, check whether the confirmation
    // dialogs have been replaced in the global settings;
    if (pGlobalSettings->fReplFileExists)
    {
        // yes: use our replacement (fileops.c)
        ulrc = fopsConfirmObjectTitle(somSelf,
                                      Folder,
                                      ppDuplicate,
                                      pszTitle,
                                      cbTitle,
                                      menuID);
    }
    else
    {
        // global settings do not allow dialog
        // replacement: call default
        #ifdef DEBUG_TITLECLASH
            _Pmpf(("  Calling original"));
        #endif
        ulrc = XFldObject_parent_WPObject_wpConfirmObjectTitle(somSelf,
                                                               Folder,
                                                               ppDuplicate,
                                                               pszTitle,
                                                               cbTitle,
                                                               menuID);
    }

    #ifdef DEBUG_TITLECLASH
    {
        CHAR szFolder2[CCHMAXPATH];
        _Pmpf(("  Return value: %d", ulrc));
        _Pmpf(("  New somSelf == 0x%lX", somSelf));
        _Pmpf(("    New pszTitle: %s", pszTitle));
        _wpQueryFilename(_wpQueryFolder(somSelf), szFolder2, TRUE);
        _Pmpf(("    in folder: %s", szFolder2));

        if (ppDuplicate) {
            _Pmpf(("  ppDuplicate neu != NULL"));
            if (*ppDuplicate) {
                _Pmpf(("    *ppDuplicate neu == 0x%lX", *ppDuplicate));
                _Pmpf(("      Title neu: %s", _wpQueryTitle(*ppDuplicate) ));
                _wpQueryFilename(_wpQueryFolder(*ppDuplicate), szFolder2, TRUE);
                _Pmpf(("      in folder: %s", szFolder2));
            }
        }
        _Pmpf(("Done."));
    }
    #endif

    return (ulrc);
}

/*
 *@@ wpDelete:
 *      this WPObject method deletes an object and
 *      prompts for confirmations, if necessary.
 *
 *      Normally, this method displays confirmations,
 *      if desired, by calling wpConfirmDelete, and
 *      then calls wpFree.
 *
 *      This must return:
 *
 *      --  NO_DELETE: Error occurred.
 *      --  CANCEL_DELETE: User canceled the operation.
 *      --  OK_DELETE: Object was deleted.
 *
 *@@added V0.9.4 (2000-08-03) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_wpDelete(XFldObject *somSelf,
                                        ULONG fConfirmations)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpDelete");

    // we can't override this... apparently, when a folder
    // is deleted in the WPS, the WPS goes thru all subobjects
    // first and calls this method for every subobject... yuck!

    /* if (pGlobalSettings->fTrashDelete)
    {
        if (    cmnMove2DefTrashCan(somSelf))
            return (OK_DELETE);
        else
            return (NO_DELETE);
    } */

    return (XFldObject_parent_WPObject_wpDelete(somSelf, fConfirmations));
}

/* ******************************************************************
 *                                                                  *
 *   here come the XFldObject class methods                         *
 *                                                                  *
 ********************************************************************/

/*
 * @@ xwpclsRemoveObjectHotkey:
 *            this removes the object hotkey for the
 *            given object. This extra function is
 *            necessary because if an object handle
 *            for an object with a hotkey gets lost
 *            (e.g. because the object was deleted),
 *            there's no way to invoke XFldObject::xwpSetObjectHotkey
 *            on it.
 *
 *            @@added V0.9.0 (99-11-12) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobjM_xwpclsRemoveObjectHotkey(M_XFldObject *somSelf,
                                                        HOBJECT hobj)
{
    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    M_XFldObjectMethodDebug("M_XFldObject","xfobjM_xwpclsRemoveObjectHotkey");

    return (objRemoveObjectHotkey(hobj));
}

/*
 *@@ wpclsInitData:
 *      we override this to initialize XWorkplace altogether.
 *
 *      This is probably the first WPS method called on the
 *      system (for M_WPObject, that is), so we use this
 *      to set up some stuff, most notably, start the
 *      additional XWorkplace threads by calling
 *      krnInitializeXWorkplace, which handles the details.
 *
 *      The beautiful thing is that at this point we appear
 *      to own the computer all alone. It seems that no
 *      additional WPS threads are running _yet_ (or if they
 *      are, they don't care), so we can halt the system,
 *      display graphics, overwrite the master boot record,
 *      whatever. (JUST KIDDING.)
 *
 *@@changed V0.9.0 [umoeller]: added class object to KERNELGLOBALS
 */

SOM_Scope void  SOMLINK xfobjM_wpclsInitData(M_XFldObject *somSelf)
{
    BOOL    fOpenFoldersFound = FALSE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
                        // this will load the global settings from OS2.INI

    // M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf);
    // M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsInitData");
    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("M_XFldObject::xfobjM_wpclsInitData for class %s",
                    _somGetName(somSelf) ));
    #endif

    M_XFldObject_parent_M_WPObject_wpclsInitData(somSelf);

    // since this code is reached for every single WPS class
    // that gets initialized, we need to check if we're being
    // called for the first time
    if (!G_fXWorkplaceInitialized)
    {
        // check if we have any open folder windows;
        // if so, we're not really in the process of starting
        // up. This check is necessary because this class
        // method also gets called when the classes are installed
        // by WinRegisterObjectClass, unfortunately, and we don't
        // want to start threads etc. then.
        HENUM   henum = WinBeginEnumWindows(HWND_DESKTOP);
        HWND    hwndThis;
        while (     (!fOpenFoldersFound)
                 && (hwndThis = WinGetNextWindow(henum))
              )
        {
            CHAR    szClass[200];
            if (WinQueryClassName(hwndThis, sizeof(szClass), szClass))
                if (strcmp(szClass, "wpFolder window") == 0)
                    // folder window:
                    fOpenFoldersFound = TRUE;
        }
        WinEndEnumWindows(henum);

        G_fXWorkplaceInitialized = TRUE;

        if (!fOpenFoldersFound)
            // only if no open folders are found:
            // initialize the kernel (kernel.c)
            krnInitializeXWorkplace();

        {
            // store the class object in KERNELGLOBALS
            PKERNELGLOBALS   pKernelGlobals = krnLockGlobals(__FILE__, __LINE__, __FUNCTION__);
            if (pKernelGlobals)
            {
                // store the XFldObject class object in KERNELGLOBALS
                pKernelGlobals->fXFldObject = TRUE;
                krnUnlockGlobals();
            }
        }
    }

    if (!fOpenFoldersFound)
        // even if not first invocation (i.e. some class other
        // than WPObject gets initialized): notify Speedy thread
        // of class initialization
        if (pGlobalSettings->ShowBootupStatus)
            xthrPostSpeedyMsg(QM_BOOTUPSTATUS,
                             (MPARAM)somSelf,       // class object
                             MPNULL);
}

/*
 *@@ wpclsNew:
 *      overridden for debugging
 */

SOM_Scope WPObject*  SOMLINK xfobjM_wpclsNew(M_XFldObject *somSelf,
                                             PSZ pszTitle,
                                             PSZ pszSetupEnv,
                                             WPFolder* Folder,
                                             BOOL fLock)
{
    WPObject *pObject;
    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    // M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsNew");

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("xfobjM_wpclsNew, class object: %s, title: %s, setup: %s, folder: 0x%lX (%s)",
                    _somGetName(somSelf),
                    pszTitle,
                    pszSetupEnv,
                    Folder,
                    (Folder)
                        ? _wpQueryTitle(Folder)
                        : "NULL"));
    #endif

    pObject = M_XFldObject_parent_M_WPObject_wpclsNew(somSelf,
                                                    pszTitle,
                                                    pszSetupEnv,
                                                    Folder, fLock);
    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("End of M_XFldObject::wpclsNew, returning pObject: 0x%lX",
                    pObject));
    #endif

    return (pObject);
}

/*
 *@@ wpclsMakeAwake:
 *      overridden for debugging
 */

SOM_Scope WPObject*  SOMLINK xfobjM_wpclsMakeAwake(M_XFldObject *somSelf,
                                                   PSZ pszTitle,
                                                   ULONG ulStyle,
                                                   HPOINTER hptrIcon,
                                                   POBJDATA pObjData,
                                                   WPFolder* Folder,
                                                   ULONG ulUser)
{
    WPObject *pObject;
    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    // M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsMakeAwake");

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("xfobjM_wpclsMakeAwake, class object: %s, title: %s, ulStyle: 0x%lX, folder: 0x%lX (%s)",
                    _somGetName(somSelf),
                    pszTitle,
                    ulStyle,
                    Folder,
                    (Folder)
                        ? _wpQueryTitle(Folder)
                        : "NULL"));

    #endif

    pObject = M_XFldObject_parent_M_WPObject_wpclsMakeAwake(somSelf,
                                                          pszTitle,
                                                          ulStyle,
                                                          hptrIcon,
                                                          pObjData,
                                                          Folder,
                                                          ulUser);
    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("End of M_XFldObject::wpclsMakeAwake, returning pobject: 0x%lX",
                pObject));
    #endif

    return (pObject);
}

/*
 *@@ wpclsQuerySettingsPageSize:
 *      this WPObject class method should return the
 *      size of the largest settings page in dialog
 *      units; if a settings notebook is initially
 *      opened, i.e. no window pos has been stored
 *      yet, the WPS will use this size, to avoid
 *      truncated settings pages.
 *
 *      Since the "Object" page is pretty large,
 *      we return this.
 *
 *@@added V0.9.2 (2000-03-08) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobjM_wpclsQuerySettingsPageSize(M_XFldObject *somSelf,
                                                          PSIZEL pSizl)
{
    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsQuerySettingsPageSize");

    /* return (M_XFldObject_parent_M_WPObject_wpclsQuerySettingsPageSize(somSelf,
                                                                      pSizl)); */
    pSizl->cx = 275;       // size of "Object" page
    pSizl->cy = 150;       // size of "Object" page

    return (TRUE);
}

