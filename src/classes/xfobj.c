
/*
 *@@sourcefile xfobj.c:
 *      This file contains SOM code for the following XWorkplace classes:
 *
 *      --  XFldObject (WPObject replacement)
 *
 *      XFldObject gives the other classes access to WPS
 *      internals that cannot be reached otherwise. It
 *      also initializes the whole XWorkplace environment
 *      at Desktop startup by overriding M_XFldObject::wpclsInitData.
 *
 *      Also this class is needed for storing some extra data
 *      when objects have been deleted into the trash can.
 *
 *      This class must always be installed.
 *
 *      Starting with V0.9.0, the files in classes\ contain only
 *      i.e. the methods themselves.
 *      The implementation for this class is mostly in filesys\object.c.
 *
 *@@somclass XFldObject xfobj_
 *@@somclass M_XFldObject xfobjM_
 */

/*
 *      Copyright (C) 1997-2000 Ulrich M”ller.
 *      This file is part of the XWorkplace source package.
 *      XWorkplace is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published
 *      by the Free Software Foundation, in version 2 as it comes in the
 *      "COPYING" file of the XWorkplace main distribution.
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitctm: 2.42
 */

#ifndef SOM_Module_xfobj_Source
#define SOM_Module_xfobj_Source
#endif
#define XFldObject_Class_Source
#define M_XFldObject_Class_Source

#pragma strings(readonly)

/*
 *  Suggested #include order:
 *  1)  os2.h
 *  2)  C library headers
 *  3)  setup.h (code generation and debugging options)
 *  4)  headers in helpers\
 *  5)  at least one SOM implementation header (*.ih)
 *  6)  dlgids.h, headers in shared\ (as needed)
 *  7)  headers in implementation dirs (e.g. filesys\, as needed)
 *  8)  #pragma hdrstop and then more SOM headers which crash with precompiled headers
 */

#define INCL_DOSPROCESS
#define INCL_DOSEXCEPTIONS
#define INCL_DOSSEMAPHORES
#define INCL_DOSERRORS

#define INCL_WINWINDOWMGR
#define INCL_WINMENUS
#define INCL_WINDIALOGS
#define INCL_WINSTDCNR
#define INCL_WINSTDBOOK
#define INCL_WINPROGRAMLIST
#include <os2.h>

// C library headers
#include <stdio.h>
#include <setjmp.h>             // needed for except.h
#include <assert.h>             // needed for except.h

// generic headers
#include "setup.h"                      // code generation and debugging options

// headers in /helpers
#include "helpers\cnrh.h"               // container helper routines
#include "helpers\except.h"             // exception handling
#include "helpers\linklist.h"           // linked list helper routines
#include "helpers\standards.h"          // some standard macros
#include "helpers\stringh.h"            // string helper routines
#include "helpers\winh.h"               // PM helper routines
#include "helpers\xstring.h"            // extended string helpers

// SOM headers which don't crash with prec. header files
#include "xfldr.ih"
#include "xfobj.ih"

// XWorkplace implementation headers
#include "dlgids.h"                     // all the IDs that are shared with NLS
#include "shared\common.h"              // the majestic XWorkplace include file
#include "shared\helppanels.h"          // all XWorkplace help panel IDs
#include "shared\init.h"                // XWorkplace initialization
#include "shared\kernel.h"              // XWorkplace Kernel
#include "shared\notebook.h"            // generic XWorkplace notebook handling
#include "shared\wpsh.h"                // some pseudo-SOM functions (WPS helper routines)

#include "shared\center.h"              // public XCenter interfaces

#include "filesys\fdrmenus.h"           // shared folder menu logic
#include "filesys\fileops.h"            // file operations implementation
#include "filesys\folder.h"             // XFolder implementation
#include "filesys\icons.h"              // icons handling
#include "filesys\object.h"             // XFldObject implementation
#include "filesys\program.h"            // program implementation; WARNING: this redefines macros
#include "filesys\xthreads.h"           // extra XWorkplace threads

// other SOM headers
#pragma hdrstop
#include <wptrans.h>                    // WPTransient

#include "helpers\undoc.h"              // some undocumented stuff

/* ******************************************************************
 *
 *   Global variables
 *
 ********************************************************************/

// global variable whether XWorkplace is initialized yet
static BOOL         G_fXWorkplaceInitialized = FALSE;

extern WPFolder     *G_pConfigFolder;
                            // xfldr.c

/* ******************************************************************
 *
 *   here come the XFldObject instance methods
 *
 ********************************************************************/

/*
 *@@ xwpDestroyStorage:
 *      new XFldObject method to destroy the physical
 *      representation of an object.
 *
 *      See object.c for details about an object's lifecycle.
 *
 *      If folder auto-refresh has been enabled, we have to
 *      override wpFree in order to suppress the nasty message
 *      boxes which are apparently displayed by
 *      WPFileSystem::wpDestroyObject. Since we cannot override
 *      wpDestroyObject, we override wpFree which in turn calls
 *      this method (see XFldObject::wpFree, which calls objFree).
 *      In this method, we can then do the cleanup ourselves.
 *
 *@@added V0.9.9 (2001-02-04) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpDestroyStorage(XFldObject *somSelf)
{
    BOOL    brc = FALSE;
    xfTD_wpDestroyObject _wpDestroyObject = NULL;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpDestroyStorage");

    if (_wpDestroyObject = (xfTD_wpDestroyObject)wpshResolveFor(
                                             somSelf,
                                             NULL,
                                             "wpDestroyObject"))
        brc = _wpDestroyObject(somSelf);

    return (brc);
}

/*
 *@@ xwpAddObjectInternalsPage:
 *      this actually adds the "Internals" pages into all object notebooks,
 *      if the Global Settings allow it
 */

/* SOM_Scope ULONG  SOMLINK xfobj_xwpAddObjectInternalsPage(XFldObject *somSelf,
                                                            HWND hwndNotebook)
{
    PAGEINFO pi;
    const char* pszHelpLibrary = cmnQueryHelpLibrary();

    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpAddObjectInternalsPages");

    // insert Shutdown settings page
    memset((PCH)&pi, 0, sizeof(PAGEINFO));
    pi.cb                  = sizeof(PAGEINFO);
    pi.hwndPage            = NULLHANDLE;
    pi.pfnwp               = obj_fnwpSettingsObjDetails;
    pi.resid               = cmnQueryNLSModuleHandle(FALSE);
    pi.pCreateParams       = somSelf;
                // passed to obj_fnwpSettingsObjDetails in mp2
    pi.dlgid               = ID_XSD_OBJECTDETAILS;
    pi.usPageStyleFlags    = BKA_STATUSTEXTON | BKA_MAJOR;   // major tab;
    pi.usPageInsertFlags   = BKA_FIRST;
    pi.usSettingsFlags     = 0; // don't enumerate in status line
    pi.pszName             = cmnGetString(ID_XSSI_INTERNALS);

    pi.pszHelpLibraryName  = (PSZ)pszHelpLibrary;
    pi.idDefaultHelpPanel  = ID_XSH_SETTINGS_OBJINTERNALS;

    return (_wpInsertSettingsPage(somSelf, hwndNotebook, &pi));
} */

/*
 *@@ xwpQueryRealDefaultView:
 *      this new method returns the "real default view" of
 *      the object.
 *
 *      This might be the same as the return value of
 *      WPObject::wpQueryDefaultView, but not necessarily.
 *
 *      Thing is, several classes override the wpQueryDefaultView
 *      method to implement a different behavior. The most
 *      annoying example is the WPFolder class which implements
 *      the folder default view inheritance from the parent
 *      folder.
 *
 *      The WPObject class has an instance variable which
 *      contains the "real" default view for the object.
 *      This is mostly set to OPEN_DEFAULT (-1), which is
 *      never returned by WPObject::wpQueryDefaultView though,
 *      because in that case, M_WPObject::wpclsQueryDefaultView
 *      gets called. Since this mechanism apparently doesn't
 *      work for folders though, we have added this method
 *      which returns the true value of the instance variable.
 *
 *      This will only be != OPEN_DEFAULT if the user explicitly
 *      changed the default view for the object on the "Menu"
 *      page.
 *
 *      This returns 0 if we couldn't get access to the internal
 *      WPObject data.
 *
 *@@added V0.9.12 (2001-05-01) [umoeller]
 *@@changed V0.9.16 (2001-11-25) [umoeller]: now using new instance var to pick up changes
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpQueryRealDefaultView(XFldObject *somSelf)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryRealDefaultView");

    return (_ulDefaultView);
            // V0.9.16 (2001-11-25) [umoeller]
}

/*
 *@@ xwpQueryOriginalObjectID:
 *      returns the original object ID that was stored
 *      in the object's instance data. This is not
 *      necessarily the same value as WPObject::wpQueryObjectID.
 *
 *      The object ID is stored both in the instance data
 *      of the object (and thus restored with wpRestoreState)
 *      _and_ the list in the OS2.INI file. This leads to
 *      problems if the same folder is made awake from two
 *      WPS installations which use different INI files.
 *      The pathological case is that one WPS sets the object ID
 *      (which updates both the INI data and the instance data)
 *      and then another WPS encounters the object. With the
 *      second WPS, we then get the following scenario:
 *
 *      1) The WPS restores the object ID in wpRestoreState.
 *         wpRestoreState makes _no_ check for whether the
 *         object ID matches the one in the INI file (which
 *         it doesn't, in this case, because the ID was from
 *         another WPS).
 *
 *      2) For some stupid, stupid reason, WPObject::wpQueryObjectID
 *         however then _removes_ the object ID from the instance
 *         data if it doesn't match the INI file. This is desastrous
 *         for "foreign" desktops because in this case, the <WP_DESKTOP>
 *         ID is removed from the other desktop and that WPS won't
 *         start anymore then.
 *
 *      Here's our hack solution:
 *
 *      1) In XFldObject::wpRestoreState, we make a backup copy of
 *         the original object ID which has _not_ yet been verified
 *         against the INI data.
 *
 *      2) We leave WPObject::wpQueryObjectID alone, i.e. we allow
 *         it to nuke the object's instance data (but we still have
 *         the backup).
 *
 *      3) In XFldObject::wpSaveState, we check for whether we have
 *         a backup but the instance member is NULL. In that case,
 *         we temporarily hack the instance data to contain the
 *         old object ID again and restore the NULL pointer
 *         after the save.
 *
 *      This method returns the backed up value. This is only used
 *      in the object "Details" dialog.
 *
 *@@added V0.9.16 (2001-12-06) [umoeller]
 */

SOM_Scope PSZ  SOMLINK xfobj_xwpQueryOriginalObjectID(XFldObject *somSelf)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryOriginalObjectID");

    return _pszOriginalObjectID;
}

/*
 *@@ xwpQueryDeletion:
 *      this method may be called at any time to determine if and
 *      when an object has been deleted into the trash can.
 *
 *      If this object has been deleted into the XWorkplace trash can
 *      (that is, if the actual object currently resides in the hidden
 *      \TRASH directory tree and a related XWPTrashObject exists),
 *      this returns TRUE and puts the date and time of deletion into
 *      the specified structures.
 *
 *      If this object has not been deleted, FALSE is returned and the
 *      structures are not changed.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpQueryDeletion(XFldObject *somSelf,
                                               CDATE* pcdateDeleted,
                                               CTIME* pctimeDeleted)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);

    BOOL    brc = (_cdateDeleted.year != 0);     // V0.9.16 (2001-12-06) [umoeller]

    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryDeletion");

    _Pmpf((__FUNCTION__ ": _cdateDeleted.year %d, returning %d", _cdateDeleted.year, brc));

    if (brc)
    {
        if (pcdateDeleted)
            memcpy(pcdateDeleted, &_cdateDeleted, sizeof(CDATE));
        if (pctimeDeleted)
            memcpy(pctimeDeleted, &_ctimeDeleted, sizeof(CTIME));
    }

    return (brc);
}

/*
 *@@ xwpSetDeletion:
 *      this sets the deletion date and time fields for this object.
 *      This method is _only_ to be called by the XWorkplace trash
 *      can and changes the data which is subsequently returned by
 *      XFldObject::xwpQueryDeletion.
 *
 *      If (fSet == TRUE),the object is assumed to have been moved to the
 *      invisible TRASH directory on the object's drive already.
 *
 *      The object's internal fields for deletion date and time will
 *      then be set to the current system date and time, and
 *      subsequent calls to XFldObject::xwpQueryDeletion will return
 *      this data.
 *
 *      If (fSet == FALSE), this means the obejct is no longer
 *      considered "deleted" (because it's been restored), and subsequent
 *      calls to XFldObject::xwpQueryDeletion will return FALSE only.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetDeletion(XFldObject *somSelf,
                                             BOOL fSet)
{
    // BOOL    brc = FALSE;
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetDeletion");

    if (fSet)
    {
        // set deletion data:
        DATETIME    dt;
        DosGetDateTime(&dt);
        cnrhDateTimeDos2Win(&dt, &_cdateDeleted, &_ctimeDeleted);
        // _fDeleted = TRUE;        // V0.9.16 (2001-12-06) [umoeller]
    }
    else
        _cdateDeleted.year = 0; // fDeleted = FALSE;    V0.9.16 (2001-12-06) [umoeller]

    return (_wpSaveDeferred(somSelf));
}

/*
 *@@ xwpSetTrashObject:
 *      sets the internal trash object field to the specified
 *      trash object (XWPTrashObject) to be able to relate a
 *      deleted object to the corresponding trash object in the
 *      trash can. Only to be called by the trash can.
 *
 *@@added V0.9.3 (2000-04-11) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetTrashObject(XFldObject *somSelf,
                                                WPObject* pTrashObject)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetTrashObject");

    _pTrashObject = pTrashObject;

    return (TRUE);
}

/*
 *@@ xwpQueryListNotify:
 *      returns the current list notification flags for this
 *      object. See XFldObject::xwpSetListNotify for details.
 *
 *@@added V0.9.6 (2000-10-23) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpQueryListNotify(XFldObject *somSelf)
{
    ULONG   ulrc = 0;
    WPSHLOCKSTRUCT Lock = {0};
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryListNotify");

    TRY_LOUD(excpt1)
    {
        if (LOCK_OBJECT(Lock, somSelf))
        {
            XFldObjectData *somThis = XFldObjectGetData(somSelf);
            ulrc = _ulListNotify;
        }
    }
    CATCH(excpt1) {} END_CATCH();

    if (Lock.fLocked)
        _wpReleaseObjectMutexSem(Lock.pObject);

    return (ulrc);
}

/*
 *@@ xwpSetListNotify:
 *      sets the list notification flags for this object.
 *
 *      List notification flags are a new object feature
 *      with XWorkplace. These are intended to implement
 *      object-granular functions when an object has been
 *      stored in some XWP-internal list which needs to
 *      be updated in certain cases.
 *
 *      Current flags are:
 *
 *      -- OBJLIST_RUNNINGSTORED: this means that the
 *         object has been given in-use emphasis by
 *         progOpenProgram. This can happen to program
 *         objects (WPProgram or WPProgramFile) or
 *         data files. If the object is destroyed
 *         for whatever reason, the object needs to
 *         be removed from the list maintained by
 *         progOpenProgram because otherwise we'd
 *         run into problems when WM_APPTERMINATENOTIFY
 *         comes in.
 *
 *      -- OBJLIST_CONFIGFOLDER: this means that the
 *         object is a config folder or resides in
 *         one. The config folder cache must be invalidated
 *         when this object gets deleted.
 *
 *      -- OBJLIST_FAVORITEFOLDER: object is a folder
 *         on the "favorite folders" list.
 *
 *      -- OBJLIST_QUICKOPENFOLDER: object is a folder
 *         on the "quick-open folders" list.
 *
 *      -- OBJLIST_HANDLESCACHE: object is in handles
 *         cache (see objFindObjFromHandle).
 *
 *      -- OBJLIST_QUERYAWAKEFSOBJECT: object is in root
 *         folders list or has been touched by that cache
 *         (fdrRegisterAwakeRootFolder).
 *
 *      Note: These flags are NOT persistent across
 *      reboots, i.e. not stored with wpSaveState.
 *      They are also cleared for the copy if the
 *      object gets copied.
 *
 *@@added V0.9.6 (2000-10-23) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetListNotify(XFldObject *somSelf,
                                               ULONG flNotifyFlags)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock = {0};
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetListNotify");

    TRY_LOUD(excpt1)
    {
        if (LOCK_OBJECT(Lock, somSelf))
        {
            XFldObjectData *somThis = XFldObjectGetData(somSelf);
            _ulListNotify = flNotifyFlags;
            brc = TRUE;
        }
    }
    CATCH(excpt1) {} END_CATCH();

    if (Lock.fLocked)
        _wpReleaseObjectMutexSem(Lock.pObject);

    return (brc);
}

/*
 *@@ xwpModifyListNotify:
 *      this modifies the current list-notify flags for the
 *      current object in an atomic operation.
 *
 *      See XFldObject::xwpSetListNotify for details.
 *
 *      Use this method if you need to modify single flags
 *      while keeping others (instead of first querying and
 *      then setting the new flags). This function is an
 *      atomic operation, similar to wpModifyStyle.
 *
 *      This operates bit-wise. To set a flag, set it in
 *      both flNotifyFlags and flNotifyMask. To clear a
 *      flag, set it in flNotifyFlags only.
 *
 *      For example, to set FLAG1 and clear FLAG2, call:
 +
 +          _xwpModifyListNotify(...,
 +                               FLAG1 | FLAG2,     // affected flags
 +                               FLAG1);            // flags to set (i.e. clear FLAG2)
 *
 *@@added V0.9.6 (2000-10-23) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpModifyListNotify(XFldObject *somSelf,
                                                  ULONG flNotifyFlags,
                                                  ULONG flNotifyMask)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock = {0};
    XFldObjectMethodDebug("XFldObject","xfobj_xwpModifyListNotify");

    TRY_LOUD(excpt1)
    {
        if (LOCK_OBJECT(Lock, somSelf))
        {
            XFldObjectData *somThis = XFldObjectGetData(somSelf);

            _ulListNotify = (
                                // copy all unaffected
                                (_ulListNotify & ~flNotifyFlags)
                                // OR with masked new ones
                              | (flNotifyFlags & flNotifyMask)
                            );
            brc = TRUE;
        }
    }
    CATCH(excpt1) {} END_CATCH();

    if (Lock.fLocked)
        _wpReleaseObjectMutexSem(Lock.pObject);

    return (brc);
}

/*
 *@@ xwpAddWidgetNotify:
 *      adds a widget window handle to the object's
 *      internal widget-notify list.
 *
 *      Widget notifies are used to establish a link
 *      between a Desktop object and an object button widget
 *      in the XCenter. This will post a WM_CONTROL
 *      message to the given HWND in the following
 *      situations:
 *
 *      --  When the object is destroyed for any reason
 *          (i.e. when it is deleted or made dormant), the
 *          specified HWND is posted (!) a WM_CONTROL message
 *          with the XN_OBJECTDESTROYED notify code.
 *
 *          Any XCenter widget that uses an object pointer
 *          internally (such as the built-in object button
 *          widget) should use this method to destroy itself
 *          when its related object gets destroyed.
 *
 *      --  When the object's in-use emphasis changes
 *          (CRA_INUSE), XFldObject::wpCnrSetEmphasis
 *          posts a WM_CONTROL message with the
 *          XN_INUSECHANGED notify code.
 *
 *      Use XFldObject::xwpRemoveDestroyNotify to remove
 *      the notification again... e.g. when the widget
 *      itself is destroyed.
 *
 *@@added V0.9.7 (2001-01-03) [umoeller]
 *@@changed V0.9.13 (2001-06-21) [umoeller]: renamed from xwpAddDestroyNotify
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpAddWidgetNotify(XFldObject *somSelf,
                                                 HWND hwnd)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock = {0};
    XFldObjectMethodDebug("XFldObject","xfobj_xwpAddWidgetNotify");

    TRY_LOUD(excpt1)
    {
        if (LOCK_OBJECT(Lock, somSelf))
        {
            XFldObjectData *somThis = XFldObjectGetData(somSelf);
            if (_pvllWidgetNotifies == NULL)
                // list not created yet: do it now
                _pvllWidgetNotifies = lstCreate(FALSE);     // no auto-free
            else
                // list exists:
                // make sure it's not in the list yet
                // V0.9.13 (2001-06-21) [umoeller]
                if (lstIndexFromItem(_pvllWidgetNotifies,
                                     (PVOID)hwnd)
                        != -1)
                {
                    // exists already:
                    brc = TRUE;
                }

            if ((_pvllWidgetNotifies) && (!brc))
                lstAppendItem((PLINKLIST)_pvllWidgetNotifies,
                              (PVOID)hwnd);

            brc = TRUE;
        }
    }
    CATCH(excpt1) {} END_CATCH();

    if (Lock.fLocked)
        _wpReleaseObjectMutexSem(Lock.pObject);

    return (brc);
}

/*
 *@@ xwpRemoveDestroyNotify:
 *      the reverse to XFldObject::AddWidgetNotify.
 *
 *@@added V0.9.7 (2001-01-03) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpRemoveDestroyNotify(XFldObject *somSelf,
                                                     HWND hwnd)
{
    BOOL    brc = FALSE;
    WPSHLOCKSTRUCT Lock = {0};
    XFldObjectMethodDebug("XFldObject","xfobj_xwpRemoveDestroyNotify");

    TRY_LOUD(excpt1)
    {
        if (LOCK_OBJECT(Lock, somSelf))
        {
            XFldObjectData *somThis = XFldObjectGetData(somSelf);
            if (_pvllWidgetNotifies)
            {
                lstRemoveItem((PLINKLIST)_pvllWidgetNotifies,
                              (PVOID)hwnd);
            }

            brc = TRUE;
        }
    }
    CATCH(excpt1) {} END_CATCH();

    if (Lock.fLocked)
        _wpReleaseObjectMutexSem(Lock.pObject);

    return (brc);
}

/*
 *@@ xwpQueryObjectHotkey:
 *      this returns the global object hotkey which has been defined
 *      to be monitored for in the XWorkplace hook.
 *
 *      If this object has been assigned a hotkey to, TRUE is returned,
 *      and the hotkey data is stored in the OBJECTHOTKEY struct.
 *
 *      xfobj.idl defines OBJECTHOTKEY as follows:
 *
 +          struct OBJECTHOTKEY
 +          {
 +              USHORT  usFlags;
 +              UCHAR   ucScanCode;
 +              USHORT  usKeyCode;
 +          };
 *
 *      usFlags contains the flags for the fsFlags parameter of
 *      the WM_CHAR message (SHORT1FROMMP(mp1)). Those flags have
 *      been filtered. See GLOBALHOTKEY for the valid flags.
 *
 *      ucScanCode contains the hardware scan code which is used
 *      to identify the hotkey in the XWorkplace hook. Since the
 *      char and virtual codes are not valid when a VIO session
 *      currently has the input focus, only the scan code can be
 *      used to identify keystrokes in the hook.
 *
 *      If usFlags has the KC_VIRTUALKEY flag set, usKeyCode has
 *      the usvk parameter of WM_CHAR; otherwise, it has the usch
 *      parameter (SHORT1/2FROMMP(mp2)). This will only be used to
 *      be able to describe the key on the dialogs, not to identify
 *      keystrokes in the XWorkplace hook.
 *
 *      If no hotkey has been assigned, FALSE is returned only.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.16 (2001-10-15) [umoeller]: switched prototype to using struct
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpQueryObjectHotkey(XFldObject *somSelf,
                                                   XFldObject_POBJECTHOTKEY pHotkey)
{
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryObjectHotkey");

    return (objQueryObjectHotkey(somSelf, pHotkey));
}

/*
 *@@ xwpSetObjectHotkey:
 *      this sets a new global object hotkey for the object.
 *
 *      See XFldObject::xwpQueryObjectHotkey for the description
 *      of the hotkey parameters.
 *
 *      If the object was given a hotkey previously, the
 *      hotkey definition is overwritten.
 *
 *      If another object had the same object hotkey, the
 *      other object will lose its hotkey definition,
 *      because only each object must have a unique hotkey
 *      definition, if any.
 *
 *      As a special exception, if the pHotkey pointer is
 *      NULL, the hotkey for the object is removed from
 *      the internal hotkeys list (i.e. somSelf loses its
 *      hotkey).
 *
 *      The XWorkplace hook is automatically notified of the
 *      change, so that the new hotkey definition takes effect
 *      immediately.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpSetObjectHotkey(XFldObject *somSelf,
                                                 XFldObject_POBJECTHOTKEY pHotkey)
{
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetObjectHotkey");

    return (objSetObjectHotkey(somSelf, pHotkey));
}

/*
 *@@ xwpQuerySetup:
 *      this new XFldObject method composes a setup string
 *      for the given object which contains all non-default
 *      settings for this object.
 *
 *      This method is the reverse to the wpSetup method.
 *      The settings string returned by this method can be
 *      passed to wpSetup (or WinSetObjectData) to restore
 *      the setting for this object. Unfortunately, IBM
 *      has never implemented a "query setup" method, so
 *      I did this now.
 *
 *      Notes:
 *
 *      --  Starting with V0.9.16, this returns a string
 *          in a new buffer. If pulLength is != NULL, it
 *          receives the length of the string that was
 *          composed, excluding the null terminator.
 *
 *          Call XFldObject::xwpFreeSetupBuffer to free
 *          the return value.
 *
 *      --  This only returns setup strings which have
 *          non-default values. Since it can be hard to
 *          find out what the "default" really is for a
 *          setting, the values may differ between system
 *          reboots.
 *
 *      --  This method only resolves the method pointer for
 *          the "xwpQuerySetup2" method, which must to the actual
 *          setup string composing. See XFldObject::xwpQuerySetup2
 *          for details.
 *
 *      --  Never override this method for subclasses;
 *          override xwpQuerySetup2 instead.
 *
 *@@added V0.9.1 (2000-01-16) [umoeller]
 *@@changed V0.9.12 (2001-05-19) [umoeller]: added object lock
 *@@changed V0.9.16 (2001-10-11) [umoeller]: changed implementation to using XSTRINGs
 */

SOM_Scope PSZ  SOMLINK xfobj_xwpQuerySetup(XFldObject *somSelf,
                                           PULONG pulLength)
{
    PSZ pszReturn = NULL;
    XSTRING str;
    WPSHLOCKSTRUCT Lock = {0};

    XFldObjectMethodDebug("XFldObject","xfobj_xwpQuerySetup");

    xstrInit(&str, 500);

    TRY_LOUD(excpt1)
    {
        if (LOCK_OBJECT(Lock, somSelf))
        {
            // obtain "xwpQuerySetup2" method pointer
            somTD_XFldObject_xwpQuerySetup2 pfn_xwpQuerySetup2;

            if (pfn_xwpQuerySetup2 = (somTD_XFldObject_xwpQuerySetup2)somResolveByName(
                                                    somSelf,
                                                    "xwpQuerySetup2"))
            {
                // method resolved: call it
                if (    (pfn_xwpQuerySetup2(somSelf, &str))
                     && (str.ulLength)
                   )
                {
                    pszReturn = str.psz;
                            // do not free
                    if (pulLength)
                        *pulLength = str.ulLength;
                }
                else
                    xstrClear(&str);
            }
        }
    }
    CATCH(excpt1)
    {
        // crash:
        xstrClear(&str);
        pszReturn = NULL;
    } END_CATCH();

    if (Lock.fLocked)
        _wpReleaseObjectMutexSem(Lock.pObject);

    return (pszReturn);
}

/*
 *@@ xwpFreeSetupBuffer:
 *      this new XFldObject instance method frees the string
 *      buffer returned by XFldObject::xwpQuerySetup.
 *
 *@@added V0.9.16 (2001-10-11) [umoeller]
 */

SOM_Scope void  SOMLINK xfobj_xwpFreeSetupBuffer(XFldObject *somSelf,
                                                 PSZ pszSetupBuffer)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpFreeSetupBuffer");

    TRY_LOUD(excpt1)
    {
        if (pszSetupBuffer)
            free(pszSetupBuffer);
    }
    CATCH(excpt1) {} END_CATCH();
}

/*
 *@@ xwpQuerySetup2:
 *      this is the implementation for querying setup strings
 *      which gets called by XFldObject::xwpQuerySetup.
 *
 *      This has been placed into a separate method because this
 *      method needs to be called using SOM name-lookup
 *      resolution to support overriding it in subclasses
 *      of XFldObject (WPObject), which xwpQuerySetup does.
 *
 *      In other words:
 *
 *      --  _call_ xwpQuerySetup for getting a setup string.
 *
 *      --  _override_ xwpQuerySetup2 for adding setup-string support
 *          to your class.
 *
 *      Guidelines:
 *
 *      1.  You cannot simply use _parent_xwpQuerySetup2
 *          to call the parent method, because there's no C binding
 *          for this. The SOM header files do not know that WPObject
 *          has been replaced with XFldObject and therefore have no
 *          idea that XFldObject is actually a parent class of all
 *          other WPS classes. You must manually resolve the SOM
 *          method pointer for the parent class of your class;
 *          wpshParentQuerySetup2 has been provided to make this
 *          easier. See the code sample below.
 *
 *      2.  You must call the parent method _after_ your implementation
 *          to make sure XFldObject gets called last, because the OBJECTID
 *          setup string must be added at the very last position in the
 *          complete setup string (IBM says), and that string is implemented
 *          by the XFldObject method.
 *
 *      3.  The implementation of this method has been changed with
 *          V0.9.16. The PVOID is a pointer to an XSTRING buffer which
 *          has been initialized by XFldObject::xwpQuerySetup. Use
 *          the xstr* functions for appending stuff to the buffer.
 *
 *          This was changed because the double call to this method
 *          that was previously required always had the slight risk
 *          that the object data would change in between the two calls.
 *
 *      4.  Always terminate your setup strings with a semicolon (";"),
 *          even if it's the last.
 *
 *      5.  While this method is running, XWP has locked the object
 *          using its object mutex. So sending messages and other
 *          stuff is a no-no.
 *
 *      Use the following code to call the parent method (V0.9.16):
 *
 +          xstrcat(pstrSetup, "MYSETUPSTRING=VALUE;", 0);
 +              // and so on... settings for your class
 +
 +          return (wpshParentQuerySetup2(somSelf,
 +                                        _somGetParent(_XWPMyClass),
 +                                        pstrSetup));
 *
 *      If all methods obey these conventions, this results in a complete
 *      setup string for any object of any class, with the subclass's strings
 *      first and XFldObject's strings last.
 *
 *      See XFolder::xwpQuerySetup2 for a sample implementation
 *      which adds setup strings for a subclass of XFldObject.
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 *@@changed V0.9.16 (2001-10-11) [umoeller]: adjusted to new implementation
 */

SOM_Scope BOOL  SOMLINK xfobj_xwpQuerySetup2(XFldObject *somSelf,
                                             PVOID pstrSetup)
{
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQuerySetup2");

    return (objQuerySetup(somSelf,
                          pstrSetup));
}

/*
 *@@ xwpSetNextObj:
 *      wrapper around the undocumented WPObject method
 *      "wpSetNextObj".
 *
 *      From my testing, wpSetNextObj stores the "next object"
 *      in the object's internal instance data. This is either
 *      NULL if the object is the last object in a folder, or
 *      points to the next object (the one that comes after
 *      somSelf in the folder).
 *
 *      These pointers are apparently maintained by
 *      the WPFolder methods wpAddToContent and
 *      wpDeleteFromContent.
 *
 *      This wrapper resolves the method pointer and calls
 *      that method, since we have no access to WPObject's
 *      internal instance data (and better not touch it in
 *      the first place).
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_xwpSetNextObj(XFldObject *somSelf,
                                             WPObject* pobjNext)
{
    ULONG ulrc = 0;     // seems to be a BOOL
    WPObject **ppObjNext = NULL;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpSetNextObj");

    if (ppObjNext = wpshGetNextObjPointer(somSelf))
        *ppObjNext = pobjNext;

    return (ulrc);
}

/*
 *@@ xwpQueryNextObj:
 *      the reverse to XFldObject::xwpSetNextObj.
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope WPObject*  SOMLINK xfobj_xwpQueryNextObj(XFldObject *somSelf)
{
    WPObject *pobj = NULL;
    WPObject **ppObjNext = NULL;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_xwpQueryNextObj");

    if (ppObjNext = wpshGetNextObjPointer(somSelf))
        pobj = *ppObjNext;

    return (pobj);
}

/*
 *@@ wpInitData:
 *      this WPObject instance method gets called when the
 *      object is being initialized (on wake-up or creation).
 *      We initialize our additional instance data here.
 *      Always call the parent method first.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.2 (2000-03-15) [umoeller]: initializing new members
 */

SOM_Scope void  SOMLINK xfobj_wpInitData(XFldObject *somSelf)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpInitData");

    XFldObject_parent_WPObject_wpInitData(somSelf);

    // _fDeleted = FALSE;
    _cdateDeleted.year = 0;     // V0.9.16 (2001-12-06) [umoeller]

    _pObjectLongs = NULL;
    _cbObjectLongs = 0;

    _pObjectStrings = NULL;

    _pszOriginalObjectID = NULL;

    _pTrashObject = NULL;

    _ulListNotify = 0;

    _pvllWidgetNotifies = NULL;

    _ulDefaultView = 0;             // OPEN_DEFAULT
}

/*
 *@@ wpObjectReady:
 *      this WPObject notification method gets called by the
 *      WPS when object instantiation is complete, for any reason.
 *      ulCode and refObject signify why and where from the
 *      object was created.
 *      The parent method must be called first.
 *
 *      We will have this object's pointer stored
 *      in a global list (maintained by the Worker thread)
 *      so that XShutdown knows which objects are currently
 *      awake.
 *
 *      Note: On my Warp 4 (FP 10), this method does _not_
 *      get called for WPFolder instances, so we override
 *      XFolder::wpObjectReady also.
 *
 *      <B>Copying considerations</B>
 *
 *      Even though WPSREF doesn't really say so, this method
 *      must be used similar to a C++ copy constructor
 *      when the instance data contains pointers and the
 *      OR_REFERENCE bit is set in ulCode. When objects are
 *      copied, SOM just copies the binary instance data, so
 *      you get two objects with instance pointers pointing
 *      to the same object, which can only lead to problems.
 *
 *      According to wpobject.h, the OR_REFERENCE bit is set
 *      for OR_FROMTEMPLATE, OR_FROMCOPY, or OR_SHADOW; this
 *      means that refObject is valid.
 *
 *      When an object is copied in any way (thru wpCopyObject
 *      or wpCreateFromTemplate), the WPS first creates a
 *      new "empty" object (on which wpInitData is invoked),
 *      does a "flat" copy then,  and then invokes wpRestoreState
 *      on it. As the very last step, wpObjectReady gets called.
 *      As a result, you must only handle the instance data here
 *      which is not safely set thru wpRestoreState.
 *
 *@@changed V0.9.0: adjust for XFolder::wpObjectReady override
 *@@changed V0.9.7 (2000-12-18) [umoeller]: fixed _ulListNotify
 */

SOM_Scope void  SOMLINK xfobj_wpObjectReady(XFldObject *somSelf,
                                            ULONG ulCode,
                                            WPObject* refObject)
{
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    // XFldObjectMethodDebug("XFldObject","xfobj_wpObjectReady");

    #if defined(DEBUG_SOMMETHODS) || defined(DEBUG_AWAKEOBJECTS)
        _Pmpf(("xfobj_wpObjectReady for %s (class %s), ulCode: %s",
                _wpQueryTitle(somSelf),
                _somGetName(_somGetClass(somSelf)),
                (ulCode == OR_AWAKE) ? "OR_AWAKE"
                : (ulCode == OR_FROMTEMPLATE) ? "OR_FROMTEMPLATE"
                : (ulCode == OR_FROMCOPY) ? "OR_FROMCOPY"
                : (ulCode == OR_NEW) ? "OR_NEW"
                : (ulCode == OR_SHADOW) ? "OR_SHADOW"
                : (ulCode == OR_REFERENCE) ? "OR_REFERENCE"
                : "unknown code"
             ));
    #endif

    XFldObject_parent_WPObject_wpObjectReady(somSelf, ulCode,
                                             refObject);

    if (ulCode & OR_REFERENCE)
    {
        XFldObjectData *somThis = XFldObjectGetData(somSelf);
        _ulListNotify = 0;
            // V0.9.7 (2000-12-18) [umoeller]

        _pvllWidgetNotifies = NULL;
    }

    // on my Warp 4 FP 10, this method does not get
    // called for WPFolder instances, so we override
    // WPFolder::wpObjectReady also; but we don't know
    // if this is so with all Warp versions, so we
    // better check (the worker thread checks for
    // duplicates, so there's no problem in posting
    // this twice)
    if (!_somIsA(somSelf, _WPFolder))
        xthrPostWorkerMsg(WOM_ADDAWAKEOBJECT,
                         (MPARAM)somSelf,
                         MPNULL);
}

/*
 *@@ wpSetup:
 *      this WPObject instance method is called to allow an
 *      object to set itself up according to setup strings.
 *      As opposed to wpSetupOnce, this gets called any time
 *      a setup string is invoked.
 *
 *      We support the WRITEREXXSETUP string here.
 *
 *@@added V0.9.9 (2001-04-06) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSetup(XFldObject *somSelf, PSZ pszSetupString)
{
    BOOL    brc = FALSE;
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSetup");

    if (brc = XFldObject_parent_WPObject_wpSetup(somSelf, pszSetupString))
        brc = objSetup(somSelf,
                       pszSetupString);

    return (brc);
}

/*
 *@@ wpSetupOnce:
 *      this WPObject method allows special object handling
 *      based on a creation setup string after an object has
 *      been fully created.
 *      As opposed to WPObject::wpSetup, this method _only_
 *      gets called during object creation. The WPObject
 *      implementation calls wpSetup in turn.
 *      If FALSE is returned, object creation is aborted.
 *
 *      We check if we're being created inside the config folder.
 *      If so, we must invalidate the config folder cache.
 *
 *@@added V0.9.16 (2001-11-25) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSetupOnce(XFldObject *somSelf,
                                          PSZ pszSetupString)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSetupOnce");

    if (G_pConfigFolder)
        // config folder is awake:
        if (wpshResidesBelow(somSelf, G_pConfigFolder))
            mnuInvalidateConfigCache();

    return (XFldObject_parent_WPObject_wpSetupOnce(somSelf, pszSetupString));
}

/*
 *@@ wpFree:
 *      this WPObject method destroys the persistent form of the object
 *      and then frees the memory that represented that object.
 *      See object.c for a detailed description of an object's lifecycle.
 *
 *      If folder auto-refresh has been replaced by XWP, we override
 *      the entire WPObject::wpFree method without calling the parent.
 *      This is necessary for a number of reasons:
 *
 *      --  wpFree in turn calls the undocumented wpDestroyObject
 *          method, which has a number of bugs but cannot be overridden
 *          (because it's not exported in the IDL file).
 *
 *          So in order to fix those bugs, wpFree had to be rewritten,
 *          which now calls the new XFldObject::xwpDestroyStorage method
 *          (which is our reimplementation of wpDestroyObject).
 *
 *      --  wpFree is not very good at cleaning up object data in the
 *          INI files. This needs to be fixed finally.
 *
 *      In other words, when wpFree is now invoked on an object,
 *      the following happens:
 *
 *      1) In this method override, we clean up some object data and
 *         then call the xwpDestroyStorage method, using SOM name-lookup
 *         resolution. This allows subclasses (such as XFolder
 *         and XFldDataFile) to override the method, even though
 *         SOM doesn't know that XFldObject is actually a parent
 *         class of those subclasses (since the IDL files do not
 *         reflect that WPObject has been replaced with XFldObject).
 *
 *      2) XFldObject::xwpDestroyStorage is the standard implementation,
 *         which invokes the standard undocumented wpDestroyObject
 *         method.
 *
 *      In summary, for classes which have not overridden xwpNukeObject,
 *      the behavior is EXACTLY as with the standard WPObject::wpFree.
 *
 *      HOWEVER, this way we can override xwpDestroyStorage in
 *      XFldDataFile and XFolder to fix the annoying message box
 *      bugs.
 *
 *@@added V0.9.9 (2001-02-04) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpFree(XFldObject *somSelf)
{
    BOOL                brc = FALSE;
    PCKERNELGLOBALS     pKernelGlobals = krnQueryGlobals();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpFree");

    if (pKernelGlobals->fAutoRefreshReplaced)
    {
        ULONG   ulStyle = _wpQueryStyle(somSelf);
        PSZ     pszID = _wpQueryObjectID(somSelf);
        somTD_XFldObject_xwpDestroyStorage pxwpDestroyStorage = NULL;
        xfTD_wpDeleteWindowPosKeys _wpDeleteWindowPosKeys = NULL;
        xfTD_wpMakeDormant _wpMakeDormant = NULL;

        // if the object has an object ID assigned, remove this...
        // this should clean the INI entry
        if (pszID && strlen(pszID))
            _wpSetObjectID(somSelf, NULL);

        // if the object is a template, unset that bit...
        // this should clean the INI entry as well
        if (ulStyle & OBJSTYLE_TEMPLATE)
            _wpModifyStyle(somSelf, OBJSTYLE_TEMPLATE, 0);

        // OK, here comes the fun stuff.
        // The WPS normally calls the "wpDestroyObject" method,
        // which is responsible for killing the physical representation
        // of the object. Unfortunately, we cannot override that method
        // because IBM wasn't kind enough to make it public. Our way
        // around this (without breaking compatibility) is to introduce
        // a new method in XFldObject, which calls wpDestroyObject per
        // default.

        // We resolve the method by name because it is overridden
        // in some XWorkplace classes. If it is not overridden,
        // XFldObject::xwpDestroyStorage calls wpDestroyObject.
        if (pxwpDestroyStorage = (somTD_XFldObject_xwpDestroyStorage)somResolveByName(
                                  somSelf,
                                  "xwpDestroyStorage"))
            pxwpDestroyStorage(somSelf);

        // the WPS then calls wpSaveImmediate just in case the object
        // has called wpSaveDeferred. I'm not sure this is a good idea...
        // this will add another entry to the INI file. This should be
        // moved up.
        _wpSaveImmediate(somSelf);

        // then there's another undocumented method call... i'm unsure
        // what this does, but what the heck. We need to resolve this
        // manually.
        if (_wpDeleteWindowPosKeys = (xfTD_wpDeleteWindowPosKeys)wpshResolveFor(
                                                somSelf,
                                                NULL,
                                                "wpDeleteWindowPosKeys"))
            _wpDeleteWindowPosKeys(somSelf);

        // finally, this calls wpMakeDormant, which destroys the SOM object
        if (_wpMakeDormant = (xfTD_wpMakeDormant)wpshResolveFor(
                                                somSelf,
                                                NULL,
                                                "wpMakeDormant"))
            brc = _wpMakeDormant(somSelf, 0);
    } // if (pKernelGlobals->fAutoRefreshReplaced)
    else
        brc = XFldObject_parent_WPObject_wpFree(somSelf);

    return (brc);
}

/*
 *@@ wpUnInitData:
 *      this WPObject instance method is called when the object
 *      is destroyed as a SOM object, either because it's being
 *      made dormant or being deleted. All allocated resources
 *      should be freed here.
 *      The parent method must always be called last.
 *
 *      We will have this object removed from our global list
 *      of awake objects.
 *
 *@@changed V0.9.3 (2000-04-11) [umoeller]: now destroying related trash object too
 *@@changed V0.9.6 (2000-10-23) [umoeller]: added support for progOpenProgram
 *@@changed V0.9.7 (2001-01-18) [umoeller]: added support for favorite and quick-open folders
 *@@changed V0.9.16 (2001-12-31) [umoeller]: added fixes for replacement icons
 */

SOM_Scope void  SOMLINK xfobj_wpUnInitData(XFldObject *somSelf)
{
    PMINIRECORDCORE pmrc = _wpQueryCoreRecord(somSelf);

    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpUnInitData");

    // have object removed from awake-objects list
    xthrPostWorkerMsg(WOM_REMOVEAWAKEOBJECT,
                      (MPARAM)somSelf,
                      MPNULL);

    // kill the title string we allocated in our wpSetTitle replacement
    // V0.9.16 (2002-01-04) [umoeller]
    if (pmrc->pszIcon)
    {
        _wpFreeMem(somSelf, pmrc->pszIcon);
        // we must set the ptr to NULL or the WPS will crash
        // in the parent method call
        pmrc->pszIcon = NULL;
    }

    // we have a problem with our replacement icons in that
    // the WPS frees the pointer handle in WPObject::wpUnInitData
    // if the object has the OBJSTYLE_NOTDEFAULTICON or OBJSTYLE_TEMPLATE
    // flags set... so in these cases, check if the object has one
    // of our standard icons WHICH MUST NOT BE FREED under any circumstances,
    // or the shared icon would disappear globally
    // V0.9.16 (2001-12-31) [umoeller]
    if (_wpQueryStyle(somSelf) & (OBJSTYLE_NOTDEFAULTICON | OBJSTYLE_TEMPLATE))
    {
        if (    (pmrc)
             && (cmnIsStandardIcon(pmrc->hptrIcon))
           )
        {
            // alright, the WPS is about to nuke this icon:
            // set the HPOINTER in the record to NULLHANDLE
            // to prevent the WPS from freeing it
            pmrc->hptrIcon = NULLHANDLE;
        }
    }

    // free the object ID backup if there's one
    // V0.9.16 (2001-12-06) [umoeller]
    strhStore(&_pszOriginalObjectID, NULL, NULL);

    // destroy trash object, if there's one
    if (_pTrashObject)
        _wpFree(_pTrashObject);

    // go thru list notifications, if we have any
    if (_ulListNotify)
    {
        if (_ulListNotify & OBJLIST_RUNNINGSTORED)
        {
            // this object is currently stored in the
            // "running programs" list: remove it, or
            // we'll get crashes later...
            _ulListNotify &= ~OBJLIST_RUNNINGSTORED;
            progRunningAppDestroyed(somSelf);
        }

        if (_ulListNotify & OBJLIST_CONFIGFOLDER)
        {
            // somSelf is in the config folder hierarchy:
            // invalidate the content lists for the config
            // folders so that they will be rebuilt
            _ulListNotify &= ~OBJLIST_CONFIGFOLDER;
            mnuInvalidateConfigCache();
        }

#ifndef __NOFOLDERCONTENTS__
        if (_ulListNotify & OBJLIST_FAVORITEFOLDER)
        {
            _ulListNotify &= ~OBJLIST_FAVORITEFOLDER;
            objAddToList(somSelf,
                         &G_llFavoriteFolders,      // folder.h
                         FALSE,         // remove
                         INIKEY_FAVORITEFOLDERS,
                         0);            // no modify flags... we're being destroyed
        }
#endif

#ifndef __NOQUICKOPEN__
        if (_ulListNotify & OBJLIST_QUICKOPENFOLDER)
        {
            _ulListNotify &= ~OBJLIST_QUICKOPENFOLDER;
            objAddToList(somSelf,
                         &G_llQuickOpenFolders,      // folder.h
                         FALSE,         // remove
                         INIKEY_QUICKOPENFOLDERS,
                         0);            // no modify flags... we're being destroyed
        }
#endif

        if (_ulListNotify & OBJLIST_HANDLESCACHE)
        {
            _ulListNotify &= ~OBJLIST_HANDLESCACHE;
            objRemoveFromHandlesCache(somSelf);
        }

        if (_ulListNotify & OBJLIST_DIRTYLIST)  // V0.9.11 (2001-04-18) [umoeller]
        {
            // _ulListNotify &= ~OBJLIST_DIRTYLIST;
            objRemoveFromDirtyList(somSelf);
                    // this unsets the flag
        }

        if (_ulListNotify & OBJLIST_QUERYAWAKEFSOBJECT)  // V0.9.16 (2001-10-25) [umoeller]
        {
            _ulListNotify &= ~OBJLIST_QUERYAWAKEFSOBJECT;
            fdrRemoveAwakeRootFolder(somSelf);
        }
    }

    if (_pvllWidgetNotifies)
    {
        // we have windows that requested notifications:
        // go thru list
        PLISTNODE pNode = lstQueryFirstNode(_pvllWidgetNotifies);
        while (pNode)
        {
            HWND hwnd = (HWND)pNode->pItemData;
            WinPostMsg(hwnd,
                       WM_CONTROL,
                       MPFROM2SHORT(ID_XCENTER_CLIENT,
                                    XN_OBJECTDESTROYED),
                       (MPARAM)somSelf);
            pNode = pNode->pNext;
        }

        lstFree((LINKLIST**)&_pvllWidgetNotifies);
    }

    XFldObject_parent_WPObject_wpUnInitData(somSelf);
}

/*
 *@@ wpSetTitle:
 *      this WPObject instance method sets a new title
 *      for the object. This gets called during object
 *      instantiation and later if the object title is
 *      changed, e.g. from the settings notebook or
 *      via direct editing in a folder container.
 *
 *      Since this stupid method also resorts the folder
 *      after title changes, I have rewritten this.
 *
 *      From my testing, this is the ONLY place in the
 *      WPS which actually allocates memory for the
 *      title string and stores that in MINIRECORDCORE.pszIcon.
 *      So we can safely override this and allocate the
 *      string memory for our own heap (as long as we free
 *      the memory properly in wpUnInitData).
 *
 *@@added V0.9.16 (2002-01-04) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSetTitle(XFldObject *somSelf,
                                         PSZ pszNewTitle)
{
    BOOL    brc = FALSE,
            fLocked = FALSE;

    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSetTitle");

    // return (XFldObject_parent_WPObject_wpSetTitle(somSelf, pszNewTitle));

    TRY_LOUD(excpt1)
    {
        if (pszNewTitle)
        {
            PMINIRECORDCORE pRecord = _wpQueryCoreRecord(somSelf);
            ULONG ulNewTitleLen = strlen(pszNewTitle);

            PSZ pszNewTitleCopy;
            ULONG ulError;

            // use the WPS heap in order not to clutter up
            // our own heap with all the string data
            if (pszNewTitleCopy = _wpAllocMem(somSelf,
                                              ulNewTitleLen + 1,
                                              &ulError))
            {
                PSZ p;

                memcpy(pszNewTitleCopy, pszNewTitle, ulNewTitleLen + 1);

                // replace all '^' with '\n'
                p = pszNewTitleCopy;
                while (p = strchr(p, '^'))
                    *p = '\n';

                if (    (!pRecord->pszIcon)
                     || (strcmp(pRecord->pszIcon, pszNewTitleCopy))
                   )
                {
                    // new title is different:
                    ULONG           ulStyle = _wpQueryStyle(somSelf);
                    BOOL            fIsInitialized = _wpIsObjectInitialized(somSelf);

                    if (    (ulStyle & OBJSTYLE_TEMPLATE)
                         && (fIsInitialized)
                       )
                    {
                        // renaming a template: template entries in
                        // OS2.INI are based on names, so unset
                        // the template flag; this will nuke the
                        // template entry from OS2.INI, we'll add
                        // a new one below
                        _wpModifyStyle(somSelf,
                                       OBJSTYLE_TEMPLATE,
                                       0);
                    }

                    // now go set the new string which we allocated above
                    if (pRecord->pszIcon)
                        _wpFreeMem(somSelf, pRecord->pszIcon);
                    pRecord->pszIcon = pszNewTitleCopy;

                    brc = TRUE;

                    // now go refresh all the views...
                    // no need to do that if the object isn't even
                    // initialized yet because then we can neither
                    // have shadows pointing to it nor can it be
                    // inserted into a container yet
                    if (    (fIsInitialized)
                         && (fLocked = !_wpRequestObjectMutexSem(somSelf, SEM_INDEFINITE_WAIT))
                       )
                    {
                        objRefreshUseItems(somSelf, pszNewTitleCopy);
                    }

                    if (    (ulStyle & OBJSTYLE_TEMPLATE)
                         && (fIsInitialized)
                       )
                    {
                        // re-enter the template entry we killed above
                        _wpModifyStyle(somSelf,
                                       OBJSTYLE_TEMPLATE,
                                       OBJSTYLE_TEMPLATE);
                    }
                }
                else
                    // title hasn't changed:
                    _wpFreeMem(somSelf, pszNewTitleCopy);

            } // end if (pszNewTitleCopy = strdup(pszNewTitle))
        } // end if (pszNewTitle)
        // else: do nothing, return FALSE
    }
    CATCH(excpt1)
    {
        brc = FALSE;
    } END_CATCH();

    if (fLocked)
        _wpReleaseObjectMutexSem(somSelf);

    return (brc);
}

/*
 *@@ wpSetDefaultView:
 *      overridden to catch a notification if the default
 *      view of the folder is to be changed (via the "Menu"
 *      page, probably).
 *
 *      Otherwise our change isn't picked up, for some reason.
 *
 *@@added V0.9.16 (2001-11-25) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSetDefaultView(XFldObject *somSelf,
                                               ULONG ulView)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSetDefaultView");

    _ulDefaultView = ulView;

    return (XFldObject_parent_WPObject_wpSetDefaultView(somSelf,
                                                        ulView));
}

/*
 *@@ wpSetObjectID:
 *      this WPObject method sets a new object ID for the
 *      object. We must then invalidate our backup object
 *      ID, or we'll run into problems in wpSaveState.
 *
 *      See XFldObject::xwpQueryOriginalObjectID for details.
 *
 *@@added V0.9.16 (2001-12-06) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSetObjectID(XFldObject *somSelf,
                                            PSZ pszObjectID)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSetObjectID");

    // now this is a true override of the object ID,
    // so nuke the one we backed up, but only if the
    // object has been initialized
    if (_wpIsObjectInitialized(somSelf))
        strhStore(&_pszOriginalObjectID, NULL, NULL);

    return (XFldObject_parent_WPObject_wpSetObjectID(somSelf,
                                                     pszObjectID));
}

/*
 *@@ wpSaveDeferred:
 *      this WPObject method saves object instance data
 *      asynchronously on a separate thread.
 *
 *      What the WPS really does here is to put the object
 *      on an internal list. There is some separate thread
 *      running which ages the objects on the list and,
 *      if an object has aged enough, will invoke
 *      WPObject::wpSaveImmediate upon the object, which
 *      not only saves the data by invoking the object's
 *      wpSaveState, but remove it from the ager list as
 *      well.
 *
 *      Now, we need to override this method to keep track
 *      of which objects are currently on the list. Otherwise
 *      objects won't be properly saved during XShutdown.
 *
 *      This WPObject method is never overridden in the WPS.
 *
 *@@added V0.9.9 (2001-04-04) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSaveDeferred(XFldObject *somSelf)
{
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSaveDeferred");

    // add the object to our private "dirty" list
    objAddToDirtyList(somSelf);

    // and call the parent...
    return (XFldObject_parent_WPObject_wpSaveDeferred(somSelf));
}

/*
 *@@ wpSaveImmediate:
 *      this WPObject method allocates some memory and then
 *      invokes the object's wpSaveState so that the object's
 *      instance data will be saved synchronously. The
 *      WPObject implementation calls wpSaveState eventually.
 *
 *      This can get called in three situations:
 *
 *      --  Explicitly, if an object wants to save its state
 *          _now_, e.g. because some critical data has changed.
 *
 *      --  Deferred as a result of WPObject::wpSaveDeferred,
 *          if the object has aged enough. This method will
 *          then run on the WPS-internal ager thread (see
 *          XFldObject::wpSaveDeferred).
 *
 *      --  Automatically during WPObject::wpMakeDormant if
 *          the object has a deferred save pending.
 *
 *      We remove the object from our private "dirty" list
 *      because it no longer needs to be saved on shutdown.
 *      See XFldObject::wpSaveDeferred.
 *
 *      This method is overridden by the base storage classes
 *      (WPAbstract, WPFileSystem, WPTransient), but most of
 *      them call the WPObject parent... except WPAbstract,
 *      apparently, which only sometimes calls the parent
 *      for some reason. Never mind, we still know that the
 *      object has been touched, so we have it on the list
 *      for XShutdown. Saving twice won't hurt.
 *
 *@@added V0.9.9 (2001-04-04) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSaveImmediate(XFldObject *somSelf)
{
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSaveImmediate");

    objRemoveFromDirtyList(somSelf);

    // now make sure the object is not residing below some desktop
    // which isn't the current desktop... we run into endless
    // problems with object IDs if we save objects that aren't
    // ours!
    // if (!cmnIsObjectFromForeignDesktop(somSelf))
        return (XFldObject_parent_WPObject_wpSaveImmediate(somSelf));

    // else: we shouldn't save...
    /* {
        CHAR szFolderPath[CCHMAXPATH];
        _wpQueryFilename(_wpQueryFolder(somSelf),
                         szFolderPath,
                         TRUE);
        cmnLog(__FILE__, __LINE__, __FUNCTION__,
               "skipping save of object %s (class: %s) in folder %s",
               _wpQueryTitle(somSelf),
               _somGetClassName(somSelf),
               szFolderPath);
    }

    return (TRUE);*/
}

/*
 *@@ wpSaveState:
 *      this WPObject instance method saves an object's state
 *      persistently so that it can later be re-initialized
 *      with wpRestoreState. This gets called during wpClose,
 *      wpSaveImmediate or wpSaveDeferred processing.
 *      All persistent instance variables should be stored here.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.16 (2001-12-06) [umoeller]: fixed problems with disappearing object IDs
 */

SOM_Scope BOOL  SOMLINK xfobj_wpSaveState(XFldObject *somSelf)
{
    BOOL    brc = FALSE,
            fHacked = FALSE;
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpSaveState");

    // now, here's the bug with the object IDs disappearing if
    // the object's ID was set from another Desktop...
    // see XFldObject::xwpQueryOriginalObjectID for the scenario.

    if (    // we have a pointer to the object strings:
            (_pObjectStrings)
            // and object ID in instance data is NULL:
         && (!_pObjectStrings->pszObjectID)
            // but there was one originally:
         && (_pszOriginalObjectID)
       )
    {
        // restore the old object ID for save!!
        _Pmpf((__FUNCTION__ ": restoring old object ID \"%s\" for save", _pszOriginalObjectID));

        _pObjectStrings->pszObjectID = _pszOriginalObjectID;
        fHacked = TRUE;
    }

    brc = XFldObject_parent_WPObject_wpSaveState(somSelf);

    if (fHacked)
        // restore old NULL pointer
        _pObjectStrings->pszObjectID = NULL;

    if (_cdateDeleted.year != 0)        // V0.9.16 (2001-12-06) [umoeller]
    {
        // save deletion data:
        _wpSaveData(somSelf, (PSZ)G_pcszXFldObject, 1,
                    (PBYTE)&_cdateDeleted, sizeof(CDATE));
        _wpSaveData(somSelf, (PSZ)G_pcszXFldObject, 2,
                    (PBYTE)&_ctimeDeleted, sizeof(CTIME));
    }

    return (brc);
}

/*
 *@@ wpRestoreState:
 *      this WPObject instance method gets called during object
 *      initialization (after wpInitData) to restore the data
 *      which was stored with wpSaveState.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.16 (2001-12-06) [umoeller]: now saving backup of object ID
 */

SOM_Scope BOOL  SOMLINK xfobj_wpRestoreState(XFldObject *somSelf,
                                             ULONG ulReserved)
{
    BOOL    brc = FALSE;
    ULONG   cbcdate = sizeof(CDATE),
            cbctime = sizeof(CTIME);
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpRestoreState");

    brc = XFldObject_parent_WPObject_wpRestoreState(somSelf,
                                                    ulReserved);

    // now check: if an object ID was remembered with
    // this object's instance data, make a backup of
    // this because _wpQueryObjectID sometimes resets
    // this to NULL
    // V0.9.16 (2001-12-06) [umoeller]
    if (    (_pObjectStrings)
         && (_pObjectStrings->pszObjectID)
         && (*(_pObjectStrings->pszObjectID))
       )
        strhStore(&_pszOriginalObjectID, _pObjectStrings->pszObjectID, NULL);

    // restore trash can deletion
    if (    (_wpRestoreData(somSelf, (PSZ)G_pcszXFldObject, 1,
                            (PBYTE)&_cdateDeleted, &cbcdate))
         && (_wpRestoreData(somSelf, (PSZ)G_pcszXFldObject, 2,
                            (PBYTE)&_ctimeDeleted, &cbctime))
       )
        // both keys successfully restored:
        ; // _fDeleted = TRUE;  V0.9.16 (2001-12-06) [umoeller]
    else
        _cdateDeleted.year = 0;         // V0.9.16 (2001-12-06) [umoeller]

    return (brc);
}

/*
 *@@ wpRestoreData:
 *      this instance method restores a 32-bit data
 *      value for the object data upon object awakening.
 *
 *      We check the "ulKey" value after having called
 *      the parent to be able to intercept the pointer
 *      to certain WPS-internal object data, which
 *      we cannot access otherwise. That's a real ugly
 *      kludge, but there's no other way to get certain
 *      object settings. ;-)
 *
 *      It is possible to override this method for WPObject
 *      even though WPObject does not define the implementation
 *      how object data is stored and restored. This works
 *      because the implementation apparently sits in
 *      wpRestoreState, which is overridden by the WPS
 *      base storage classes (WPAbstract, WPTransient,
 *      WPFileSystem). This method is _not_ overridden.
 *
 *@@added V0.9.1 (2000-01-22) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpRestoreData(XFldObject *somSelf,
                                            PSZ pszClass, ULONG ulKey,
                                            PBYTE pValue, PULONG pcbValue)
{
    BOOL    brc = FALSE;
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpRestoreData");

    brc = XFldObject_parent_WPObject_wpRestoreData(somSelf,
                                                   pszClass,
                                                   ulKey, pValue,
                                                   pcbValue);

    if ( (brc) && (pValue) )
    {
        switch (ulKey)
        {
            case 11:        // IDKEY_OBJLONGS, not defined
                _pObjectLongs = (PVOID)pValue;
                // store object default view for xwpQueryDefaultView
                // V0.9.16 (2001-11-25) [umoeller]
                _ulDefaultView = _pObjectLongs->lDefaultView;

                _cbObjectLongs = *pcbValue;

                // object strings come right after this
                _pObjectStrings = (PWPOBJECTSTRINGS)(   (PBYTE)(_pObjectLongs)
                                                      + _cbObjectLongs
                                                    );
            break;
        }
    }

    return (brc);
}

/*
 *@@ wpFilterPopupMenu:
 *      this WPObject instance method allows the object to
 *      filter out unwanted menu items from the context menu.
 *      This gets called before wpModifyPopupMenu.
 *
 *      We remove default entries according to global settings.
 *
 *@@changed V0.9.5 (2000-09-20) [pr]: fixed context menu flags
 */

SOM_Scope ULONG  SOMLINK xfobj_wpFilterPopupMenu(XFldObject *somSelf,
                                                   ULONG ulFlags,
                                                   HWND hwndCnr,
                                                   BOOL fMultiSelect)
{
    ULONG ulMenuFilter = 0;
    // PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpFilterPopupMenu");

    ulMenuFilter = XFldObject_parent_WPObject_wpFilterPopupMenu(somSelf,
                                                         ulFlags,
                                                         hwndCnr,
                                                         fMultiSelect);
    #ifdef DEBUG_MENUS
        _Pmpf((__FUNCTION__ ": ulMenuFilter & CTXT_CRANOTHER: 0x%lX %d",
                ulMenuFilter, ((ulMenuFilter) & CTXT_CRANOTHER)));
    #endif

    // if object has been deleted already (ie. is in trashcan),
    // remove delete
    if (_cdateDeleted.year != 0)    // V0.9.16 (2001-12-06) [umoeller]
        ulMenuFilter &= ~CTXT_DELETE; // V0.9.5 (2000-09-20) [pr]

    // now suppress default menu items according to
    // Global Settings;
    // the DefaultMenuItems field in pGlobalSettings is
    // ready-made for this function; the "Workplace Shell"
    // notebook page for removing menu items sets this field with
    // the proper CTXT_xxx flags
    return ((ulMenuFilter
            // first we add "Create another", because for
            // some reason it's always disabled if XFolder
            // is installed; I don't know why
            // V0.9.5 (2000-09-20) [pr] No it's not. This causes problems
            // with objects wrongly having Create Another options.
            /*| CTXT_CRANOTHER*/ ) // V0.9.5 (2000-09-20) [pr]
            // then disable items, this may include CTXT_CRANOTHER
            & ~(cmnQuerySetting(sflDefaultMenuItems))
        );
}

/*
 *@@ wpModifyPopupMenu:
 *      this WPObject instance methods gets called by the WPS
 *      when a context menu needs to be built for the object
 *      and allows the object to manipulate its context menu.
 *      This gets called _after_ wpFilterPopupMenu.
 *
 *      We remove the "Lock in place" item here because there's
 *      no flag for that in wpFilterPopupMenu.
 *
 *@@changed V0.9.7 (2000-12-10) [umoeller]: added "fix lock in place"
 */

SOM_Scope BOOL  SOMLINK xfobj_wpModifyPopupMenu(XFldObject *somSelf,
                                                HWND hwndMenu,
                                                HWND hwndCnr,
                                                ULONG iPosition)
{
    BOOL        rc;
    // PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpModifyPopupMenu");

    rc = (XFldObject_parent_WPObject_wpModifyPopupMenu(somSelf,
                                                       hwndMenu,
                                                       hwndCnr,
                                                       iPosition));
    if (rc)
        objModifyPopupMenu(somSelf, hwndMenu);  // V0.9.7 (2000-12-10) [umoeller]

    // now that the menu is completely built, let's add hotkey
    // descriptions, but DONT do this for folders or data files,
    // because those menu items will only be added later... for
    // folders, we call this function in XFolder::wpMenuItemSelected
    if (!_somIsA(somSelf, _WPFileSystem))
        fdrAddHotkeysToMenu(somSelf,
                            hwndCnr,
                            hwndMenu);

    return rc;
}

/*
 *@@ wpMenuItemSelected:
 *      this WPObject method processes menu selections.
 *      This must be overridden to support new menu
 *      items which have been added in wpModifyPopupMenu.
 *
 *      Note that the WPS invokes this method upon every
 *      object which has been selected in the container.
 *      That is, if three objects have been selected and
 *      a menu item has been selected for all three of
 *      them, all three objects will receive this method
 *      call. This is true even if FALSE is returned from
 *      this method by one of the objects.
 *
 *      In order to be able to process all objects at
 *      once, we now have XFolder::xwpProcessObjectCommand,
 *      which can intercept the menu ID even before this
 *      method is invoked on each object and process all
 *      objects in one flush.
 *
 *      We override this to move objects into the
 *      trash can instead, if necessary.
 *
 *      Note: This method normally doesn't get called
 *      during the regular WPS file operations once
 *      the trash can has been enabled because XFolder
 *      intercepts all file operations commands and
 *      performs the required actions directly without
 *      calling this method. However, this method still
 *      gets called by WinDestroyObject and the REXX
 *      counterpart, SysDestroyObject.
 *
 *@@changed V0.9.7 (2000-12-10) [umoeller]: added "fix lock in place"
 *@@changed V0.9.7 (2001-01-15) [umoeller]: added WPMENUID_DELETE if trash can is enabled
 *@@changed V0.9.9 (2001-03-10) [pr]: this screwed up print jobs, now checking for WPTransient
 *@@changed V0.9.16 (2001-12-06) [umoeller]: fixed shredder deleting into trash can
 */

SOM_Scope BOOL  SOMLINK xfobj_wpMenuItemSelected(XFldObject *somSelf,
                                                 HWND hwndFrame,
                                                 ULONG ulMenuId)
{
    BOOL        brc = FALSE,
                fCallDefault = FALSE;

    // PGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpMenuItemSelected");

    switch (ulMenuId)
    {
        #ifdef DEBUG_CONTEXT
            case ID_XFMI_RECORDCORE:
            {
                int                 i;
                CHAR                szMsg[1024] = "No record core.",
                                    szTitle[1024],
                                    szBuf[20] = "0x00000000";
                PMINIRECORDCORE     pMRC = _wpQueryCoreRecord(somSelf);
                PCLASSFIELDINFO     pCFI, pCFI2;
                ULONG               ulCFISize = 0, ulErr;

                strcpy(szTitle, "Record core for ");
                strcat(szTitle, _wpQueryTitle(somSelf));

                strcpy(szMsg, "Size of core record (cb): ");
                UL2H(szBuf+2, pMRC->cb);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nSize of MINIRECORDCORE:   ");
                UL2H(szBuf+2, sizeof(MINIRECORDCORE));
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nSize of RECORDCORE:       ");
                UL2H(szBuf+2, sizeof(RECORDCORE));
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nNext record:              ");
                UL2H(szBuf+2, (ULONG)pMRC->preccNextRecord);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nIcon X pos:               ");
                UL2H(szBuf+2, pMRC->ptlIcon.x);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\nIcon Y pos:               ");
                UL2H(szBuf+2, pMRC->ptlIcon.y);
                strcat(szMsg, szBuf);

                strcat(szMsg, "\n\nDetails CLASSFIELDINFO:");

                strcat(szMsg, "\nSize of structure:        ");
                _wpQueryDetailsData(somSelf, NULL, &ulCFISize);
                UL2H(szBuf+2, ulCFISize);
                strcat(szMsg, szBuf);

                pCFI = (PCLASSFIELDINFO)_wpAllocMem(somSelf, ulCFISize, &ulErr);
                pCFI2 = pCFI;
                _wpQueryDetailsData(somSelf, (PVOID)&pCFI2, &ulCFISize);

                _wpFreeMem(somSelf, (PVOID)pCFI);

                winhDebugBox(szTitle, szMsg);

                brc = TRUE;
            break; }

            case ID_XFMI_SHOWFOLDERDATA:
            {
                xthrPostWorkerMsg(WM_SHOWFOLDERDATA,
                                  (MPARAM)somSelf,
                                  MPNULL);
                brc = TRUE;
            break; }
        #endif

        /*  V0.9.16 (2001-12-06) [umoeller]:
            disabled the following, or the shredder will delete
            into the trash can as well... sigh
        case WPMENUID_DELETE:
        {
            PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
            // this is never reached, because the subclassed folder
            // frame winproc already intercepts this

            if (    (cmnQuerySetting(sfTrashDelete))
                 && !_somIsA(somSelf, _WPTransient)  // V0.9.9 (2001-03-10) [pr]: fix print object delete
               )
            {

                cmnDeleteIntoDefTrashCan(somSelf);
                brc = TRUE;     // processed
            }
            else
                brc = XFldObject_parent_WPObject_wpMenuItemSelected(somSelf,
                                                                    hwndFrame,
                                                                    ulMenuId);
        break; }
        */

        case ID_WPM_LOCKINPLACE:    // V0.9.7 (2000-12-10) [umoeller]
        {
            // PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
            if (cmnQuerySetting(sfFixLockInPlace))
            {
                // we have replaced the "lock in place" submenu:
                // we must then intercept this menu item...
                ULONG ulStyle = _wpQueryStyle(somSelf);
                if ((ulStyle & OBJSTYLE_LOCKEDINPLACE) == 0)
                    ulStyle |= OBJSTYLE_LOCKEDINPLACE;
                else
                    ulStyle &= ~OBJSTYLE_LOCKEDINPLACE;
                _wpSetStyle(somSelf, ulStyle);
                _wpSaveDeferred(somSelf);
            }
        break; }

        default:
            fCallDefault = TRUE;
    }

    if (fCallDefault)
        brc = XFldObject_parent_WPObject_wpMenuItemSelected(somSelf,
                                                            hwndFrame,
                                                            ulMenuId);
    return (brc);
}

/*
 *@@ wpAddObjectGeneralPage:
 *      this WPObject instance method adds the "Icon"
 *      page to an object's settings notebook.
 *
 *      Starting with V0.9.16, we completely replace
 *      the "Icon" page to add support for object
 *      hotkeys and object details. The "Object"
 *      page is gone.
 *
 *@@added V0.9.1 (2000-02-17) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xfobj_wpAddObjectGeneralPage(XFldObject *somSelf,
                                                      HWND hwndNotebook)
{
    // PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpAddObjectGeneralPage");


#ifndef __ALWAYSREPLACEICONPAGE__
    if (    (cmnQuerySetting(sfReplaceIconPage))
            // check if this is a folder;
            // if so, XFolder will insert the page
            // because otherwise this would be between
            // the two "Icon" pages...
         // && (!_somIsA(somSelf, _WPFolder))
                // removed V0.9.16 (2001-10-15) [umoeller]
        )
#endif
    {
        PCREATENOTEBOOKPAGE pcnbp;

        pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
        memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));
        pcnbp->somSelf = somSelf;
        pcnbp->hwndNotebook = hwndNotebook;
        pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
        pcnbp->ulDlgID = ID_XFD_EMPTYDLG;
        pcnbp->ulPageID = SP_OBJECT_ICONPAGE1;
        pcnbp->usPageStyleFlags = BKA_MAJOR;
        pcnbp->fEnumerate = TRUE;
        pcnbp->pszName = cmnGetString(ID_XSSI_ICONPAGE);
                    // no new string needed, was defined for trash can already
        pcnbp->ulDefaultHelpPanel  = ID_XSH_OBJICONPAGE1;
        pcnbp->pfncbInitPage    = icoIcon1InitPage;
        pcnbp->pfncbItemChanged = icoIcon1ItemChanged;

        return (ntbInsertPage(pcnbp));
    }

#ifndef __ALWAYSREPLACEICONPAGE__
    return (XFldObject_parent_WPObject_wpAddObjectGeneralPage(somSelf,
                                                              hwndNotebook));
#endif
}

/*
 *@@ wpConfirmObjectTitle:
 *      this instance method is called by the WPS during file
 *      operations (copy, move, rename etc.) for every single
 *      object that is being processed. This method must verify
 *      that the operation is valid WRT name clashes and display
 *      a confirmation dialog in case it is not.
 *
 *      Apparently, this method is not overridden by subclasses,
 *      not even WPFileSystem -- except WPShadow, which forwards
 *      this method call to the linked object.
 *
 *      XWorkplace implements its own "Object exists" dialog here,
 *      if the Global Settings allow it.
 *
 *      Like most interesting methods in the WPS, this thing is
 *      barely documented, so this is what I found out.
 *
 *      Parameters:
 *      -- *somSelf      in: the object being worked on
 *      -- *Folder       in: the folder being worked on
 *      -- **ppDuplicate out: if we return NAMECLASH_REPLACE,
 *                            we need to set this to the object to
 *                            be replaced
 *      -- pszTitle      in: title of somSelf
 *                            out: if we return NAMECLASH_RENAME,
 *                            we need to set this to somSelf's new title
 *      -- cbTitle       in: sizeof(*pszTitle)
 *      -- menuID        in: the user's operation, which is:
 *                              0x0065    create another (WPMENUID_CREATEANOTHER)
 *                              0x006B    move (WPMENUID_MOVE)
 *                              0x006C    copy (WPMENUID_COPY)
 *                              0x006E    rename (no menu ID defined in wpobject.h)
 *                              0x013C    create shadow (WPMENUID_CREATESHADOW)
 *
 *      Returns:
 *      -- NAMECLASH_CANCEL (0):
 *                  abort processing, have the WPS do nothing ("Cancel"
 *                  button pressed in confirmation dialog); this will
 *                  just skip the current file;
 *      -- NAMECLASH_NONE (1):
 *                  continue processing, but perform no further
 *                  renaming etc.; we return this if no duplicate file
 *                  exists;
 *      -- NAMECLASH_RENAME (2):
 *                  have the WPS change the title to pszTitle, which we
 *                  need to set here; note that this does NOT change
 *                  the real name! So we do the renaming ourselves here;
 *      -- NAMECLASH_REPLACE (8):
 *                  have the WPS delete *ppDuplicate, which we need to
 *                  set here if we return this code; we need to find the
 *                  duplicate in this method then.
 *
 *      Note: these constants are only defined in the Warp 4 Toolkit
 *      (some of them in wpsystem.h in Warp 3 Toolkit also). So
 *      #include helpers/undoc.h, which defines these.
 *
 *@@changed V0.9.0 [umoeller]: fixed "create another" bug
 */

SOM_Scope ULONG  SOMLINK xfobj_wpConfirmObjectTitle(XFldObject *somSelf,
                                                    WPFolder* Folder,
                                                    WPObject** ppDuplicate,
                                                    PSZ pszTitle,
                                                    ULONG cbTitle,
                                                    ULONG menuID)
{
    ULONG ulrc = NAMECLASH_NONE;

    // PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();

    // XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpConfirmObjectTitle");

    #ifdef DEBUG_TITLECLASH
    {
        CHAR szFolder2[CCHMAXPATH];
        _Pmpf(("Entering wpConfirmObjectTitle"));
        _Pmpf(("  somSelf == 0x%lX", somSelf));
        _Pmpf(("    pszTitle: %s", pszTitle));
        _wpQueryFilename(_wpQueryFolder(somSelf), szFolder2, TRUE);
        _Pmpf(("    in folder: %s", szFolder2));
        _Pmpf(("  menuID: 0x%lX", menuID));
    }
    #endif

    // first of all, check whether the confirmation
    // dialogs have been replaced in the global settings;
#ifndef __ALWAYSREPLACEFILEEXISTS__
    if (cmnQuerySetting(sfReplaceFileExists))
    {
#endif
        // yes: use our replacement (fileops.c)
        ulrc = fopsConfirmObjectTitle(somSelf,
                                      Folder,
                                      ppDuplicate,
                                      pszTitle,
                                      cbTitle,
                                      menuID);
#ifndef __ALWAYSREPLACEFILEEXISTS__
    }
    else
    {
        // global settings do not allow dialog
        // replacement: call default
        #ifdef DEBUG_TITLECLASH
            _Pmpf(("  Calling original"));
        #endif
        ulrc = XFldObject_parent_WPObject_wpConfirmObjectTitle(somSelf,
                                                               Folder,
                                                               ppDuplicate,
                                                               pszTitle,
                                                               cbTitle,
                                                               menuID);
    }
#endif

    #ifdef DEBUG_TITLECLASH
    {
        CHAR szFolder2[CCHMAXPATH];
        _Pmpf(("  Return value: %d", ulrc));
        _Pmpf(("  New somSelf == 0x%lX", somSelf));
        _Pmpf(("    New pszTitle: %s", pszTitle));
        _wpQueryFilename(_wpQueryFolder(somSelf), szFolder2, TRUE);
        _Pmpf(("    in folder: %s", szFolder2));

        if (ppDuplicate) {
            _Pmpf(("  ppDuplicate neu != NULL"));
            if (*ppDuplicate) {
                _Pmpf(("    *ppDuplicate neu == 0x%lX", *ppDuplicate));
                _Pmpf(("      Title neu: %s", _wpQueryTitle(*ppDuplicate) ));
                _wpQueryFilename(_wpQueryFolder(*ppDuplicate), szFolder2, TRUE);
                _Pmpf(("      in folder: %s", szFolder2));
            }
        }
        _Pmpf(("Done."));
    }
    #endif

    return (ulrc);
}

/*
 *@@ wpCnrSetEmphasis:
 *      this WPObject method changes the emphasis flags of
 *      the object's MINIRECORDCORE (and updates all views
 *      where this object is inserted).
 *
 *      We override this method to be able to intercept the
 *      CRA_INUSE emphasis in case the object is currently
 *      used in an XCenter object button widget, which then
 *      needs to be repainted.
 *
 *      With V0.9.13, I tried overriding
 *      wpAddTo/DeleteFromObjectUseList, which didn't quite
 *      work.
 *
 *@@added V0.9.14 (2001-07-30) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobj_wpCnrSetEmphasis(XFldObject *somSelf,
                                               ULONG ulEmphasisAttr,
                                               BOOL fTurnOn)
{
    XFldObjectData *somThis = XFldObjectGetData(somSelf);
    XFldObjectMethodDebug("XFldObject","xfobj_wpCnrSetEmphasis");

    if (    (ulEmphasisAttr & CRA_INUSE)
         && (_pvllWidgetNotifies)
       )
    {
        // we have windows that requested notifications:
        // go thru list
        PLISTNODE pNode = lstQueryFirstNode(_pvllWidgetNotifies);
        while (pNode)
        {
            WinPostMsg((HWND)pNode->pItemData,
                       WM_CONTROL,
                       MPFROM2SHORT(ID_XCENTER_CLIENT,
                                    XN_INUSECHANGED),
                       (MPARAM)somSelf);
            pNode = pNode->pNext;
        }
    }

    return (XFldObject_parent_WPObject_wpCnrSetEmphasis(somSelf,
                                                        ulEmphasisAttr,
                                                        fTurnOn));
}


/* ******************************************************************
 *
 *   here come the XFldObject class methods
 *
 ********************************************************************/

/*
 * @@ xwpclsRemoveObjectHotkey:
 *      this removes the object hotkey for the
 *      given object. This extra function is
 *      necessary because if an object handle
 *      for an object with a hotkey gets lost
 *      (e.g. because the object was deleted),
 *      there's no way to invoke
 *      XFldObject::xwpSetObjectHotkey on it.
 *
 *@@added V0.9.0 (99-11-12) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobjM_xwpclsRemoveObjectHotkey(M_XFldObject *somSelf,
                                                        HOBJECT hobj)
{
    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    M_XFldObjectMethodDebug("M_XFldObject","xfobjM_xwpclsRemoveObjectHotkey");

    return (objRemoveObjectHotkey(hobj));
}

/*
 *@@ wpclsInitData:
 *      this WPObject class method gets called when a class
 *      is loaded by the WPS (probably from within a
 *      somFindClass call) and allows the class to initialize
 *      itself.
 *
 *      We override this for XFldObject to initialize
 *      XWorkplace altogether.
 *
 *      This is probably the first WPS method called on the
 *      system (for M_WPObject, that is), so we use this
 *      to set up some stuff, most notably, start the
 *      additional XWorkplace threads by calling
 *      initMain, which handles the details.
 *
 *      The beautiful thing is that at this point we appear
 *      to own the computer all alone. It seems that no
 *      additional WPS threads are running _yet_ (or if they
 *      are, they don't care), so we can halt the system,
 *      display graphics, overwrite the master boot record,
 *      whatever. (JUST KIDDING.)
 *
 *@@changed V0.9.0 [umoeller]: added class object to KERNELGLOBALS
 */

SOM_Scope void  SOMLINK xfobjM_wpclsInitData(M_XFldObject *somSelf)
{
    BOOL    fOpenFoldersFound = FALSE;
    // // PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
                        // this will load the global settings from OS2.INI

    // M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf);
    // M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsInitData");
    #ifdef DEBUG_SOMMETHODS
        _Pmpf((__FUNCTION__ " for class %s",
                    _somGetName(somSelf) ));
    #endif

    M_XFldObject_parent_M_WPObject_wpclsInitData(somSelf);

    // since this code is reached for every single WPS class
    // that gets initialized, we need to check if we're being
    // called for the first time
    if (!G_fXWorkplaceInitialized)
    {
        HENUM   henum;
        HWND    hwndThis;

        G_fXWorkplaceInitialized = TRUE;

        // check if we have any open folder windows;
        // if so, we're not really in the process of starting
        // up. This check is necessary because this class
        // method also gets called when the classes are installed
        // by WinRegisterObjectClass, unfortunately, and we don't
        // want to start threads etc. then.
        henum = WinBeginEnumWindows(HWND_DESKTOP);
        while (     (!fOpenFoldersFound)
                 && (hwndThis = WinGetNextWindow(henum))
              )
        {
            CHAR    szClass[200];
            if (WinQueryClassName(hwndThis, sizeof(szClass), szClass))
                if (!strcmp(szClass, "wpFolder window"))
                    // folder window:
                    fOpenFoldersFound = TRUE;
        }
        WinEndEnumWindows(henum);

        if (!fOpenFoldersFound)
        {
            _Pmpf((__FUNCTION__ ": initializing class %s",
                   _somGetName(somSelf)));

            // only if no open folders are found:
            // initialize the kernel (kernel.c)
            initMain();
        }

        krnClassInitialized(G_pcszXFldObject);
    }

#ifndef __NOBOOTUPSTATUS__
    if (!fOpenFoldersFound)
    {
        // PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
        // even if not first invocation (i.e. some class other
        // than WPObject gets initialized): notify Speedy thread
        // of class initialization
        if (cmnQuerySetting(sfShowBootupStatus))
            xthrPostSpeedyMsg(QM_BOOTUPSTATUS,
                              (MPARAM)somSelf,       // class object
                              MPNULL);
    }
#endif
}

/*
 *@@ wpclsQuerySettingsPageSize:
 *      this WPObject class method should return the
 *      size of the largest settings page in dialog
 *      units; if a settings notebook is initially
 *      opened, i.e. no window pos has been stored
 *      yet, the WPS will use this size, to avoid
 *      truncated settings pages.
 *
 *      Since the "Object" page is pretty large,
 *      we return this.
 *
 *@@added V0.9.2 (2000-03-08) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobjM_wpclsQuerySettingsPageSize(M_XFldObject *somSelf,
                                                          PSIZEL pSizl)
{
    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsQuerySettingsPageSize");

    /* return (M_XFldObject_parent_M_WPObject_wpclsQuerySettingsPageSize(somSelf,
                                                                      pSizl)); */
    pSizl->cx = 275;       // size of "Object" page
    pSizl->cy = 150;       // size of "Object" page

    return (TRUE);
}

/*
 *@@ wpclsSetIconData:
 *      this WPObject class method sets the icon information
 *      for the given class object.
 *
 *      Doesn't make much sense? Welcome to the club. See
 *      icons.c for an introduction to the WPS icon mess.
 *
 *      What I found out is that when the WPS calls
 *      M_WPObject::wpclsQueryIcon to get the default icon of
 *      an object's class (because an object is not using a
 *      custom icon), the icon only gets loaded once. On the
 *      first call _per class_, the WPS then calls
 *      wpclsQueryIconData (which is the method to be overridden
 *      to change the class default icon) and then this method,
 *      wpclsSetIconData, to have the class icon set. For that,
 *      wpclsSetIconData calls wpclsSetIcon to set the _class_
 *      icon handle, which is then returned in subsequent calls
 *      to wpclsQueryIcon.
 *
 *      The problem with this method (wpclsSetIconData) is
 *      that it doesn't support the ICON_FILE format in
 *      ICONINFO. So in order to support ICON_FILE, which
 *      would be handy with the way cmnGetStandardIcon
 *      works, we have to override this method too.
 *
 *@@added V0.9.16 (2002-01-13) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfobjM_wpclsSetIconData(M_XFldObject *somSelf,
                                                PICONINFO pIconInfo)
{
    BOOL brc = FALSE;
    BOOL fCallDefault = TRUE;

    /* M_XFldObjectData *somThis = M_XFldObjectGetData(somSelf); */
    M_XFldObjectMethodDebug("M_XFldObject","xfobjM_wpclsSetIconData");

#ifndef __NOICONREPLACEMENTS__
    // if icon replacements are enabled, we support ICON_FILE
    // too; for all other cases, call the parent method
    if (cmnQuerySetting(sfIconReplacements))
    {
        _Pmpf((__FUNCTION__ ", class %s, format %s",
                _somGetName(somSelf),
                (pIconInfo)
                    ? ((pIconInfo->fFormat == ICON_FILE) ? "FILE"
                        : (pIconInfo->fFormat == ICON_RESOURCE) ? "RESOURCE"
                        : "UNKNOWN"  )
                    : "NULL"));
        if ((pIconInfo) && (pIconInfo->fFormat == ICON_FILE))
        {
            HPOINTER hptr;

            fCallDefault = FALSE;

            _Pmpf(("        pIconInfo->pszFileName %s", pIconInfo->pszFileName));

            if (!icoLoadICOFile(pIconInfo->pszFileName,
                                &hptr,
                                NULL,
                                NULL))
            {
                brc = _wpclsSetIcon(somSelf, hptr);
            }
        }
    }
#endif

    if (fCallDefault)
        brc = M_XFldObject_parent_M_WPObject_wpclsSetIconData(somSelf,
                                                              pIconInfo);

    return (brc);
}

