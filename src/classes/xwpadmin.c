
/*
 *@@sourcefile xwpadmin.c:
 *      This file contains SOM code for the following XWorkplace classes:
 *
 *      --  XWPAdmin ("XWorkplace Administrator" object, WPAbstract subclass)
 *
 *      This class implements the "XWorkplace Administrator"
 *      setting object, in which administrators may configure XWPShell.
 *
 *@@added V0.9.9 (2001-02-08) [umoeller]
 *@@somclass XWPAdmin adm_
 *@@somclass M_XWPAdmin admM_
 */

/*
 *      Copyright (C) 2001-2002 Ulrich M”ller.
 *      This file is part of the XWorkplace source package.
 *      XWorkplace is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published
 *      by the Free Software Foundation, in version 2 as it comes in the
 *      "COPYING" file of the XWorkplace main distribution.
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitctm: 2.41
 */

#ifndef SOM_Module_xwpadmin_Source
#define SOM_Module_xwpadmin_Source
#endif
#define XWPAdmin_Class_Source
#define M_XWPAdmin_Class_Source

#pragma strings(readonly)

/*
 *  Suggested #include order:
 *  1)  os2.h
 *  2)  C library headers
 *  3)  setup.h (code generation and debugging options)
 *  4)  headers in helpers\
 *  5)  at least one SOM implementation header (*.ih)
 *  6)  dlgids.h, headers in shared\ (as needed)
 *  7)  headers in implementation dirs (e.g. filesys\, as needed)
 *  8)  #pragma hdrstop and then more SOM headers which crash with precompiled headers
 */

#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSQUEUES
#define INCL_DOSMODULEMGR
#define INCL_DOSERRORS
#include <os2.h>

// C library headers
#include <stdio.h>

// generic headers
#include "setup.h"                      // code generation and debugging options

// headers in /helpers

// SOM headers which don't crash with prec. header files
#include "xwpadmin.ih"

// XWorkplace implementation headers
#include "dlgids.h"                     // all the IDs that are shared with NLS
#include "shared\common.h"              // the majestic XWorkplace include file
#include "shared\helppanels.h"          // all XWorkplace help panel IDs
#include "shared\kernel.h"              // XWorkplace Kernel
#include "shared\notebook.h"            // generic XWorkplace notebook handling
#include "shared\xsetup.h"              // XWPSetup implementation

#include "security\xwpsecty.h"          // XWorkplace Security

// other SOM headers
#pragma hdrstop

/* ******************************************************************
 *
 *   XWPShell security APIs
 *
 ********************************************************************/

/*
 *@@ XWPSHELLCOMMAND:
 *
 *@@added V0.9.11 (2001-04-22) [umoeller]
 */

typedef struct _XWPSHELLCOMMAND
{
    PXWPSHELLQUEUEDATA  pShared;
    PID                 pidXWPShell;
    HQUEUE              hqXWPShell;
} XWPSHELLCOMMAND, *PXWPSHELLCOMMAND;

VOID FreeXWPShellCommand(PXWPSHELLCOMMAND pCommand);

/*
 *@@ CreateXWPShellCommand:
 *      creates a command for XWPShell to process.
 *
 *      See XWPSHELLQUEUEDATA for a description of
 *      what's going on here.
 *
 *      ulCommand must be one of QUECMD_* values.
 *
 *      If this returns NO_ERROR, the caller must
 *      then fill in the shared data according to
 *      what the command requires and use
 *      SendXWPShellCommand then.
 *
 *      Among others, this can return:
 *
 *      --  ERROR_NOT_ENOUGH_MEMORY
 *
 *      --  ERROR_QUE_NAME_NOT_EXIST (343): XWPShell queue
 *          not found, XWPShell is probably not running.
 *
 *@@added V0.9.11 (2001-04-22) [umoeller]
 */

APIRET CreateXWPShellCommand(ULONG ulCommand,               // in: command
                             PXWPSHELLCOMMAND *ppCommand)   // out: cmd structure if NO_ERROR is returned
{
    APIRET      arc = NO_ERROR;

    PXWPSHELLCOMMAND pCommand = (PXWPSHELLCOMMAND)malloc(sizeof(XWPSHELLCOMMAND));
    if (!pCommand)
        arc = ERROR_NOT_ENOUGH_MEMORY;
    else
    {
        memset(pCommand, 0, sizeof(*pCommand));

        // check if XWPShell is running; if so the queue must exist
        if (!(arc = DosOpenQueue(&pCommand->pidXWPShell,
                                 &pCommand->hqXWPShell,
                                 QUEUE_XWPSHELL)))
        {
            if (!(arc = DosAllocSharedMem((PVOID*)&pCommand->pShared,
                                          NULL,     // unnamed
                                          sizeof(XWPSHELLQUEUEDATA),
                                          PAG_COMMIT | OBJ_GIVEABLE | PAG_READ | PAG_WRITE)))
            {
                PXWPSHELLQUEUEDATA pShared = pCommand->pShared;

                if (    (!(arc = DosGiveSharedMem(pShared,
                                                  pCommand->pidXWPShell,
                                                  PAG_READ | PAG_WRITE)))
                     && (!(arc = DosCreateEventSem(NULL,
                                                   &pShared->hevData,
                                                   DC_SEM_SHARED,
                                                   FALSE)))      // reset
                   )
                {
                    pShared->ulCommand = ulCommand;
                }
            }
        }

        if (!arc)
            *ppCommand = pCommand;
        else
            FreeXWPShellCommand(pCommand);
    }

    return (arc);
}

/*
 *@@ SendXWPShellCommand:
 *      sends a command to XWPShell and waits for
 *      the command to be processed.
 *
 *      This will wait a maximum of five seconds
 *      and return 640 (ERROR_TIMEOUT) if XWPShell
 *      didn't manage to respond in that time.
 *
 *      In addition to standard OS/2 error codes,
 *      this may return XWPShell error codes
 *      depending on the command that was sent.
 *      See XWPSHELLQUEUEDATA for commands and
 *      their possible return values.
 *
 *      If XWPSEC_QUEUE_INVALID_CMD is returned,
 *      you have specified an invalid command code.
 *
 *      Be warned, this blocks the calling thread.
 *      Even though XWPShell should be following
 *      the PM 0.1 seconds rule, you might want
 *      to start a second thread for this.
 *
 *@@added V0.9.11 (2001-04-22) [umoeller]
 */

APIRET SendXWPShellCommand(PXWPSHELLCOMMAND pCommand)
{
    APIRET arc = NO_ERROR;

    if (!pCommand)
        arc = ERROR_INVALID_PARAMETER;
    else
    {
        if (!(arc = DosWriteQueue(pCommand->hqXWPShell,
                                  (ULONG)pCommand->pShared,   // request data
                                  0,
                                  NULL,
                                  0)))              // priority
        {
            // wait 5 seconds for XWPShell to write the data
            if (!(arc = DosWaitEventSem(pCommand->pShared->hevData,
                                        5*1000)))
            {
                // check if XWPShell reported error
                arc = pCommand->pShared->arc;
            }
        }
    }

    return (arc);
}

/*
 *@@ FreeXWPShellCommand:
 *      cleans up.
 *
 *@@added V0.9.11 (2001-04-22) [umoeller]
 */

VOID FreeXWPShellCommand(PXWPSHELLCOMMAND pCommand)
{
    if (pCommand)
    {
        if (pCommand->pShared)
        {
            if (pCommand->pShared->hevData)
                DosCloseEventSem(pCommand->pShared->hevData);

            DosFreeMem(pCommand->pShared);
        }

        if (pCommand->hqXWPShell)
            DosCloseQueue(pCommand->hqXWPShell);

        free(pCommand);
    }
}

/*
 *@@ xsecQueryLocalLoggedOn:
 *      returns the user who's currently logged
 *      on locally.
 *
 *      Required authority: None.
 *
 *      Among others, this can return:
 *
 *      --  ERROR_NOT_ENOUGH_MEMORY
 *
 *      --  ERROR_QUE_NAME_NOT_EXIST (343): XWPShell queue
 *          not found, XWPShell is probably not running.
 *
 *      --  XWPSEC_NO_LOCAL_USER: no user is currently
 *          logged on locally (XWPShell is probably
 *          displaying logon dialog).
 *
 *@@added V0.9.11 (2001-04-22) [umoeller]
 */

APIRET xsecQueryLocalLoggedOn(PXWPLOGGEDON pLoggedOn)
{
    APIRET              arc = NO_ERROR;
    PXWPSHELLCOMMAND    pCommand;

    if (!(arc = CreateXWPShellCommand(QUECMD_LOCALLOGGEDON,
                                      &pCommand)))
    {
        if (!(arc = SendXWPShellCommand(pCommand)))
        {
            // alright:
            // copy output
            memcpy(pLoggedOn,
                   &pCommand->pShared->Data.LoggedOn,      // union member
                   sizeof(XWPLOGGEDON));
        }

        FreeXWPShellCommand(pCommand);
    }

    return (arc);
}

/* ******************************************************************
 *
 *   XWPAdmin implementation
 *
 ********************************************************************/

VOID admUserInitPage(PCREATENOTEBOOKPAGE pcnbp,   // notebook info struct
                     ULONG flFlags)        // CBI_* flags (notebook.h)
{
    if (flFlags & CBI_INIT)
    {
        APIRET arc = NO_ERROR;
        XWPLOGGEDON LoggedOn;

        if (arc = xsecQueryLocalLoggedOn(&LoggedOn))
        {
            // error:
            CHAR szError[100];
            sprintf(szError, "Error %d", arc);
            WinSetDlgItemText(pcnbp->hwndDlgPage,
                              ID_AMDI_USER_USERNAME,
                              szError);
        }
        else
        {
            WinSetDlgItemText(pcnbp->hwndDlgPage,
                              ID_AMDI_USER_USERNAME,
                              LoggedOn.szUserName);
            WinSetDlgItemShort(pcnbp->hwndDlgPage,
                               ID_AMDI_USER_USERID,
                               LoggedOn.uid,
                               FALSE);          // unsigned
            WinSetDlgItemText(pcnbp->hwndDlgPage,
                              ID_AMDI_USER_GROUPNAME,
                              LoggedOn.szGroupName);
            WinSetDlgItemShort(pcnbp->hwndDlgPage,
                               ID_AMDI_USER_GROUPID,
                               LoggedOn.gid,
                               FALSE);          // unsigned
        }
    }
}

/* ******************************************************************
 *
 *   XWPAdmin instance methods
 *
 ********************************************************************/

/*
 *@@ xwpAddXWPAdminPages:
 *      this actually adds the new pages into the
 *      "XWorkplace Administrator" notebook.
 */

SOM_Scope ULONG  SOMLINK adm_xwpAddXWPAdminPages(XWPAdmin *somSelf,
                                                 HWND hwndDlg)
{
    ULONG   ulrc;
    PCREATENOTEBOOKPAGE pcnbp;
    HMODULE             savehmod = cmnQueryNLSModuleHandle(FALSE);
    PID                 pidXWPShell;
    HQUEUE              hqXWPShell;

    /* XWPAdminData *somThis = XWPAdminGetData(somSelf); */
    XWPAdminMethodDebug("XWPAdmin","adm_xwpAddXWPAdminPages");

    pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
    memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));
    pcnbp->somSelf = somSelf;
    pcnbp->hwndNotebook = hwndDlg;
    pcnbp->hmod = savehmod;

    // check if XWPShell is running; if so the queue must exist
    if (DosOpenQueue(&pidXWPShell,
                     &hqXWPShell,
                     QUEUE_XWPSHELL))
    {
        // error: display XWP page only then
        pcnbp->usPageStyleFlags = BKA_MAJOR;
        pcnbp->pszName = "XWorkplace";
        pcnbp->ulDlgID = ID_XCD_FIRST;
        pcnbp->ulPageID = SP_SETUP_XWPLOGO;
        pcnbp->pfncbInitPage    = setLogoInitPage;
        pcnbp->pfncbMessage = setLogoMessages;
        ulrc = ntbInsertPage(pcnbp);
    }
    else
    {
        // XWPShell running:
        DosCloseQueue(hqXWPShell);

        pcnbp->ulDlgID = ID_AMD_USER;
        pcnbp->usPageStyleFlags = BKA_MAJOR;
        pcnbp->pszName = cmnGetString(ID_XSSI_ADMIN_USER);
        pcnbp->ulDefaultHelpPanel  = ID_XSH_ADMIN_USER;
        pcnbp->ulPageID = SP_ADMIN_USER;
        pcnbp->pfncbInitPage    = admUserInitPage;
        ulrc = ntbInsertPage(pcnbp);
    }

    return ulrc;
}

/*
 *@@ wpFilterPopupMenu:
 *      this WPObject instance method allows the object to
 *      filter out unwanted menu items from the context menu.
 *      This gets called before wpModifyPopupMenu.
 */

SOM_Scope ULONG  SOMLINK adm_wpFilterPopupMenu(XWPAdmin *somSelf,
                                               ULONG ulFlags,
                                               HWND hwndCnr,
                                               BOOL fMultiSelect)
{
    /* XWPAdminData *somThis = XWPAdminGetData(somSelf); */
    XWPAdminMethodDebug("XWPAdmin","adm_wpFilterPopupMenu");

    return (XWPAdmin_parent_WPAbstract_wpFilterPopupMenu(somSelf,
                                                         ulFlags,
                                                         hwndCnr,
                                                         fMultiSelect)
            & ~CTXT_NEW
           );
}

/*
 *@@ wpQueryDefaultHelp:
 *      this WPObject instance method specifies the default
 *      help panel for an object (when "Extended help" is
 *      selected from the object's context menu). This should
 *      describe what this object can do in general.
 *      We must return TRUE to report successful completion.
 */

SOM_Scope BOOL  SOMLINK adm_wpQueryDefaultHelp(XWPAdmin *somSelf,
                                               PULONG pHelpPanelId,
                                               PSZ HelpLibrary)
{
    /* XWPAdminData *somThis = XWPAdminGetData(somSelf); */
    XWPAdminMethodDebug("XWPAdmin","adm_wpQueryDefaultHelp");

    return (XWPAdmin_parent_WPAbstract_wpQueryDefaultHelp(somSelf,
                                                          pHelpPanelId,
                                                          HelpLibrary));
}

/*
 *@@ wpQueryDefaultView:
 *      this WPObject method returns the default view of an object,
 *      that is, which view is opened if the program file is
 *      double-clicked upon. This is also used to mark
 *      the default view in the "Open" context submenu.
 *
 *      This must be overridden for direct WPAbstract subclasses,
 *      because otherwise double-clicks on the object won't
 *      work.
 */

SOM_Scope ULONG  SOMLINK adm_wpQueryDefaultView(XWPAdmin *somSelf)
{
    /* XWPAdminData *somThis = XWPAdminGetData(somSelf); */
    XWPAdminMethodDebug("XWPAdmin","adm_wpQueryDefaultView");

    return (OPEN_SETTINGS);     // settings view is default
}

/*
 *@@ wpAddObjectWindowPage:
 *      this WPObject instance method normally adds the
 *      "Standard Options" page to the settings notebook
 *      (that's what the WPS reference calls it; it's actually
 *      the "Window" page).
 *
 *      We don't want that page here, so we remove it.
 */

SOM_Scope ULONG  SOMLINK adm_wpAddObjectWindowPage(XWPAdmin *somSelf,
                                                   HWND hwndNotebook)
{
    /* XWPAdminData *somThis = XWPAdminGetData(somSelf); */
    XWPAdminMethodDebug("XWPAdmin","adm_wpAddObjectWindowPage");

    return (SETTINGS_PAGE_REMOVED);
}

/*
 *@@ wpAddSettingsPages:
 *      this WPObject instance method gets called by the WPS
 *      when the Settings view is opened to have all the
 *      settings page inserted into hwndNotebook.
 *
 *      We add the various new pages here.
 */

SOM_Scope BOOL  SOMLINK adm_wpAddSettingsPages(XWPAdmin *somSelf,
                                               HWND hwndNotebook)
{
    /* XWPAdminData *somThis = XWPAdminGetData(somSelf); */
    XWPAdminMethodDebug("XWPAdmin","adm_wpAddSettingsPages");

    XWPAdmin_parent_WPAbstract_wpAddSettingsPages(somSelf,
                                                  hwndNotebook);

    // add XWorkplace pages on top
    _xwpAddXWPAdminPages(somSelf, hwndNotebook);

    return (TRUE);
}

/* ******************************************************************
 *
 *   XWPAdmin instance methods
 *
 ********************************************************************/

/*
 *@@ wpclsInitData:
 *      this WPObject class method gets called when a class
 *      is loaded by the WPS (probably from within a
 *      somFindClass call) and allows the class to initialize
 *      itself.
 */

SOM_Scope void  SOMLINK admM_wpclsInitData(M_XWPAdmin *somSelf)
{
    /* M_XWPAdminData *somThis = M_XWPAdminGetData(somSelf); */
    M_XWPAdminMethodDebug("M_XWPAdmin","admM_wpclsInitData");

    M_XWPAdmin_parent_M_WPAbstract_wpclsInitData(somSelf);
}

/*
 * wpclsQueryStyle:
 *      prevent copy, delete, print.
 *
 *@@changed V0.9.16 (2001-11-25) [umoeller]: added nevertemplate
 */

SOM_Scope ULONG  SOMLINK admM_wpclsQueryStyle(M_XWPAdmin *somSelf)
{
    /* M_XWPAdminData *somThis = M_XWPAdminGetData(somSelf); */
    M_XWPAdminMethodDebug("M_XWPAdmin","admM_wpclsQueryStyle");

    return (M_XWPAdmin_parent_M_WPAbstract_wpclsQueryStyle(somSelf)
                | CLSSTYLE_NEVERTEMPLATE        // V0.9.16 (2001-11-25) [umoeller]
                | CLSSTYLE_NEVERPRINT
                | CLSSTYLE_NEVERCOPY
                | CLSSTYLE_NEVERDELETE);
}

/*
 *@@ wpclsQueryTitle:
 *      this WPObject class method tells the WPS the clear
 *      name of a class, which is shown in the third column
 *      of a Details view and also used as the default title
 *      for new objects of a class.
 */

SOM_Scope PSZ  SOMLINK admM_wpclsQueryTitle(M_XWPAdmin *somSelf)
{
    // PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    /* M_XWPAdminData *somThis = M_XWPAdminGetData(somSelf); */
    M_XWPAdminMethodDebug("M_XWPAdmin","admM_wpclsQueryTitle");

    return (cmnGetString(ID_XSSI_ADMINISTRATOR)) ; // pszAdministrator
}

/*
 *@@ wpclsQueryIconData:
 *      this WPObject class method builds the default
 *      icon for objects of a class (i.e. the icon which
 *      is shown if no instance icon is assigned). This
 *      apparently gets called from some of the other
 *      icon instance methods if no instance icon was
 *      found for an object. The exact mechanism of how
 *      this works is not documented.
 *
 *      We override this to give XWPAdmin objects a new
 *      icon (src\shared\xwpsetup.ico).
 */

SOM_Scope ULONG  SOMLINK admM_wpclsQueryIconData(M_XWPAdmin *somSelf,
                                                 PICONINFO pIconInfo)
{
    /* M_XWPAdminData *somThis = M_XWPAdminGetData(somSelf); */
    M_XWPAdminMethodDebug("M_XWPAdmin","admM_wpclsQueryIconData");

    if (pIconInfo)
    {
        pIconInfo->fFormat = ICON_RESOURCE;
        pIconInfo->resid   = ID_ICONXWPADMIN;
        pIconInfo->hmod    = cmnQueryMainResModuleHandle();
    }

    return (sizeof(ICONINFO));
}

/*
 *@@ wpclsQuerySettingsPageSize:
 *      this WPObject class method should return the
 *      size of the largest settings page in dialog
 *      units; if a settings notebook is initially
 *      opened, i.e. no window pos has been stored
 *      yet, the WPS will use this size, to avoid
 *      truncated settings pages.
 */

SOM_Scope BOOL  SOMLINK admM_wpclsQuerySettingsPageSize(M_XWPAdmin *somSelf,
                                                        PSIZEL pSizl)
{
    /* M_XWPAdminData *somThis = M_XWPAdminGetData(somSelf); */
    M_XWPAdminMethodDebug("M_XWPAdmin","admM_wpclsQuerySettingsPageSize");

    return (M_XWPAdmin_parent_M_WPAbstract_wpclsQuerySettingsPageSize(somSelf,
                                                                      pSizl));
}

