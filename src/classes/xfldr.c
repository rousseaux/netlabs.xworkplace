
/*
 *@@sourcefile xfldr.c:
 *      This file contains SOM code for the following XWorkplace classes:
 *
 *      --  XFolder class (WPFolder replacement)
 *
 *      XFolder is probably the most complex class of this
 *      package. The main functionalities of XFolder are
 *      hooked into the WPS thru the following method
 *      overrides:
 *
 *      -- XFolder::wpModifyPopupMenu adds all the XFolder menu items
 *         to folder context menus. This calls code in
 *         src/filesys/fdrmenus.c which is shared with XFldDisk,
 *         because both classes largely do the same thing.
 *
 *      -- XFolder::wpOpen calls fdrManipulateNewView, which
 *         subclasses a newly opened folder view frame window
 *         with fdr_fnwpSubclassedFolderFrame -- one of the most
 *         complex parts of XWorkplace.
 *         This window procedure intercepts lots of messages
 *         which are needed for the more advanced features.
 *         See src\filesys\fdrsubclass.c for an introduction.
 *
 *         The subclassed folder frame window procedure also
 *         handles WM_COMMAND messages directly to start the
 *         enhanced XWorkplace file operations, such as moving
 *         files to the XWorkplace trash can.
 *
 *      -- Extended folder sorting is mostly implemented thru
 *         fdr_fnwpSubclassedFolderFrame as well.
 *
 *      -- Lots of wpAdd* settings pages overrides to replace
 *         XFolder settings pages.
 *
 *      Installation of XFolder is now optional (V0.9.0).
 *      However, if any of XFldDisk, XFldStartup, or XFldShutdown are
 *      installed, XFolder must also be installed.
 *
 *      Starting with V0.9.0, the files in classes\ contain only
 *      the SOM interface, i.e. the methods themselves.
 *      The implementation for this class is mostly in filesys\folder.c,
 *      filesys\fdrhotky.c, and filesys\filesys.c.
 *
 *@@somclass XFolder xf_
 *@@somclass M_XFolder xfM_
 *
 *@@changed V0.9.0 [umoeller]: override of wpclsQueryTitle removed
 */

/*
 *      Copyright (C) 1997-2000 Ulrich M”ller.
 *      This file is part of the XWorkplace source package.
 *      XWorkplace is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published
 *      by the Free Software Foundation, in version 2 as it comes in the
 *      "COPYING" file of the XWorkplace main distribution.
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

/*
 *@@todo:
 *
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitctm: 2.41
 */

#ifndef SOM_Module_xfldr_Source
#define SOM_Module_xfldr_Source
#endif
#define XFolder_Class_Source
#define M_XFolder_Class_Source

/*
 *  Suggested #include order:
 *  1)  os2.h
 *  2)  C library headers
 *  3)  setup.h (code generation and debugging options)
 *  4)  headers in helpers\
 *  5)  at least one SOM implementation header (*.ih)
 *  6)  dlgids.h, headers in shared\ (as needed)
 *  7)  headers in implementation dirs (e.g. filesys\, as needed)
 *  8)  #pragma hdrstop and then more SOM headers which crash with precompiled headers
 */

#define INCL_DOSEXCEPTIONS
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSERRORS
#define INCL_WINWINDOWMGR
#define INCL_WINFRAMEMGR
#define INCL_WININPUT
#define INCL_WINRECTANGLES
#define INCL_WINSYS             // needed for presparams
#define INCL_WINMENUS
#define INCL_WINTIMER
#define INCL_WINDIALOGS
#define INCL_WINBUTTONS
#define INCL_WINENTRYFIELDS
#define INCL_WINLISTBOXES
#define INCL_WINSTDCNR
#define INCL_WINSHELLDATA       // Prf* functions
#define INCL_WINHOOKS
#include <os2.h>

// C library headers
#include <stdio.h>              // needed for except.h
#include <setjmp.h>             // needed for except.h

// generic headers
#include "setup.h"                      // code generation and debugging options

// headers in /helpers
#include "helpers\cnrh.h"               // container helper routines
#include "helpers\dosh.h"               // Control Program helper routines
#include "helpers\eah.h"                // extended attributes helper routines
#include "helpers\except.h"             // exception handling
#include "helpers\linklist.h"           // linked list helper routines
#include "helpers\prfh.h"               // INI file helper routines
#include "helpers\stringh.h"            // string helper routines
#include "helpers\winh.h"               // PM helper routines
#include "helpers\wphandle.h"           // Henk Kelder's HOBJECT handling

// SOM headers which don't crash with prec. header files
#include "xfldr.ih"

// XWorkplace implementation headers
#include "dlgids.h"                     // all the IDs that are shared with NLS
#include "shared\cnrsort.h"             // container sort comparison functions
#include "shared\common.h"              // the majestic XWorkplace include file
#include "shared\kernel.h"              // XWorkplace Kernel
#include "shared\notebook.h"            // generic XWorkplace notebook handling
#include "shared\wpsh.h"                // some pseudo-SOM functions (WPS helper routines)

#include "filesys\filesys.h"            // various file-system object implementation code
#include "filesys\folder.h"             // XFolder implementation
#include "filesys\fdrmenus.h"           // shared folder menu logic
#include "filesys\object.h"             // XFldObject implementation
#include "filesys\statbars.h"           // status bar translation logic
#include "filesys\xthreads.h"           // extra XWorkplace threads

// other SOM headers
#pragma hdrstop                         // VAC++ keeps crashing otherwise

#include <wprootf.h>                    // WPRootFolder
#include <wpshadow.h>                   // WPShadow
#include <wpdesk.h>                     // WPDesktop
#include "xfobj.h"                      // XFldObject
#include "xfdisk.h"                     // XFldDisk

/* ******************************************************************
 *                                                                  *
 *   Global variables                                               *
 *                                                                  *
 ********************************************************************/

static XFolder      *G_pConfigFolder = NULL;

// "XFolder" key for wpRestoreData etc.
static const char*  G_pcszXFolder = "XFolder";

// roots of linked lists for favorite/quick-open folders
// these hold plain WPObject pointers, no auto-free
PLINKLIST           G_pllFavoriteFolders = NULL,
                    G_pllQuickOpenFolders = NULL;
                            // these two are exported in folder.h

/* ******************************************************************
 *                                                                  *
 *   here come the XFolder instance methods                         *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpQueryFldrSort:
 *      this returns the folder's sort settings into the specified
 *      USHORT variables. These are set to SET_DEFAULT if no instance
 *      data has been defined; you will then need to query the
 *      GLOBALSETTINGS values.
 *
 *      See XFolder::xwpSortViewOnce for the values of pusDefaultSort.
 */

SOM_Scope BOOL  SOMLINK xf_xwpQueryFldrSort(XFolder *somSelf,
                                            PUSHORT pusDefaultSort,
                                            PUSHORT pusAlwaysSort)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpQueryFldrSort");

    if ((pusDefaultSort) && (pusAlwaysSort))
    {
        *pusDefaultSort = (USHORT)_bDefaultSort;
        *pusAlwaysSort  = (USHORT)_bAlwaysSort;
        return (TRUE);
    }
    else
        return (FALSE);
}

/*
 *@@ xwpSetFldrSort:
 *      this is the new XFolder method for setting the sort data
 *      for a certain folder.
 *
 *      usDefaultSort should be one of the SV_ constants as in
 *      XFolder::xwpSortViewOnce or SET_DEFAULT for resetting the folder's
 *      default sort criterion to the Global Settings's value.
 *
 *      usAlwaysSort can be 0 or 1 or SET_DEFAULT also.
 *
 *      This method updates all open folder views with the new
 *      sort settings.
 *
 *      This method returns TRUE if any visible change occured as
 *      a result to the new settings.
 *
 *@@changed V0.9.2 (2000-03-08) [umoeller]: added folder locking
 */

SOM_Scope BOOL  SOMLINK xf_xwpSetFldrSort(XFolder *somSelf,
                                          USHORT usDefaultSort,
                                          USHORT usAlwaysSort)
{
    BOOL        Update = FALSE;
    XFolderData *somThis = XFolderGetData(somSelf);

    WPSHLOCKSTRUCT Lock;

    #ifdef DEBUG_SORT
        _Pmpf((__FUNCTION__ " for %s", _wpQueryTitle(somSelf)));
        _Pmpf(("  Old: Default %d, Always %d", _bDefaultSort, _bAlwaysSort));
        _Pmpf(("  New: Default %d, Always %d", usDefaultSort, usAlwaysSort));
    #endif

    if (wpshLockObject(&Lock, somSelf))
    {
        PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
        XFolderMethodDebug("XFolder","xf_xwpSetFldrSort");

        if (usDefaultSort != _bDefaultSort)
        {
            _bDefaultSort = usDefaultSort;
            Update = TRUE;
        }

        if (usAlwaysSort != _bAlwaysSort)
        {
            _bAlwaysSort = usAlwaysSort;
            // if _wpRestoreState has found the pointer to the
            // WPFOlder-internal sort structure, we will update
            // this one also, because otherwise the WPS keeps
            // messing with the container attributes;
            // but make sure the folder is not being copied right now
            /* if (_wpIsObjectInitialized(somSelf)) // V0.9.3 (2000-04-29) [umoeller]
                if (_pFolderSortInfo)
                    (_pFolderSortInfo)->fAlwaysSort = ALWAYS_SORT; */
            Update = TRUE;
        }
    } // end if (fFolderLocked)

    wpshUnlockObject(&Lock);

    if (Update)
    {
        // update open views of this folder
        fdrForEachOpenInstanceView(somSelf,
                                   0,
                                   fdrUpdateFolderSorts);
        // save instance data
        _wpSaveDeferred(somSelf);
        // update folder "Sort" notebook page, if open
        ntbUpdateVisiblePage(somSelf, SP_FLDRSORT_FLDR);
    }

    return (Update);
}

/*
 *@@ xwpSortViewOnce:
 *      sorts the content of given folder.
 *      As opposed to XFolder::xwpSetFldrSort, this does not
 *      change the folder sort settings, but only sorts the view
 *      once.
 *
 *      This is used by the context menu entries in the "Sort"
 *      menu and the respective folder hotkeys.
 *
 *      ulSort must be one of the following:
 *      --  SV_NAME
 *      --  SV_TYPE
 *      --  SV_CLASS                (new: sort by object class)
 *      --  SV_REALNAME
 *      --  SV_SIZE
 *      --  SV_LASTWRITEDATE
 *      --  SV_LASTACCESSDATE
 *      --  SV_CREATIONDATE
 *      --  SV_EXT                  (new: sort by extension)
 *      --  SV_FOLDERSFIRST         (new: sort folders first)
 *
 *@@changed V0.9.2 (2000-03-08) [umoeller]: added folder locking
 */

SOM_Scope BOOL  SOMLINK xf_xwpSortViewOnce(XFolder *somSelf,
                                           HWND hwndFrame,
                                           USHORT usSort)
{
    BOOL        rc = FALSE;

    WPSHLOCKSTRUCT Lock;
    if (wpshLockObject(&Lock, somSelf))
    {
        HWND hwndCnr = wpshQueryCnrFromFrame(hwndFrame);
        // XFolderData *somThis = XFolderGetData(somSelf);
        XFolderMethodDebug("XFolder","xf_xfSortByExt");

        if (hwndCnr)
        {
            CNRINFO CnrInfo;
            ULONG   ulStyle = 0;

            cnrhQueryCnrInfo(hwndCnr, &CnrInfo);

            if ((CnrInfo.flWindowAttr & (CV_ICON | CV_TREE)) == CV_ICON)
            {
                // for some reason, icon views need to have "auto arrange" on,
                // or nothing will happen
                ulStyle = WinQueryWindowULong(hwndCnr, QWL_STYLE);
                WinSetWindowULong(hwndCnr, QWL_STYLE, ulStyle | CCS_AUTOPOSITION);
            }

            // send sort msg with proper sort (comparison) func
            WinSendMsg(hwndCnr,
                       CM_SORTRECORD,
                       (MPARAM)fdrQuerySortFunc(usSort),
                       MPNULL);

            if ((CnrInfo.flWindowAttr & (CV_ICON | CV_TREE)) == CV_ICON)
                // restore old cnr style
                WinSetWindowULong(hwndCnr, QWL_STYLE, ulStyle);

            rc = TRUE;
        }
    } // end if (fFolderLocked)

    wpshUnlockObject(&Lock);

    return (rc);
}

/*
 *@@ xwpQueryIconPos:
 *      this new instance method retrieves the icon position of an
 *      object in a currently populated folder; you need to initialize
 *      the pICONPOS structure first, whose size you need to pass in
 *      ulICONPOSSize; the ICONPOS data will be copied to pipReturn.
 *      The method returns FALSE if something went wrong.
 *
 *@@changed V0.9.2 (2000-03-09) [umoeller]: fixed excessive handle queries
 */

SOM_Scope BOOL  SOMLINK xf_xwpGetIconPos(XFolder *somSelf,
                                         WPObject *pObject,
                                         PBYTE pICONPOS,
                                         USHORT usICONPOSSize,
                                         PICONPOS pipReturn)
{
    USHORT   usStartPos;
    PICONPOS pip;

    CHAR     szKey[100],
             szPath[CCHMAXPATH];

    PSZ      pszClass = _somGetClassName(pObject);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpGetIconPos");

    usStartPos = 21; // with OS/2 2.1 and above, Henk Kelder says

    /* first step: the icon position of each object within a given
       .ICONPOS EA starts with a string identifying the object; so
       first, we need to compose this string depending on the type
       of the passed object */
    if (!_somIsA(pObject, _WPFileSystem))
    {
        // abstract object:
        HOBJECT  hObject = _wpQueryHandle(pObject);
        sprintf(szKey, "%s:A%lX", pszClass, LOUSHORT(hObject));
    }
    else
    {   // file system object
        /* WPFileSystem    *pobjFile;
        if (pobjFile = _wpclsQueryObject(_WPObject, hObject)) */
        {
            if (_wpQueryFilename(pObject, szPath, FALSE))
            {
                sprintf(szKey,
                        "%s:%c%s",
                        pszClass,
                        (_somIsA(pObject, _WPFolder) ? 'D' : 'F'),
                        szPath);
            }
            else
                return FALSE;
        }
        /* else
            return FALSE; */

    }

    // now we have the key to search for within the .ICONPOS EA

    if ((pICONPOS) && (pipReturn))
    {
        /* now we go through the .ICONPOS data that was given to us
           and check each item in there if it matches the key we
           composed above */
        for (pip = (PICONPOS)( pICONPOS + usStartPos );
            (PBYTE)pip < pICONPOS + usICONPOSSize; )
        {
            if (!stricmp(pip->szIdentity, szKey))
            {
                *pipReturn = *pip;
                return TRUE;
            }
            pip = (PICONPOS)( (PBYTE)pip + sizeof(POINTL) + strlen(pip->szIdentity) + 1 );
        }
    }

    return FALSE;
}

/*
 *@@ xwpBeginEnumContent:
 *      this begins ordered content enumeration on a folder.
 *      Call this method before any call to XFolder::xwpEnumNext.
 *
 *      The "enum content" methods are similar to wpQueryContent,
 *      but take into account the order of objects in a folder.
 *      This is done by evaluating the .ICONPOS extended
 *      attributes of a folder.
 *
 *      This function returns an enumeration handle if the folder
 *      contains any objects at all. Pass this handle to any
 *      subsequent calls of XFolder::xwpEnumNext, and keep calling
 *      XFolder::xwpEnumNext until NULL is returned.
 *
 *      Then call XFolder::xwpEndEnumContent when you're
 *      done to free allocated resources.
 *
 *      If the folder is empty, NULLHANDLE is returned.
 *
 *      The "enum content" methods replace the following
 *      methods, which were present before V0.9.0:
 *               xfInvalidateOrderedContent,
 *               xfUpdateOrderedContent,
 *               xfQueryOrderedContent.
 *      The new methods do not keep memory allocated, so
 *      this new approach was taken.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.2 (2000-03-04) [umoeller]: added folder locking
 *@@changed V0.9.3 (2000-04-28) [umoeller]: now pre-resolving wpQueryContent for speed
 */

SOM_Scope ULONG  SOMLINK xf_xwpBeginEnumContent(XFolder *somSelf)
{
    PENUMCONTENT pec;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpBeginEnumContent");

    pec = malloc(sizeof(ENUMCONTENT));
    if (pec)
    {
        BOOL                 fItemsFound = FALSE;
        WPObject             *pObj;
        BOOL                 fFolderLocked = FALSE;

        ULONG ulNesting = 0;
        DosEnterMustComplete(&ulNesting);

        memset(pec, 0, sizeof(ENUMCONTENT));

        wpshCheckIfPopulated(somSelf,
                             FALSE);        // full populate

        // build new list for ORDEREDLISTITEMs:
        pec->pllOrderedContent = lstCreate(TRUE);       // auto-free list items

        TRY_LOUD(excpt1)
        {
            fFolderLocked = !wpshRequestFolderMutexSem(somSelf, 5000);
            if (fFolderLocked)
            {
                // get the folder's content as the WPS delivers it.
                // This is unsorted. Apparently, the WPS returns items
                // in the following order:
                // a)   first: file-system objects in the order returned
                //      by the file system (i.e. alphabetically on HPFS)
                // b)   then all abstract objects in the order they were
                //      placed in this folder.

                // pre-resolve _wpQueryContent for speed V0.9.3 (2000-04-28) [umoeller]
                somTD_WPFolder_wpQueryContent rslv_wpQueryContent
                        = SOM_Resolve(somSelf, WPFolder, wpQueryContent);

                for (pObj = rslv_wpQueryContent(somSelf, NULL, (ULONG)QC_FIRST);
                     (pObj);
                     pObj = rslv_wpQueryContent(somSelf, pObj, (ULONG)QC_NEXT)
                    )
                {
                    // create new list item
                    PORDEREDLISTITEM poliNew = malloc(sizeof(ORDEREDLISTITEM));
                    fItemsFound = TRUE;

                    // store object
                    poliNew->pObj = pObj;

                    // Each ICONPOS struct's identity string has the following format:
                    // <class>:<t><identity>
                    // with: <class> being the class of the object
                    //       <t> == A for abstracts, D for folders, F for files
                    //       <identity> for abstract objects: the handle
                    //                  for file-system objects: the filename

                    // now create the identity string for the search object
                    if (_somIsA(pObj, _WPAbstract))
                    {
                        // for abstract objects, this is the low word
                        // of the object handle
                        HOBJECT hobjSearch = _wpQueryHandle(pObj);
                        sprintf(poliNew->szIdentity, ":A%lX", (hobjSearch & 0xFFFF));
                    }
                    else
                    {
                        // for file-system objects, this is the object's real name
                        ULONG   ulSize = sizeof(poliNew->szIdentity)-2;
                        if (_somIsA(pObj, _WPFolder))
                            strcpy(poliNew->szIdentity, ":D");
                        else
                            strcpy(poliNew->szIdentity, ":F");
                        // append real name
                        _wpQueryRealName(pObj,
                                         (poliNew->szIdentity)+2,
                                         &ulSize,
                                         FALSE);    // file name only
                    }

                    lstAppendItem(pec->pllOrderedContent,
                                  poliNew);
                }
            } // end if fFolderLocked
        }
        CATCH(excpt1) {} END_CATCH();

        if (fFolderLocked)
            wpshReleaseFolderMutexSem(somSelf);

        DosExitMustComplete(&ulNesting);

        if (!fItemsFound)
        {
            // folder was empty:
            // cleanup
            lstFree(pec->pllOrderedContent);
            free(pec);
            pec = NULL;
        }
        else
        {
            PEABINDING           peab;
            SORTBYICONPOS        sip;

            // read .ICONPOS extended attributes of this folder
            _wpQueryFilename(somSelf, sip.szRealName, TRUE);
            if (peab = eaPathReadOneByName(sip.szRealName, ".ICONPOS"))
            {

                //  typedef struct
                //  {
                //    BYTE bFlags;
                //    BYTE bNameLength;
                //    USHORT usValueLength;
                //    PSZ pszName;
                //    PSZ pszValue;
                //  } EABINDING, *PEABINDING;

                PBYTE pICONPOS = malloc(peab->usValueLength+100);

                if (pICONPOS)
                {
                    ULONG ulICONPOSSize = (peab->usValueLength)-5;
                    memcpy(pICONPOS, peab->pszValue+4, peab->usValueLength-3);

                    // finally, we have the ICONPOS data in _pICONPOS;
                    // now we pass the ICONPOS data to the sort function
                    // defined above

                    #ifdef DEBUG_ORDEREDLIST
                        _Pmpf(("  Sorting..."));
                    #endif

                    sip.pICONPOS = pICONPOS;
                    sip.usICONPOSSize = ulICONPOSSize;

                    lstQuickSort(pec->pllOrderedContent,
                                 fdrSortByICONPOS,
                                 &sip);     // addtl. param passed to sort func

                    free(pICONPOS);
                }

                eaFreeBinding(peab);
            }
        }
    }

    return ((ULONG)pec);
}

/*
 *@@ xwpEnumNext:
 *      this keeps returning the ordered contents of a
 *      folder or NULL if no more objects are found.
 *
 *      Keep calling this function if XFolder::xwpBeginEnumContent
 *      returned a valid enumeration handle, until this
 *      function returns NULL.
 *
 *      Then call XFolder::xwpEndEnumContent when you're
 *      done to free allocated resources.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope WPObject*  SOMLINK xf_xwpEnumNext(XFolder *somSelf,
                                            ULONG henum)
{
    WPObject *pObject = NULL;
    PENUMCONTENT pec = (PENUMCONTENT)henum;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpEnumNext");

    if (pec)
    {
        if (pec->pnodeLastQueried == NULL)
            // first call: get first list node
            pec->pnodeLastQueried = lstQueryFirstNode(pec->pllOrderedContent);
        else
            // subsequent calls: get next list node
            pec->pnodeLastQueried = pec->pnodeLastQueried->pNext;

        if (pec->pnodeLastQueried)
        {
            // another item found:
            PORDEREDLISTITEM poli = (PORDEREDLISTITEM)pec->pnodeLastQueried->pItemData;
            if (poli)
                pObject = poli->pObj;
        }
    }

    return (pObject);
}

/*
 *@@ xwpEndEnumContent:
 *      this frees resources allocated when enumerating
 *      folder contents.
 *
 *      See XFolder::xwpBeginEnumContent for how to use
 *      this.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpEndEnumContent(XFolder *somSelf,
                                             ULONG henum)
{
    PENUMCONTENT pec = (PENUMCONTENT)henum;
    BOOL brc = FALSE;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpEndEnumContent");

    if (pec)
    {
        lstFree(pec->pllOrderedContent);    // this will auto-free the list items
        free(pec);
        brc = TRUE;
    }

    return (brc);
}

/*
 *@@ xwpBeginProcessOrderedContent:
 *      this new instance method uses XFolder::xwpBeginEnumContent etc.
 *      to open all the objects in the given folder. This is used
 *      by the XWorkplace Startup and Shutdown folders.
 *
 *      This method returns immediately; further processing is done in the
 *      background Worker thread.
 *
 *      However, this method returns a handle which may be used in
 *      XFolder::xwpCancelProcessOrderedContent to abort processing.
 *      Upon errors, null is returned.
 *
 *      Parameters:
 *      -- ULONG ulTiming:     the time to wait between starting objects
 *                                  in milliseconds; if set to 0, this function
 *                                  will work in "Wait" mode, i.e. the next
 *                                  object will open the next object only if
 *                                  the previous one has been closed again
 *                                  (e.g. for XShutdown folder).
 *      -- PFNWP pfnwpCallback: a callback routine which will be called on
 *                                  every object which is started.
 *      -- ULONG ulCallbackParam: the first parameter to pass to this proc.
 *
 *      You will be notified of the progress thru the pfnwpCallback function,
 *      which gets passed the the following parameters:
 *      -- HWND  hwnd:     will not be a hwnd, but ulCallbackParam
 *                              specified above (which might be a window though);
 *      -- ULONG msg:      will contain the current object of the
 *                              folder on which this mthd is invoked;
 *                              this must be cast manually to (WPObject*);
 *      -- MPARAM mp1:     contains the current object count
 *                              (starting with 1 and increasing for each
 *                              subsequent object);
 *      -- MPARAM mp2:     the (constant) number of objects in the folder.
 *
 *      This callback func may be used for implementing a progress bar.
 *      You can use ulCallbackParam for the msg window handle and display
 *      the progress according to mp1 and mp2; the object title may be
 *      obtained by calling _wpQueryTitle((WPObject*)msg).
 *
 *      Note that even though the processing of the folder is done in the
 *      Worker thread, the callback func is actually called on thread 1
 *      (Workplace thread), so you can create your window there and have
 *      work done on it without having to worry about thread safety. This
 *      is implemented because wpViewObject is having problems when not
 *      being called in the Workplace thread.
 *
 *      In detail, the thread interaction works as follows:
 *
 *      1)   Calling this function posts WOM_PROCESSORDEREDCONTENT to
 *                the Worker thread (fnwpWorkerObject), which takes over.
 *
 *      2)   The Worker thread then goes thru the (ordered) contents of
 *                the specified folder. For each object found, it posts
 *                T1M_POCCALLBACK to krn_fnwpThread1Object, which will then in
 *                turn call your callback on thread 1.
 *
 *      3)   The Worker thread then either waits for the object to
 *                be closed (in "Wait" mode) or the specified time.
 *
 *      After all objects have been processed, the callback will called
 *      once more with msg == 0 to allow cleaning up. If the folder does
 *      not contain any objects, the callback will only be called this one
 *      time.
 *
 *      If you're running in "Wait" mode, the callback must return the
 *      hwnd of the object which you must have opened with wpViewObject,
 *      so that the Worker thread can wait for this window to be closed.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 */

SOM_Scope ULONG  SOMLINK xf_xwpBeginProcessOrderedContent(XFolder *somSelf,
                                                          ULONG ulTiming,
                                                          PFNWP pfnwpCallback,
                                                          ULONG ulCallbackParam)
{
    PPROCESSCONTENTINFO pPCI;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpBeginProcessOrderedContent");

    pPCI = (PPROCESSCONTENTINFO)malloc(sizeof(PROCESSCONTENTINFO));

    if (pPCI)
    {
        pPCI->ulObjectNow = 0;
        pPCI->ulTiming = ulTiming;
        pPCI->pfnwpCallback = pfnwpCallback;
        pPCI->ulCallbackParam = ulCallbackParam;
        pPCI->fCancelled = FALSE;

        xthrPostWorkerMsg(WOM_PROCESSORDEREDCONTENT, (MPARAM)somSelf, pPCI);

        return ((ULONG)pPCI);
    }
    return (0);
}

/*
 *@@ xwpCancelProcessOrderedContent:
 *      this method cancels a folder content process started with
 *      XFolder::xwpBeginProcessOrderedContent; hPOC must the handle
 *      returned by that function.
 *
 *      Warning: After folder content processing has finished, hPOC is
 *      no longer valid, and calling this function then will simply
 *      crash the WPS. As a result, your callback function MUST keep
 *      track if hPOC is still valid; after the callback func has been
 *      called with msg == 0, calling this function is no longer allowed.
 */

SOM_Scope BOOL  SOMLINK xf_xwpCancelProcessOrderedContent(XFolder *somSelf,
                                                          ULONG hPOC)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpCancelProcessOrderedContent");

    ((PPROCESSCONTENTINFO)hPOC)->fCancelled = TRUE;

    return (TRUE);
}

/*
 *@@ xwpMakeFavoriteFolder:
 *      if fInsert is TRUE, this folder will be made a "favorite folder",
 *      i.e. added to all context menus; if FALSE, it will be removed.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 *@@changed V0.9.1: made folder list code generic in folder.c
 *@@changed V0.9.7 (2001-01-18) [umoeller]: added list notify on deletion, which fixed crashes
 */

SOM_Scope ULONG  SOMLINK xf_xwpMakeFavoriteFolder(XFolder *somSelf,
                                                  BOOL fInsert)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);

    XFolderMethodDebug("XFolder","xf_xwpMakeFavoriteFolder");

    return (objAddToList(somSelf,
                         G_pllFavoriteFolders,
                         fInsert,
                         INIKEY_FAVORITEFOLDERS,
                         OBJLIST_FAVORITEFOLDER));
}

/*
 *@@ xwpIsFavoriteFolder:
 *      returns TRUE if somSelf is on the list of "favorite" folders.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 *@@changed V0.9.1: made folder list code generic in folder.c
 */

SOM_Scope BOOL  SOMLINK xf_xwpIsFavoriteFolder(XFolder *somSelf)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);
    XFolderMethodDebug("XFolder","xf_xwpIsFavoriteFolder");

    return (objIsOnList(somSelf,
                        G_pllFavoriteFolders));
}

/*
 *@@ xwpSetQuickOpen:
 *      if fQuickOpen == TRUE, somSelf will automatically be
 *      populated at WPS bootup.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 *@@changed V0.9.1: made folder list code generic in folder.c
 *@@changed V0.9.7 (2001-01-18) [umoeller]: added list notify on deletion, which fixed crashes
 */

SOM_Scope ULONG  SOMLINK xf_xwpSetQuickOpen(XFolder *somSelf,
                                            BOOL fQuickOpen)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);
    XFolderMethodDebug("XFolder","xf_xwpSetQuickOpen");

    return (objAddToList(somSelf,
                         G_pllQuickOpenFolders,
                         fQuickOpen,
                         INIKEY_QUICKOPENFOLDERS,
                         OBJLIST_QUICKOPENFOLDER));
}

/*
 *@@ xwpQueryQuickOpen:
 *      returns TRUE if somSelf has the QuickOpen feature ON.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 *@@changed V0.9.1: made folder list code generic in folder.c
 */

SOM_Scope BOOL  SOMLINK xf_xwpQueryQuickOpen(XFolder *somSelf)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);
    XFolderMethodDebug("XFolder","xf_xwpSetQuickOpen");

    return (objIsOnList(somSelf,
                        G_pllQuickOpenFolders));
}

/*
 *@@ xwpSetDefaultDocument:
 *      this sets the default document for this folder.
 *      If a default document is set for a folder, a
 *      double-click on the folder will not open the
 *      folder, but the default document instead.
 *
 *      Returns FALSE on errors, e.g. if pDefDoc is
 *      not a WPFileSystem or does not reside in the
 *      current folder (somSelf).
 *
 *      If pDefDoc is NULL, the default document is
 *      unset to restore normal folder behavior.
 *
 *@@added V0.9.4 (2000-06-09) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpSetDefaultDocument(XFolder *somSelf,
                                                 WPFileSystem* pDefDoc)
{
    WPSHLOCKSTRUCT Lock;
    BOOL brc = FALSE;
    XFolderMethodDebug("XFolder","xf_xwpSetDefaultDocument");

    if (wpshLockObject(&Lock, somSelf))
    {
        XFolderData *somThis = XFolderGetData(somSelf);

        if (!pDefDoc)
        {
            // NULL:
            _pDefaultDocument = NULL;
            brc = TRUE;
        }
        else
        {
            if (    (_somIsA(pDefDoc, _WPFileSystem))       // must be a WPFileSystem
                 && (_wpQueryFolder(pDefDoc) == somSelf)    // must be in this folder
               )
            {
                _pDefaultDocument = pDefDoc;
                brc = TRUE;
            }
        }

        _wpSaveDeferred(somSelf);
    }

    wpshUnlockObject(&Lock);

    return (brc);
}

/*
 *@@ xwpQueryDefaultDocument:
 *      returns the default document which has been set
 *      previously with XFolder::xwpSetDefaultDocument
 *      or NULL if there's none.
 *
 *@@added V0.9.4 (2000-06-09) [umoeller]
 */

SOM_Scope WPFileSystem*  SOMLINK xf_xwpQueryDefaultDocument(XFolder *somSelf)
{
    WPFileSystem *rc = NULL;

    XFolderMethodDebug("XFolder","xf_xwpQueryDefaultDocument");

    if (!_somIsA(somSelf, _WPDesktop))
    {
        WPSHLOCKSTRUCT Lock;
        if (wpshLockObject(&Lock, somSelf))
        {
            XFolderData *somThis = XFolderGetData(somSelf);

            if (_pszDefaultDocDeferred)
                // we have a default document, but this hasn't been
                // resolved yet:
                rc = NULL;
            else
                rc = _pDefaultDocument;
        }

        wpshUnlockObject(&Lock);
    }

    return (rc);
}

/*
 *@@ xwpQueryMenuBarVisibility:
 *      returns TRUE or FALSE if Warp 4's folder bar is
 *      currently visible for this folder. On Warp 3, this
 *      always returns FALSE.
 *
 *      Warp 4 does have a method for querying this, but we want
 *      XWorkplace to run on Warp 3 also, so I have rewritten this.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpQueryMenuBarVisibility(XFolder *somSelf)
{
    BOOL        brc = FALSE;
    XFolderMethodDebug("XFolder","xf_xwpQueryMenuBarVisibility");

    if (doshIsWarp4())
    {
        XFolderData *somThis = XFolderGetData(somSelf);
        // to find out whether the menu bar has been enabled,
        // check the FDRLONGARRAY (xfldr.idl) to which we have
        // obtained a pointer using the ugly kludge in
        // XFolder::wpRestoreData
        if (_wpIsObjectInitialized(somSelf)) // V0.9.3 (2000-04-29) [umoeller]
            if (_pFolderLongArray)
            {
                // _Pmpf(("cbFldrLongArray: %d", _cbFldrLongArray));
                ULONG   ulMenuBarVisibility = _pFolderLongArray->ulMenuBarVisibility;
                            // 0 = off, 1 = on, 2 = default
                if (ulMenuBarVisibility == 1)
                    brc = TRUE;
                else if (ulMenuBarVisibility == 2)
                {
                    CHAR    szTemp[20] = "";
                    // default value set: get the default value
                    PrfQueryProfileString(HINI_USER,
                                          "PM_Workplace",
                                          "FolderMenuBar",
                                          "OFF",
                                          szTemp,
                                          sizeof(szTemp));
                    if (strcmp(szTemp, "ON") == 0)
                        brc = TRUE;
                }
            }
    }

    return (brc);
}

/*
 *@@ xwpSetStatusBarVisibility:
 *      this new instance method sets the status bar visibility of
 *      a folder.
 *      ulVisibility may be:
 *      -- STATUSBAR_ON:        show status bars
 *      -- STATUSBAR_OFF:       hide status bars
 *      -- STATUSBAR_DEFAULT:   use GLOBALSETTINGS for this folder
 *
 *      If fUpdate is TRUE, XFolder will have the Worker thread search
 *      for open folder views and update their frame controls accordingly.
 *      Otherwise the status bar setting will only be changed internally
 *      for the next time the folder is opened. Might lead to errors.
 *      Returns TRUE if successful.
 */

SOM_Scope BOOL  SOMLINK xf_xwpSetStatusBarVisibility(XFolder *somSelf,
                                                     ULONG ulVisibility,
                                                     BOOL fUpdate)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpSetStatusBarVisibility");

    if (_bStatusBarInstance != ulVisibility)
    {
        #ifdef DEBUG_STATUSBARS
            _Pmpf(( "xwpSetStatusBarVisibility: %d", ulVisibility));
        #endif
        _bStatusBarInstance = ulVisibility;

        if (fUpdate)
        {
            // update open folder views in Worker thread;
            // this will call fncbUpdateStatusBars for each
            // open folder window
            xthrPostWorkerMsg(WOM_UPDATEALLSTATUSBARS,
                             (MPARAM)1,      // show/hide flag
                             MPNULL);
            // update "XFolder" notebook page, if open
            ntbUpdateVisiblePage(somSelf, SP_XFOLDER_FLDR);
        }
    }
    return (TRUE);
}

/*
 *@@ xwpQueryStatusBarVisibility:
 *      this new instance method returns the status bar visibility of
 *      a folder:
 *      -- STATUSBAR_ON:        status bars visible
 *      -- STATUSBAR_OFF:       status bars invisible
 *      -- STATUSBAR_DEFAULT:   GLOBALSETTINGS used for this folder
 *
 *@@changed V0.9.0 [umoeller]: function prototype changed
 */

SOM_Scope ULONG  SOMLINK xf_xwpQueryStatusBarVisibility(XFolder *somSelf)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpQueryStatusBarVisibility");

    return (_bStatusBarInstance);
}

/*
 *@@ xwpProcessObjectCommand:
 *      this new XFolder instance method gets called when
 *      XFolder's subclassed window procedure
 *      (fdr_fnwpSubclassedFolderFrame) intercepts a WM_COMMAND
 *      message. This gets called before the WPS gets a
 *      chance to process that command, which will probably
 *      result in a call to wpMenuItemSelected for each of
 *      the affected objects in the container.
 *
 *      The purpose of this new message is to allow any folder
 *      (e.g. a subclass of WPFolder) to intercept object
 *      operations _before_ wpMenuItemSelected. While
 *      wpMenuItemSelected is OK for doing things which only
 *      affect a single object, it is not quite suitable
 *      for collecting all selected objects and processing
 *      them all at once. This is where overriding this method
 *      helps.
 *
 *      If this returns TRUE, it is assumed that the command
 *      was processed, and it is swallowed (i.e. not passed
 *      on to the standard WPS processing). If you're not
 *      interested in a command, you must return FALSE,
 *      or you'll break all other menu items.
 *
 *      Parameters:
 *
 *      -- usCommand has the command message (e.g. WPMENUID_DELETE).
 *
 *      -- hwndCnr has the folder's container window where the
 *         command originated from.
 *
 *      -- pFirstObject has the first of the selected objects.
 *
 *      -- ulSelectionFlags has information on the context why
 *         pFirstObject was considered selected. You can use
 *         wpshQueryNextSourceObject to get the others, if this
 *         is indicated here.
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpProcessObjectCommand(XFolder *somSelf,
                                                   USHORT usCommand,
                                                   HWND hwndCnr,
                                                   WPObject* pFirstObject,
                                                   ULONG ulSelectionFlags)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpProcessObjectCommand");

    return (fdrProcessObjectCommand(somSelf,
                                    usCommand,
                                    hwndCnr,
                                    pFirstObject,
                                    ulSelectionFlags));
}

/*
 *@@ xwpUpdateStatusBar:
 *      this method gets called when the status bar needs updating.
 *
 *      To be more precise, it is fdr_fnwpStatusBar which calls this
 *      method after it has received STBM_UPDATESTATUSBAR and the
 *      update timer has elapsed.
 *
 *      This method has been introduced for two reasons:
 *
 *      a)   You can call it yourself if you need to have the
 *           status bar updated; use
 +              WinQueryWindow(hwndFrame, 0x9001)
 *           to get hwndStatusBar for this method. If that call
 *           returns NULLHANDLE, there is no status bar for the
 *           folder view.
 *
 *      b)   You can override this method if you wish to have a
 *           different status bar display. This method gets called
 *           using SOM name-lookup resolution, so you can even
 *           override this method if you don't want to derive your
 *           folder class from XFolder. Simply define a method with
 *           the same prototype in your WPFolder subclass, and your
 *           method will get called instead of this default one.
 *
 *           The XWPTrashCan class (xtrash.c) is an example of a
 *           WPFolder (not XFolder!) subclass which overrides this
 *           method (see XWPTrashCan::xwpUpdateStatusBar).
 *
 *           See the SOM Programming Guide for details about name-lookup
 *           method resolution.
 *
 *      It is the responsibility of this method to completely compose
 *      the status bar text (according to the container contents) and
 *      set the status bar to that text. You can use a simple
 *      WinSetWindowText(hwndStatusBar, ...) for that.
 *
 *      This method calls stbComposeText (statbars.c) per default,
 *      which translates all status bar mnemonics except for the
 *      $x flags (tabulators), which are evaluated
 *
 *      If any $x flags are found (see the XWorkplace User Guide for
 *      WPObject status bar codes), these will be parsed during WM_PAINT
 *      of fdr_fnwpStatusBar only. So you can use those tags when
 *      setting the status bar's text to position status bar substrings.
 *      All other tags are not evaluated though.
 *
 *      hwndStatusbar has the HWND of the status bar window (a child
 *      of the folder frame). The QWL_USER window word of that
 *      window points to a STATUSBARDATA structure (statbars.h)
 *      containing more information.
 *
 *      hwndCnr is the container HWND of the folder view to which
 *      the status bar has been added. Use that for getting selected
 *      objects.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpUpdateStatusBar(XFolder *somSelf,
                                              HWND hwndStatusBar,
                                              HWND hwndCnr)
{
    PSZ psz;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpUpdateStatusBar");

    psz = stbComposeText(somSelf,
                         hwndCnr);
    if (psz)
    {
        WinSetWindowText(hwndStatusBar, psz);
        free(psz);
    }

    return (psz != 0);
}

/*
 *@@ xwpAddXFolderPages:
 *      this adds the "XFolder" page into a folder settings notebook.
 */

SOM_Scope ULONG  SOMLINK xf_xwpAddXFolderPages(XFolder *somSelf,
                                               HWND hwndDlg)
{
    PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
    memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

    XFolderMethodDebug("XFolder","xf_xwpAddXFolderPages");

    pcnbp->somSelf = somSelf;
    pcnbp->hwndNotebook = hwndDlg;
    pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
    pcnbp->ulDlgID = ID_XSD_SETTINGS_FLDR1;
    pcnbp->ulPageID = SP_XFOLDER_FLDR;
    pcnbp->usPageStyleFlags = BKA_MAJOR;
    pcnbp->pszName = "~XFolder";
    pcnbp->ulDefaultHelpPanel  = ID_XSH_SETTINGS_FLDR1;
    pcnbp->pfncbInitPage    = fdrXFolderInitPage;
    pcnbp->pfncbItemChanged = fdrXFolderItemChanged;

    return (ntbInsertPage(pcnbp));
}

/*
 *@@ xwpQuerySetup2:
 *      this XFldObject method is overridden to support
 *      setup strings for folders.
 *
 *      See XFldObject::xwpQuerySetup2 for details.
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_xwpQuerySetup2(XFolder *somSelf,
                                           PSZ pszSetupString,
                                           ULONG cbSetupString)
{
    ULONG ulReturn = 0;
    // method pointer for parent class
    somTD_XFldObject_xwpQuerySetup pfn_xwpQuerySetup2 = 0;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpQuerySetup2");

    // call XFolder implementation
    ulReturn = fdrQuerySetup(somSelf, pszSetupString, cbSetupString);

    // manually resolve parent method
    pfn_xwpQuerySetup2
        = (somTD_XFldObject_xwpQuerySetup)wpshResolveFor(somSelf,
                                                         _somGetParent(_XFolder),
                                                         "xwpQuerySetup2");
    if (pfn_xwpQuerySetup2)
    {
        // now call parent method
        if ( (pszSetupString) && (cbSetupString) )
            // string buffer already specified:
            // tell parent to append to that string
            ulReturn += pfn_xwpQuerySetup2(somSelf,
                                           pszSetupString + ulReturn, // append to existing
                                           cbSetupString - ulReturn); // remaining size
        else
            // string buffer not yet specified: return length only
            ulReturn += pfn_xwpQuerySetup2(somSelf, 0, 0);
    }

    return (ulReturn);
}

/*
 *@@ xwpSetDisableCnrAdd:
 *      sets the "disable automatic cnr add" flag for this folder.
 *
 *      Normally, this flag is FALSE (resulting in the standard
 *      WPS behavior for wpAddToContent). However, you may choose
 *      to call this method with (fDisable == TRUE), which will
 *      NOT automatically insert objects into the container when
 *      the folder is populated.
 *
 *      After that, the behavior of XFolder::wpAddToContent is
 *      modified.
 *
 *      NOTE: You must call this method during the processing
 *      of the folder's wpInitData, or otherwise the folder
 *      contents will become garbled.
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope void  SOMLINK xf_xwpSetDisableCnrAdd(XFolder *somSelf,
                                               BOOL fDisable)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpSetDisableCnrAdd");

    _fDisableAutoCnrAdd = fDisable;
}

/*
 *@@ wpInitData:
 *      this WPObject instance method gets called when the
 *      object is being initialized (on wake-up or creation).
 *      We initialize our additional instance data here.
 *      Always call the parent method first.
 *
 *@@changed V0.9.4 (2000-08-02) [umoeller]: added "keep title" instance setting
 */

SOM_Scope void  SOMLINK xf_wpInitData(XFolder *somSelf)
{
    // PGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpInitData");

    XFolder_parent_WPFolder_wpInitData(somSelf);

    // set all the instance variables to safe defaults
    _bSnapToGridInstance = 2;
    _bFullPathInstance = 2;
    _bKeepTitleInstance = 2;
    _bFolderHotkeysInstance = 2;
    _bStatusBarInstance = STATUSBAR_DEFAULT;

    _bAlwaysSort = SET_DEFAULT;
    _bDefaultSort = SET_DEFAULT;
    _fXFolderSortSettingRestored = FALSE;

    _pFolderSortInfo = NULL;
    _pFolderLongArray = NULL;
    _pszFolderStrArray = NULL;
    _cbFolderStrArray = 0;
    _cbFolderLongArray = 0;

    _pFolderBackground = NULL;
    _cbFolderBackground = 0;

    _pulFolderShowAllInTreeView = NULL;

    _pszFolderBkgndImageFile = 0;

    _fUnInitCalled = FALSE;
    _hwndCnrSaved = NULLHANDLE;

    _pfnResolvedUpdateStatusBar = NULL;

    _pDefaultDocument = NULL; // V0.9.4 (2000-06-09) [umoeller]
    _pszDefaultDocDeferred = NULL; // V0.9.4 (2000-06-09) [umoeller]

    _cObjects = 0;

    _fDisableAutoCnrAdd = FALSE;

    _ppFirstObj = NULL;
    _ppLastObj = NULL;
}

/*
 *@@ wpSetup:
 *      this WPObject instance method is called to allow an
 *      object to set up itself according to setup strings.
 *      XFolder will examine its setup strings here.
 *
 *@@changed V0.9.1 (2000-01-03) [umoeller]: now processing our own strings first
 *@@changed V0.9.6 (2000-10-16) [umoeller]: added QUICKOPEN=IMMEDIATE
 */

SOM_Scope BOOL  SOMLINK xf_wpSetup(XFolder *somSelf, PSZ pszSetupString)
{
    BOOL        rc = FALSE,             // processed
                fChanged = FALSE;       // instance data changed
                // fCallParent = TRUE;
    CHAR        szValue[CCHMAXPATH + 1];
    ULONG       cbValue;

    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpSetup");

    rc = (XFolder_parent_WPFolder_wpSetup(somSelf, pszSetupString));

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "SNAPTOGRID", szValue, &cbValue))
    {
        rc = TRUE;
        fChanged = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _bSnapToGridInstance = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            _bSnapToGridInstance = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            _bSnapToGridInstance = 2;
        else if (strnicmp(szValue, "EXEC", 4) == 0)
        {
            fdrSnapToGrid(somSelf, FALSE);
            fChanged = FALSE;
        }
        else
        {
            fChanged = FALSE;
            rc = FALSE;
        }
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "FULLPATH", szValue, &cbValue))
    {
        fChanged = TRUE;
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _bFullPathInstance = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            _bFullPathInstance = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            _bFullPathInstance = 2;

        fdrUpdateAllFrameWndTitles(somSelf);
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "ACCELERATORS", szValue, &cbValue))
    {
        fChanged = TRUE;
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _bFolderHotkeysInstance = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            _bFolderHotkeysInstance = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            _bFolderHotkeysInstance = 2;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "FAVORITEFOLDER", szValue, &cbValue))
    {
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _xwpMakeFavoriteFolder(somSelf, FALSE);
        else if (strnicmp(szValue, "YES", 3) == 0)
            _xwpMakeFavoriteFolder(somSelf, TRUE);
        // fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "QUICKOPEN", szValue, &cbValue))
    {
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _xwpSetQuickOpen(somSelf, FALSE);
        else if (strnicmp(szValue, "YES", 3) == 0)
            _xwpSetQuickOpen(somSelf, TRUE);
        else if (strnicmp(szValue, "IMMEDIATE", 3) == 0)  // V0.9.6 (2000-10-16) [umoeller]
            fdrQuickOpen(somSelf,
                         NULL);     // no callback
    }

    if (somSelf != cmnQueryActiveDesktop())
    {
        cbValue = sizeof(szValue);
        if (_wpScanSetupString(somSelf, pszSetupString,
                               "STATUSBAR", szValue, &cbValue))
        {
            rc = TRUE;
            if (strnicmp(szValue, "NO", 2) == 0)
                _bStatusBarInstance = STATUSBAR_OFF;
            else if (strnicmp(szValue, "YES", 3) == 0)
                _bStatusBarInstance = STATUSBAR_ON;
            else if (strnicmp(szValue, "DEFAULT", 7) == 0)
                _bStatusBarInstance = STATUSBAR_DEFAULT;
        }
        xthrPostWorkerMsg(WOM_UPDATEALLSTATUSBARS,
                          (MPARAM)1,  // show/hide flag
                          MPNULL);
        fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "ALWAYSSORT", szValue, &cbValue))
    {
        USHORT      usDefaultSort, usAlwaysSort;

        rc = TRUE;
        _xwpQueryFldrSort(somSelf, &usDefaultSort, &usAlwaysSort);

        if (strnicmp(szValue, "NO", 2) == 0)
            usAlwaysSort = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            usAlwaysSort = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            usAlwaysSort = SET_DEFAULT;
        _xwpSetFldrSort(somSelf, usDefaultSort, usAlwaysSort);
        // fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "DEFAULTSORT", szValue, &cbValue))
    {
        USHORT      usDefaultSort = 0,
                    usAlwaysSort = 0;
        LONG lValue;

        rc = TRUE;
        _xwpQueryFldrSort(somSelf, &usDefaultSort, &usAlwaysSort);

        sscanf(szValue, "%d", &lValue);
        if ( (lValue >=0) && (lValue <= SV_LAST) )
            usDefaultSort = lValue;
        else
            usDefaultSort = SET_DEFAULT;
        _xwpSetFldrSort(somSelf, usDefaultSort, usAlwaysSort);
        // fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "SORTNOW", szValue, &cbValue))
    {
        USHORT usSort;
        LONG lValue;

        sscanf(szValue, "%d", &lValue);
        if ( (lValue >=0) && (lValue <= SV_LAST) )
            usSort = lValue;
        else
            usSort = SET_DEFAULT;

        fdrForEachOpenInstanceView(somSelf,
                                   usSort,
                                   fdrSortAllViews);
    }

    if (fChanged)
        _wpSaveDeferred(somSelf);

    return (rc);
}

/*
 *@@ wpObjectReady:
 *      this WPObject notification method gets called by the
 *      WPS when object instantiation is complete, for any reason.
 *      ulCode and refObject signify why and where from the
 *      object was created.
 *      The parent method must be called first.
 *
 *      See XFldObject::wpObjectReady for remarks about using
 *      this method as a copy constructor.
 *
 *      We will have this object's pointer stored
 *      in a global list (maintained by the Worker thread)
 *      so that XShutdown knows which objects are currently
 *      awake.
 *
 *      Note: XFldObject::wpObjectReady already does this
 *      for all objects, but on my Warp 4 (FP 10), that
 *      method does _not_ get called for WPFolder instances,
 *      so we override this method for XFolder also.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.4 (2000-06-09) [umoeller]: added default document
 */

SOM_Scope void  SOMLINK xf_wpObjectReady(XFolder *somSelf,
                                         ULONG ulCode,
                                         WPObject* refObject)
{
    WPSHLOCKSTRUCT Lock;
    // XFolderMethodDebug("XFolder","xf_wpObjectReady");

    #if defined(DEBUG_SOMMETHODS) || defined(DEBUG_AWAKEOBJECTS)
        _Pmpf(("XFolder::wpObjectReady for %s (class %s), ulCode: %s",
                _wpQueryTitle(somSelf),
                _somGetName(_somGetClass(somSelf)),
                (ulCode == OR_AWAKE) ? "OR_AWAKE"
                : (ulCode == OR_FROMTEMPLATE) ? "OR_FROMTEMPLATE"
                : (ulCode == OR_FROMCOPY) ? "OR_FROMCOPY"
                : (ulCode == OR_NEW) ? "OR_NEW"
                : (ulCode == OR_SHADOW) ? "OR_SHADOW"
                : (ulCode == OR_REFERENCE) ? "OR_REFERENCE"
                : "unknown code"
             ));
    #endif

    XFolder_parent_WPFolder_wpObjectReady(somSelf, ulCode, refObject);

    xthrPostWorkerMsg(WOM_ADDAWAKEOBJECT,
                      (MPARAM)somSelf,
                      MPNULL);

    if (wpshLockObject(&Lock, somSelf))
    {
        XFolderData *somThis = XFolderGetData(somSelf);

        // were we copied?
        if (ulCode & OR_REFERENCE)
        {
            XFolderData *somThat = XFolderGetData(refObject);
            // yes: fix the instance data which SOM has done
            // a flat binary copy on... V0.9.7 (2000-12-13) [umoeller]
            _pfnResolvedUpdateStatusBar = NULL;

            _pDefaultDocument = NULL;
        }


        // in all cases, resolve deferred default document
        if (_pszDefaultDocDeferred)
        {
            // this has been set by wpRestoreState
            _pDefaultDocument = wpshContainsFile(somSelf, _pszDefaultDocDeferred);
                // can return NULL if not found
            free(_pszDefaultDocDeferred);
            _pszDefaultDocDeferred = NULL;
        }
    }

    wpshUnlockObject(&Lock);
}

/*
 *@@ wpUnInitData:
 *      this WPObject instance method is called when the object
 *      is destroyed as a SOM object, either because it's being
 *      made dormant or being deleted. All allocated resources
 *      should be freed here.
 *      The parent method must always be called last.
 */

SOM_Scope void  SOMLINK xf_wpUnInitData(XFolder *somSelf)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpUnInitData");

    // make sure we only do this once, because we
    // seem to get called several times sometimes
    if (!_fUnInitCalled)
        _fUnInitCalled = TRUE;

    if (_pszFolderBkgndImageFile)
        free(_pszFolderBkgndImageFile);

    XFolder_parent_WPFolder_wpUnInitData(somSelf);
        // fixed this (V0.9.0)
}

/*
 *@@ wpFree:
 *      this WPObject method destroys the persistent form of the object
 *      and then frees the memory that represented that object.
 *
 *      For WPFolders, this is called when a folder is actually to be
 *      deleted. We will call the parent method and then also remove
 *      those darn PMWorkplace:FolderPos entries which the WPS never
 *      deletes.
 *
 *      If the folder is somewhere in the config folder hierarchy,
 *      we also invalidate the config folder caches in fdrmenus.c.
 *
 *@@changed V0.9.0 [umoeller]: adjusted to new config folder handling
 */

SOM_Scope BOOL  SOMLINK xf_wpFree(XFolder *somSelf)
{
    BOOL        brc;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    HOBJECT     hObj = NULLHANDLE;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpFree");

    /* if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // invalidate the content lists for the config
        // folders so that they will be rebuilt
        mnuInvalidateConfigCache();
    } */ // now handled by XFldObject::wpUninitData

    if (pGlobalSettings->CleanupINIs)
    {
        // "clean up INI files": get object handle for
        // folderpos deletion later. This doesn't hurt
        // because every folder has a handle once it has
        // been opened
        hObj = _wpQueryHandle(somSelf);
    }

    // according to WPS docs, the parent method should be called
    // AFTER additional processing; probably somSelf becomes invalid
    // after this
    brc = XFolder_parent_WPFolder_wpFree(somSelf);

    if (brc)
        // successfully deleted:
        if (hObj)
            // have FOLDERPOS entries
            // deleted by Worker thread; we only pass the
            // object HANDLE and not somSelf because somSelf
            // is no longer valid after having called the parent
            xthrPostWorkerMsg(WOM_DELETEFOLDERPOS,
                              (MPARAM)hObj, NULL);

    return (brc);
}

/*
 *@@ wpSaveState:
 *      this WPObject instance method saves an object's state
 *      persistently so that it can later be re-initialized
 *      with wpRestoreState. This gets called during wpClose,
 *      wpSaveImmediate or wpSaveDeferred processing.
 *      All persistent instance variables should be stored here.
 *
 *@@changed V0.9.4 (2000-06-09) [umoeller]: added default document
 *@@changed V0.9.4 (2000-08-02) [umoeller]: added "keep title" instance setting
 *@@changed V0.9.7 (2000-12-18) [umoeller]: fixed folder sorts
 */

SOM_Scope BOOL  SOMLINK xf_wpSaveState(XFolder *somSelf)
{
    BOOL brc = FALSE;
    XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpSaveState");

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpSaveState (%s)", _wpQueryTitle(somSelf)));
    #endif

    // we will now save all our instance data; in order
    // not to blow up the EA size too much, we will only
    // save data which is different from the "transparent"
    // (i.e. Global) setting

    if (_bSnapToGridInstance != 2)
        _wpSaveLong(somSelf, (PSZ)G_pcszXFolder, 1, (ULONG)_bSnapToGridInstance);
    if (_bFullPathInstance != 2)
        _wpSaveLong(somSelf, (PSZ)G_pcszXFolder, 2, (ULONG)_bFullPathInstance);
    if (_bFolderHotkeysInstance != 2)
        _wpSaveLong(somSelf, (PSZ)G_pcszXFolder, 3, (ULONG)_bFolderHotkeysInstance);
    if (_bStatusBarInstance != STATUSBAR_DEFAULT)
        _wpSaveLong(somSelf, (PSZ)G_pcszXFolder, 4, (ULONG)_bStatusBarInstance);
    /* if (_ulSBInflatedFrame)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 5, (ULONG)_ulSBInflatedFrame); */

    // ID 6 used to be "always sort", this has been raised to 9
    // ID 7 used to be "default sort", this has been raised to 10
    // V0.9.7 (2000-12-18) [umoeller]

    if (_pDefaultDocument)  // V0.9.4 (2000-06-09) [umoeller]
    {
        CHAR szDefaultDoc[CCHMAXPATH];
        _wpQueryFilename(_pDefaultDocument, szDefaultDoc, FALSE);   // not qualified
        _wpSaveString(somSelf, (PSZ)G_pcszXFolder, 8, szDefaultDoc);
    }

    #ifdef DEBUG_SORT
        _Pmpf((__FUNCTION__ " for %s: _bAlwaysSortInstance is %d",
                _wpQueryTitle(somSelf), _bAlwaysSort));
    #endif
    // if (_bAlwaysSort != SET_DEFAULT)
        // wrong, we must always store this, or default sort settings
        // won't work V0.9.7 (2000-12-18) [umoeller]
        // also raised ID from 6 to 9
        _wpSaveLong(somSelf, (PSZ)G_pcszXFolder, 9, (ULONG)_bAlwaysSort);
    // if (_bDefaultSort != SET_DEFAULT)
        // also raised ID from 7 to 10
        _wpSaveLong(somSelf, (PSZ)G_pcszXFolder, 10, (ULONG)_bDefaultSort);


    brc = XFolder_parent_WPFolder_wpSaveState(somSelf);

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("%s: End of wpSaveState", _wpQueryTitle(somSelf)));
    #endif

    return (brc);
}

/*
 *@@ wpRestoreState:
 *      this WPObject instance method gets called during object
 *      initialization (after wpInitData) to restore the data
 *      which was stored with wpSaveState.
 *
 *@@changed V0.9.4 (2000-06-09) [umoeller]: added default document
 *@@changed V0.9.4 (2000-08-02) [umoeller]: added "keep title" instance setting
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreState(XFolder *somSelf,
                                             ULONG ulReserved)
{
    ULONG   ul;
    BOOL    brc;
    CHAR    szDefaultDoc[CCHMAXPATH];
    ULONG   cbDefaultDoc = sizeof(szDefaultDoc);

    XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpRestoreState");

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpRestoreState for %s", _wpQueryTitle(somSelf) ));
    #endif

    // we will now restore all the different XFolder settings
    // into the instance data; note that if _wpRestoreLong
    // returns FALSE (i.e. setting not found), we always use
    // the "transparent" value which makes this folder use
    // the corresponding Global Setting

    if (_wpRestoreLong(somSelf, (PSZ)G_pcszXFolder, 1, &ul))
        _bSnapToGridInstance = (BYTE)ul;
    else _bSnapToGridInstance = 2;

    if (_wpRestoreLong(somSelf, (PSZ)G_pcszXFolder, 2, &ul))
        _bFullPathInstance = (BYTE)ul;
    else _bFullPathInstance = 2;

    if (_wpRestoreLong(somSelf, (PSZ)G_pcszXFolder, 3, &ul))
        _bFolderHotkeysInstance = (BYTE)ul;
    else _bFolderHotkeysInstance = 2;

    if (_wpRestoreLong(somSelf, (PSZ)G_pcszXFolder, 4, &ul))
        _bStatusBarInstance = (BYTE)ul;
    else _bStatusBarInstance = STATUSBAR_DEFAULT;

    /* if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 5, &ul))
        _ulSBInflatedFrame = (BYTE)ul;
    else _ulSBInflatedFrame = 0; */

    // ID 6 used to be "always sort", this has been raised to 9
    // ID 7 used to be "default sort", this has been raised to 10
    // V0.9.7 (2000-12-18) [umoeller]

    if (_wpRestoreString(somSelf, (PSZ)G_pcszXFolder, 8, szDefaultDoc, &cbDefaultDoc))
    {
        // store file name in instance data; wpObjectReady will then
        // find the file, which doesn't work when the folder isn't fully initialized.
        _pszDefaultDocDeferred = strdup(szDefaultDoc);
    }

    // changed ID from 6 to 9 -- V0.9.7 (2000-12-18) [umoeller]
    if (_wpRestoreLong(somSelf, (PSZ)G_pcszXFolder, 9, &ul))
    {
        _bAlwaysSort = (USHORT)ul;
        _fXFolderSortSettingRestored = TRUE; // V0.9.7 (2000-12-18) [umoeller]

    }
    else
        // setting not found:
        if (_somIsA(somSelf, _WPDesktop))
            // otherwise we might automatically sort the desktop...
            // not really what we want!
            _bAlwaysSort = FALSE;

    #ifdef DEBUG_SORT
        _Pmpf((__FUNCTION__ " for %s: _bAlwaysSortInstance is %d",
                _wpQueryTitle(somSelf), _bAlwaysSort));
    #endif

    // changed ID from 7 to 10 -- V0.9.7 (2000-12-18) [umoeller]
    if (_wpRestoreLong(somSelf, (PSZ)G_pcszXFolder, 10, &ul))
        _bDefaultSort = (USHORT)ul;

    // in this case, we MUST call the parent LAST because
    // wpRestoreData checks for whether an XFolder sort setting
    // has been restored!!
    brc = (XFolder_parent_WPFolder_wpRestoreState(somSelf, ulReserved));

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("  End of XFolder::wpRestoreState"));
    #endif

    return (brc);
}

/*
 *@@ wpRestoreLong:
 *      this instance method restores a 32-bit data
 *      value from the folder EAs upon object awakening.
 *
 *      We check the "ulKey" value after having called
 *      the parent to be able to intercept the pointer
 *      to certain WPS-internal folder data, which
 *      we cannot access otherwise. That's a real ugly
 *      kludge, but there's no other way to get certain
 *      folder settings. ;-)
 *
 *      On Warp 4, the WPS queries the
 *      IDKEY_FDRTREEVIEWCONTENTS key here, which is
 *      == 1 if the "SHOWALLINTREEVIEW" flag is on.
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreLong(XFolder *somSelf, PSZ pszClass,
                                         ULONG ulKey, PULONG pulValue)
{
    BOOL        brc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpRestoreLong");

    brc = XFolder_parent_WPFolder_wpRestoreLong(somSelf, pszClass,
                                                ulKey, pulValue);

    if (strcmp(pszClass, "WPFolder") == 0)
    {
        switch (ulKey)
        {
            // Warp 4
            #ifndef IDKEY_FDRTREEVIEWCONTENTS
                #define IDKEY_FDRTREEVIEWCONTENTS 2939
            #endif

            case IDKEY_FDRTREEVIEWCONTENTS:
            {
                // then the pointer given to this method (pValue) must
                // be the pointer to the WPFolder-internal SHOWALLINTREEVIEW
                // flag
                if (pulValue)
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _pulFolderShowAllInTreeView = pulValue;
                }
            break; }
        }
    }

    #ifdef DEBUG_RESTOREDATA
        if ((pulValue) && (brc))
            _Pmpf(("Long %s (%s %d) --> 0x%lX",
                   wpshIdentifyRestoreID(pszClass, ulKey),
                   pszClass, ulKey,
                   *pulValue));        // data returned
    #endif

    return (brc);
}

/*
 *@@ wpRestoreString:
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreString(XFolder *somSelf,
                                           PSZ pszClass, ULONG ulKey,
                                           PSZ pszValue, PULONG pcbValue)
{
    BOOL brc = FALSE;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpRestoreString");

    brc = XFolder_parent_WPFolder_wpRestoreString(somSelf,
                                                  pszClass, ulKey,
                                                  pszValue, pcbValue);

    if (strcmp(pszClass, "WPFolder") == 0)
    {
        switch (ulKey)
        {
            case IDKEY_FDRBKGNDIMAGEFILE: // 2934
                if ((pszValue) && (brc))
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _pszFolderBkgndImageFile = strdup(pszValue);   // freed in uninitdata
                }
            break;
        }
    }

    #ifdef DEBUG_RESTOREDATA
        if ((pszValue) && (brc))
            _Pmpf(("Strg %s (%s %d) --> %s",
                   wpshIdentifyRestoreID(pszClass, ulKey),
                   pszClass, ulKey,
                   pszValue));        // data returned
    #endif

    return (brc);
}

/*
 *@@ wpRestoreData:
 *      this instance method restores binary instance
 *      data from the folder EAs upon object awakening.
 *      We check the "ulKey" value after having called
 *      the parent to be able to intercept the pointer
 *      to certain WPS-internal folder data, which
 *      we cannot access otherwise. That's a real ugly
 *      kludge, but there's no other way to get certain
 *      folder settings. ;-)
 *
 *      On Warp 4, the WPS queries lots of sort and
 *      folder view settings here, whose pointers we
 *      can store in XFolder's instance data.
 *
 *@@changed V0.9.7 (2000-12-18) [umoeller]: fixed always sort bug
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreData(XFolder *somSelf,
                                         PSZ pszClass, ULONG ulKey,
                                         PBYTE pValue, PULONG pcbValue)
{
    BOOL        brc;
    ULONG       cbOrigValue = 0;
    // XFolderMethodDebug("XFolder","xf_wpRestoreData");

    // get the size of the buffer which was given to us
    if (pValue)
        // pValue given:
        cbOrigValue = *pcbValue;
    // else: caller is requesting the size of the data

    // always call parent, even for the sort data, or
    // the WPFolder original gets confused
    brc = XFolder_parent_WPFolder_wpRestoreData(somSelf,
                                                pszClass, ulKey,
                                                pValue, pcbValue);

    // after we have restored the setting by calling the
    // default WPFolder method, we check for a few flags
    // which we might be interested in; we can then store
    // the pointer to WPS-internal data in XFolder instance
    // data
    if (strcmp(pszClass, "WPFolder") == 0)
    {
        switch (ulKey)
        {
            case IDKEY_FDRSORTINFO:
            {
                // then the pointer given to this method (pValue) must
                // be the pointer to the WPFolder-internal FDRSORTINFO
                // structure (undocumented, I've declared it in
                // xfldr.idl); we store this pointer in the instance
                // data so that we can manipulate it later
                if (cbOrigValue == sizeof(FDRSORTINFO))
                {
                    if (pValue)
                    {
                        XFolderData *somThis = XFolderGetData(somSelf);
                        _pFolderSortInfo = (PFDRSORTINFO)pValue;

                        // if the parent method has found sort data,
                        // and the user had set "Always sort" on for
                        // the folder using the regular WPS "Sort" page,
                        // we need to update the XFolder sort data, but
                        // only update this if this hasn't been set
                        // by wpRestoreState yet; as a result, the
                        // XFolder sort settings will follow the WPFolder
                        // sort settings, but can be overridden
                        // fixed this with V0.9.7 (2000-12-18) [umoeller]

                        // setting loaded successfully by parent?
                        /* if (brc)
                            // yes: did we have an XFolder setting already
                            // (this is set by wpRestoreData)?
                            if (!_fXFolderSortSettingRestored)
                                // no: is "always sort" enabled?
                                if (((PFDRSORTINFO)pValue)->fAlwaysSort)
                                {
                                    // yes: copy that
                                    _Pmpf((__FUNCTION__ " for %s: hacking _bAlwaysSort to 1",
                                                _wpQueryTitle(somSelf)));
                                    _bAlwaysSort = 1;
                                }
                                // if (_bAlwaysSort == SET_DEFAULT)
                                // _bAlwaysSort = ((PFDRSORTINFO)pValue)->fAlwaysSort;
                        */
                    }
                }
                // _Pmpf(("IDKEY_FDRSORTINFO size %d -> %d", cbOrigValue, *pcbValue));
            break; }

            case IDKEY_FDRBACKGROUND:       // size: 2 bytes
                if (pValue)
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _cbFolderBackground = *pcbValue;
                    _pFolderBackground = (PVOID)pValue;
                }
            break;

            /* case IDKEY_FDRCNRBACKGROUND:
                _Pmpf(("%s::wpRestoreString: IDKEY_FDRCNRBACKGROUND -> %d",
                       _wpQueryTitle(somSelf),
                       brc));
                if (pValue)
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _cbFdrCnrBackground = *pcbValue;
                    _pszFdrCnrBackground = pValue;     // buffer
                }
            break; */

            case IDKEY_FDRLONGARRAY:        // size: 84 bytes
            {
                XFolderData *somThis = XFolderGetData(somSelf);
                // store the size of the data returned in
                // folder instance data, in case it is not
                // 84 bytes (as it is with Warp 4 fixpak 8)
                _cbFolderLongArray = *pcbValue;
                if (pValue)
                    _pFolderLongArray = (PFDRLONGARRAY)pValue;
            break; }

            case IDKEY_FDRSTRARRAY:         // size: 400 bytes
            {
                XFolderData *somThis = XFolderGetData(somSelf);
                // store the size of the data returned in
                // folder instance data, in case it is not
                // 400 bytes (as it is with Warp 4 fixpak 8)
                if (pValue)
                {
                    _cbFolderStrArray = *pcbValue;
                    _pszFolderStrArray = (PSZ)pValue;
                }
            break; }

            /* case IDKEY_CNRBACKGROUND:
            {
                XFolderData *somThis = XFolderGetData(somSelf);
                if (pValue)
                {
                    _cbCnrBackground = *pcbValue;
                    _pvCnrBackground = pValue;
                }
            break; } */

            /*
             * the following others were queried for G:\root\test
             * under Warp 4 fixpak 8:
             */

            /*
                IDKEY_xxx (WPObject 11) size 32 -> 32           WPOBJECT_DATA
                IDKEY_xxx (WPObject 12) size 400 -> 400         WPOBJECT_STRINGS
                IDKEY_xxx (WPObject 4) size 8 -> 8              ?!?
                IDKEY_xxx (WPFolder 2924) size 542 -> 542       IDKEY_CNRBACKGROUND
                IDKEY_xxx (WPFolder 2920) size 542 -> 542       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 542 -> 542       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2938) size 8 -> 8           IDKEY_FDRGRIDINFO

            and these under Warp 3, no fixpaks:
                IDKEY_xxx (WPObject 11) size 28 -> 28           (+) four bytes less
                IDKEY_xxx (WPObject 12) size 400 -> 400         (+)
                IDKEY_xxx (WPObject 4) size 8 -> 8              (+)
                IDKEY_xxx (WPFolder 2924) size 542 -> 542       (+)
                IDKEY_xxx (WPFolder 2920) size 542 -> 542       (+)
                IDKEY_xxx (WPFolder 2925) size 542 -> 542       (+)
                i.e. the same, except the grid info

            but if we had a folder background set (Warp 4):
                IDKEY_xxx (WPObject 11) size 32 -> 32
                IDKEY_xxx (WPObject 12) size 400 -> 400
                IDKEY_xxx (WPObject 4) size 8 -> 8
                IDKEY_xxx (WPFolder 2924) size 542 -> 542       IDKEY_CNRBACKGROUND
                IDKEY_xxx (WPFolder 2920) size 542 -> 542       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 542 -> 107       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2920) size 260 -> 260       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 260 -> 107       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2925) size 107 -> 107       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2938) size 8 -> 8
            and on Warp 3:
                IDKEY_xxx (WPObject 11) size 28 -> 28
                IDKEY_xxx (WPObject 12) size 400 -> 400
                IDKEY_xxx (WPObject 4) size 8 -> 8
                                                            no  IDKEY_CNRBACKGROUND
                IDKEY_xxx (WPFolder 2920) size 259 -> 259       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 259 -> 178       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2920) size 260 -> 260       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 260 -> 178       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2925) size 178 -> 178       IDKEY_FDRINCCRITERIA

            */

            /* this is what we got from the "Programme" folder (Warp 4):

                 Long IDKEY_xxx (WPFileSystem 4) --> 0x0
                 Data IDKEY_xxx (WPObject 11) size 32 -> 32         WPOBJECT_DATA
                 Data IDKEY_xxx (WPObject 12) size 400 -> 400       WPOBJECT_STRINGS
                 Data IDKEY_xxx (WPObject 4) size 8 -> 8            ?!?
                 Data IDKEY_xxx (WPFolder 2924) size 542 -> 542     IDKEY_CNRBACKGROUND
                 Strg IDKEY_xxx (WPFolder 2921) --> NULL            IDKEY_FDRINCNAME
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 542       IDKEY_FDRINCCLASS
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107       IDKEY_FDRINCCRITERIA
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 260       * IDKEY_FDRINCCLASS
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107       * IDKEY_FDRINCCRITERIA
                 Data IDKEY_xxx (WPFolder 2925) size 107 -> 107     * IDKEY_FDRINCCRITERIA
                 Strg IDKEY_xxx (WPFolder 2921) -->                 * IDKEY_FDRINCNAME
                 Data IDKEY_xxx (WPFolder 2938) size 8 -> 8         IDKEY_FDRGRIDINFO
                 Long IDKEY_xxx (WPFolder 2939) --> 0x0             IDKEY_FDRTREEVIEWCONTENTS

                 Long IDKEY_xxx (WPFileSystem 4) --> 0x0
                 Data IDKEY_xxx (WPObject 11) size 32 -> 32
                 Data IDKEY_xxx (WPObject 12) size 400 -> 400
                 Data IDKEY_xxx (WPObject 4) size 8 -> 8
                 Strg IDKEY_xxx (WPFolder 2934) --> F:\OS2\BITMAP\PLASTER.BMP
                                                                    IDKEY_FDRCNRBACKGROUND
                 Strg IDKEY_xxx (WPFolder 2921) --> NULL
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 259
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 260
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107
                 Data IDKEY_xxx (WPFolder 2925) size 107 -> 107
                 Strg IDKEY_xxx (WPFolder 2921) --> F:\OS2\BITMAP\PLASTER.BMP
                                                                    IDKEY_FDRCNRBACKGROUND
                 Data IDKEY_xxx (WPFolder 2938) size 8 -> 8
                 Long IDKEY_xxx (WPFolder 2939) --> 0x0             IDKEY_FDRTREEVIEWCONTENTS

            */

            /*
             *  the following are apperently never queried
             *  (Warp 4 FP 8 German):
             */

            /*
                case IDKEY_FDRSORTATTRIBS:
                case IDKEY_FDRSORTCLASS:
                case IDKEY_FDRINVISCOLUMNS:
                case IDKEY_FDRCONTENTATTR:
                case IDKEY_FDRSNEAKYCOUNT:
                case IDKEY_FDRCNRBACKGROUND:
                case IDKEY_FDRBKGNDIMAGEFILE:
            */


        }   // end switch
    }

    #ifdef DEBUG_RESTOREDATA
        if ((pValue) && (brc))
            _Pmpf(("Data %s (%s %d) size_in %d -> out %d",
                    wpshIdentifyRestoreID(pszClass, ulKey),
                    pszClass, ulKey,
                    cbOrigValue,    // size in or 0 if size queried
                    *pcbValue));    // size out
    #endif

    return (brc);
}

/*
 *@@ wpFilterPopupMenu:
 *      this WPObject instance method allows the object to
 *      filter out unwanted menu items from the context menu.
 *      This gets called before wpModifyPopupMenu.
 *
 *      This removes default menu entries according to the
 *      global menu settings.
 *
 *@@changed V0.9.5 (2000-09-20) [pr]: fixed context menu flags
 */

SOM_Scope ULONG  SOMLINK xf_wpFilterPopupMenu(XFolder *somSelf,
                                                 ULONG ulFlags,
                                                 HWND hwndCnr,
                                                 BOOL fMultiSelect)
{
    ULONG ulMenuFilter = 0;
    // XFolderData *somThis = XFolderGetData(somSelf);
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFolderMethodDebug("XFolder","xf_wpFilterPopupMenu");

    ulMenuFilter = XFolder_parent_WPFolder_wpFilterPopupMenu(somSelf,
                                                             ulFlags,
                                                             hwndCnr,
                                                             fMultiSelect);
    #ifdef DEBUG_MENUS
        _Pmpf(("XFolder::wpFilterPopupMenu parent flags:"));
        _Pmpf(("  CTXT_CRANOTHER %d", ulMenuFilter & CTXT_CRANOTHER));
    #endif

    // if object has been deleted already (ie. is in trashcan),
    // remove delete
    if (_xwpQueryDeletion(somSelf, NULL, NULL))
        ulMenuFilter &= ~CTXT_DELETE; // V0.9.5 (2000-09-20) [pr]

    // now suppress default menu items according to
    // Global Settings;
    // the DefaultMenuItems field in pGlobalSettings is
    // ready-made for this function; the "Workplace Shell"
    // notebook page for removing menu items sets this field with
    // the proper CTXT_xxx flags
    return ((ulMenuFilter)
            & ~(pGlobalSettings->DefaultMenuItems)
        );
}

/*
 *@@ wpModifyPopupMenu:
 *      this WPObject instance methods gets called by the WPS
 *      when a context menu needs to be built for the object
 *      and allows the object to manipulate its context menu.
 *      This gets called _after_ wpFilterPopupMenu.
 *
 *      We add the various XFolder menu entries here
 *      by calling the common XFolder function in fdrmenus.c,
 *      which is also used by the XFldDisk class.
 */

SOM_Scope BOOL  SOMLINK xf_wpModifyPopupMenu(XFolder   *somSelf,
                                             HWND  hwndMenu,
                                             HWND  hwndCnr,
                                             ULONG iPosition)
{
    BOOL                rc = TRUE;
    HWND                hwndCnr2 = hwndCnr;

    XFolderData *somThis = XFolderGetData(somSelf);

    /* _Pmpf(("wpModifyPopupMenu cbFldrLongArray: %d", _cbFldrLongArray));
    _Pmpf(("  somThis for %s: 0x%lX", _wpQueryTitle(somSelf), somThis)); */

    XFolderMethodDebug("XFolder","xf_wpModifyPopupMenu");

    // call parent
    XFolder_parent_WPFolder_wpModifyPopupMenu(somSelf, hwndMenu, hwndCnr, iPosition);

    // _Pmpf(("wpModifyPopupMenu cbFldrLongArray: %d", _cbFldrLongArray));

    if (hwndCnr == NULLHANDLE)
    {
        // bug in Warp 3: if the popup menu is requested
        // on container whitespace, hwndCnr is passed as
        // NULLHANDLE; we therefore use this ugly
        // workaround
        hwndCnr2 = _hwndCnrSaved;   // set by WM_INITMENU in fdr_fnwpSubclassedFolderFrame
    }

    // call menu manipulator common to XFolder and XFldDisk (fdrmenus.c)
    rc = mnuModifyFolderPopupMenu(somSelf,
                                  hwndMenu,
                                  hwndCnr2,
                                  iPosition);

    if (rc)
        fdrAddHotkeysToMenu(somSelf,
                            hwndCnr,
                            hwndMenu);

    return (rc);
}

/*
 *@@ wpMenuItemSelected:
 *      this WPObject method processes menu selections.
 *      This must be overridden to support new menu
 *      items which have been added in wpModifyPopupMenu.
 *      See XFldObject::wpMenuItemSelected for additional
 *      information and how to intercept this for multiple
 *      objects.
 *
 *      We pass the input to mnuMenuItemSelected in fdrmenus.c
 *      because disk menu items are mostly shared with XFldDisk.
 */

SOM_Scope BOOL  SOMLINK xf_wpMenuItemSelected(XFolder *somSelf,
                                                 HWND hwndFrame,
                                                 ULONG ulMenuId)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpMenuItemSelected");

    // call the menu item checker common to XFolder and XFldDisk
    // (fdrmenus.c); this returns TRUE if one of the manipulated
    // menu items was selected
    if (mnuMenuItemSelected(somSelf, hwndFrame, ulMenuId))
        return (TRUE);
    else
        // none of our menu items: pass on to parent
        return (XFolder_parent_WPFolder_wpMenuItemSelected(somSelf, hwndFrame, ulMenuId));
}

/*
 *@@ wpMenuItemHelpSelected:
 *      display help for a context menu item.
 */

SOM_Scope BOOL  SOMLINK xf_wpMenuItemHelpSelected(XFolder *somSelf,
                                                     ULONG MenuId)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpMenuItemHelpSelected");

    // call the common help processor in fdrmenus.c;
    // if this returns TRUE, help was requested for one
    // of the new menu items
    if (mnuMenuItemHelpSelected(somSelf, MenuId))
        return TRUE;
    else
        // else: none of our menu items, call default
        return (XFolder_parent_WPFolder_wpMenuItemHelpSelected(somSelf,
                                                               MenuId));
}

/*
 *@@ wpQueryDefaultView:
 *      this WPObject method returns the default view of an object,
 *      that is, which view is opened if the program file is
 *      double-clicked upon. This is also used to mark
 *      the default view in the "Open" context submenu.
 *
 *      We change the folder's default view to "open default document"
 *      if this has been enabled in "Workplace Shell" and a
 *      default document exists.
 *
 *@@added V0.9.4 (2000-06-09) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpQueryDefaultView(XFolder *somSelf)
{
    ULONG   ulDefaultView = 0;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();

    XFolderMethodDebug("XFolder","xf_wpQueryDefaultView");

    if (    (_wpIsObjectInitialized(somSelf))    // wpPopulate hangs otherwise
         && (!_somIsA(somSelf, _WPDesktop))
       )
    {
        if (    (pGlobalSettings->fFdrDefaultDoc)
             && (pGlobalSettings->fFdrDefaultDocView)
           )
        {
            // XFolderData *somThis = XFolderGetData(somSelf);
            WPFileSystem *pDefaultDoc = _xwpQueryDefaultDocument(somSelf);
            if (pDefaultDoc)
                // we have a default document for this folder:
                // change default view to menu item ID of "open default document"
                // (same as in mnuModifyDataFilePopupMenu)
                ulDefaultView = pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_FDRDEFAULTDOC;
        }
    }

    if (!ulDefaultView)
        // call parent:
        ulDefaultView = XFolder_parent_WPFolder_wpQueryDefaultView(somSelf);

    return (ulDefaultView);
}

/*
 *@@ wpQueryDefaultHelp:
 *      this WPObject instance method specifies the default
 *      help panel for an object (when "Extended help" is
 *      selected from the object's context menu). This should
 *      describe what this object can do in general.
 *      We must return TRUE to report successful completion.
 *
 *      XFolder will return something different for the
 *      Config folder and its subfolders.
 */

SOM_Scope BOOL  SOMLINK xf_wpQueryDefaultHelp(XFolder *somSelf,
                                              PULONG pHelpPanelId,
                                              PSZ HelpLibrary)
{
    BOOL        rc;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpQueryDefaultHelp");

    if (    (pCfg)
         && (wpshResidesBelow(somSelf, pCfg))
       )
    {
        // somSelf is in the config folder hierarchy:
        // display help for config folders
        strncpy(HelpLibrary, cmnQueryHelpLibrary(), CCHMAXPATH);
        *pHelpPanelId = ID_XMH_CONFIGFOLDER;
        rc = TRUE;
    }
    else
        rc = (XFolder_parent_WPFolder_wpQueryDefaultHelp(somSelf,
                                                           pHelpPanelId,
                                                           HelpLibrary));

    return (rc);
}

/*
 *@@ wpOpen:
 *      this WPObject instance method gets called when
 *      a new view needs to be opened. Normally, this
 *      gets called after wpViewObject has scanned the
 *      object's USEITEMs and has determined that a new
 *      view is needed.
 *
 *      This _normally_ runs on thread 1 of the WPS, but
 *      this is not always the case. If this gets called
 *      in response to a menu selection from the "Open"
 *      submenu or a double-click in the folder, this runs
 *      on the thread of the folder (which _normally_ is
 *      thread 1). However, if this results from WinOpenObject
 *      or an OPEN setup string, this will not be on thread 1.
 *
 *      This is one of the main hooks where the XFolder
 *      features are inserted into the WPS.
 *      We call the parent method first (which will create
 *      the folder window) and then subclass the
 *      resulting frame window with the new
 *      fdr_fnwpSubclassedFolderFrame window procedure.
 *
 *@@changed V0.9.2 (2000-03-04) [umoeller]: fixed work-area hangs
 *@@changed V0.9.4 (2000-06-09) [umoeller]: added default documents
 */

SOM_Scope HWND  SOMLINK xf_wpOpen(XFolder *somSelf,
                                  HWND hwndCnr,
                                  ULONG ulView,
                                  ULONG param)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    HWND        hwndNewFrame; // return HWND
    BOOL        fOpenDefaultDoc = FALSE;

    // XFolderMethodDebug("XFolder","xf_wpOpen");
    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpOpen for 0x%lX (%s): ulView = 0x%lX, param = 0x%lX",
                    somSelf,
                    _wpQueryTitle(somSelf),
                    ulView,
                    param));
    #endif

    // default document support
    if (ulView == OPEN_DEFAULT)
    {
        if (    (pGlobalSettings->fFdrDefaultDoc)
             && (pGlobalSettings->fFdrDefaultDocView)
             && (!_somIsA(somSelf, _WPDesktop))
           )
        {
            fOpenDefaultDoc = TRUE;
        }
    }
    else if (ulView == (pGlobalSettings->VarMenuOffset + ID_XFMI_OFS_FDRDEFAULTDOC))
        fOpenDefaultDoc = TRUE;

    if (fOpenDefaultDoc)
    {
        WPFileSystem *pDefaultDoc = _xwpQueryDefaultDocument(somSelf);
        if (pDefaultDoc)
            _wpViewObject(pDefaultDoc, NULLHANDLE, OPEN_DEFAULT, 0);
    }
    else
    {
        // not default document:
        TRY_LOUD(excpt1)
        {
            // request object mutex;
            // parent_wpOpen starts the Populate thread, and we
            // don't want that one to start until we are done
            // with our folder manipulations
            /* fFolderLocked = !_wpRequestObjectMutexSem(somSelf, 5000);
            if (fFolderLocked) */
            // V0.9.2 (2000-03-04) [umoeller]: no, don't do this, this
            // prevents work areas from re-opening

            // have parent do the window creation
            hwndNewFrame = XFolder_parent_WPFolder_wpOpen(somSelf,
                                                          hwndCnr,
                                                          ulView,
                                                          param);

            if (   (ulView == OPEN_CONTENTS)
                || (ulView == OPEN_TREE)
                || (ulView == OPEN_DETAILS)
               )
            {
                fdrManipulateNewView(somSelf,
                                     hwndNewFrame,
                                     ulView);
            }
        }
        CATCH(excpt1) { } END_CATCH();

        /* if (fFolderLocked)
            _wpReleaseObjectMutexSem(somSelf); */
                    // this will unblock the Populate thread

    }

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("End of XFolder::wpOpen for %s: hwndFrame = 0x%lX",
                    _wpQueryTitle(somSelf),
                    hwndNewFrame));
    #endif

    return (hwndNewFrame);
}

/*
 *@@ wpPopulate:
 *      this instance method populates a folder. This normally
 *      runs on the Populate thread, of which I am unsure if it
 *      recreated every time a folder is opened or if there's
 *      only one Populate thread which is shared by all folders.
 *      This may also run on thread 1 if populating occurs
 *      synchronously (as with the XFolder folder content menus).
 *
 *      Interestingly, from my debugging, the Populate thread is
 *      started right after WPFolder::wpOpen is called, even before
 *      the folder window is created. Kinda sick, in my view. I
 *      get the following order:
 *
 *      1)  wpPopulate;
 *      2)
 */

SOM_Scope BOOL  SOMLINK xf_wpPopulate(XFolder *somSelf, ULONG ulReserved,
                                      PSZ pszPath, BOOL fFoldersOnly)
{
    BOOL brc = FALSE;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpPopulate");
    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpPopulate for %s", _wpQueryTitle(somSelf) ));
    #endif

    brc = XFolder_parent_WPFolder_wpPopulate(somSelf, ulReserved,
                                               pszPath, fFoldersOnly);

    /*
        apparently, wpPopulate calls the following methods
        (in this order):

        --  wpQueryFldrFlags
        --  wpSetFldrFlags      0x400 (FOI_POPULATEINPROGRESS)
        --  wpQueryFldrFlags

        Then we have more calls on thread 1:

        --  wpclsNew, creating an instance of WPFolderCV (whatever that
                               class is good for);

        --  then we get a WM_CREATE for the folder window;

        --  then we get a wpRegisterView;

        --  wpSetFldrFlags      0x58408
                                    (0x0010000  FOI_CHANGEICONTEXTCOLOR
                                     0x0040000  FOI_CHANGESHADOWTEXTCOLOR (Warp 4 only)
                                     0x0008000  FOI_CHANGEICONBGNDCOLOR
                                     0x0000400  FOI_POPULATEINPROGRESS
                                     0x0000008  FOI_CHANGEFONT
                                    )
        --  and some more, but always with FOI_POPULATEINPROGRESS set

        --  then wpOpen returns.

        Then we have the Populate thread again

        --  wpclsMakeAwake, for all the objects in the folder,
            which apparently calls
            --  WPFolder::wpAddToContent
            --  WPObject::wpObjectReady (on the Populate thread! Obviously, the object
                               is created here)
        --  wpclsInitData, wpQueryStyle, wpRestoreState, ...

        --  In between, we get wpQueryFldrFlags from thread 1 again, querying if
            the populate is still in progress. I guess this is from my status bar
            timers.

        --  wpSetFldrFlags      0x402
                                    (0x00000400  FOI_POPULATEINPROGRESS
                                     0x00000002  FOI_POPULATEDWITHFOLDERS
                                    )
        --  wpSetFldrFlags      0x003
                                    (0x00000001  FOI_POPULATEDWITHALL
                                     0x00000002  FOI_POPULATEDWITHFOLDERS
                                    )

        End of wpPopulate; returning 1
    */

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("End of wpPopulate for %s --> %d",
                    _wpQueryTitle(somSelf),
                    brc));
    #endif
    return (brc);
}

/*
 *@@ wpRefresh:
 *      this method updates a folder; after doing
 *      this, we will also update the title of the
 *      window and maybe status bars.
 *
 *      Note that this method normally does _not_
 *      get called on thread 1, but some other thread,
 *      so this better be thread-safe.
 */

SOM_Scope BOOL  SOMLINK xf_wpRefresh(XFolder *somSelf, ULONG ulView,
                                        PVOID pReserved)
{
    BOOL        rc;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpRefresh");

    rc = XFolder_parent_WPFolder_wpRefresh(somSelf, ulView, pReserved);

    fdrForEachOpenInstanceView(somSelf,
                              (ULONG)2,           // update
                              (PFNWP)fncbUpdateStatusBars);

    xthrPostWorkerMsg(WOM_REFRESHFOLDERVIEWS, (MPARAM)somSelf, MPNULL);

    return rc;
}

/*
 *@@ wpAddObjectGeneralPage2:
 *      this WPObject instance method adds the "Animation icon"
 *      page to an object's settings notebook.
 *      For folders, we'll insert the object's "Internals" page
 *      here (now called "Object" page).
 *
 *      For folders, this is not done by XFldObject::wpAddObjectGeneralPage
 *      because otherwise the "Object" page would be between
 *      the two icon pages.
 *
 *@@added V0.9.2 (2000-02-27) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpAddObjectGeneralPage2(XFolder *somSelf,
                                                    HWND hwndNotebook)
{
    PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddObjectGeneralPage2");

    if (pGlobalSettings->AddObjectPage)
        _xwpAddObjectInternalsPage(somSelf, hwndNotebook);

    return (XFolder_parent_WPFolder_wpAddObjectGeneralPage2(somSelf,
                                                            hwndNotebook));
}

/*
 *@@ wpAddFile1Page:
 *      this normally adds the first "File" page to
 *      the file's settings notebook; if allowed,
 *      we will replace this with our own version,
 *      which combines the three "File" pages into
 *      one single page.
 *
 *      We cannot override this in XWPFileSystem because
 *      WPFolder overrides this too.
 *
 *@@added V0.9.0
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFile1Page(XFolder *somSelf,
                                           HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFile1Page");

    if (pGlobalSettings->fReplaceFilePage)
    {
        return (fsysInsertFilePages(somSelf,
                                    hwndNotebook));
    }
    else
        return (XFolder_parent_WPFolder_wpAddFile1Page(somSelf, hwndNotebook));
}

/*
 *@@ wpAddFile2Page:
 *      this normally adds the second "File" page to
 *      the file's settings notebook; since we
 *      combine the three "File" pages into one,
 *      we'll remove this page, if allowed.
 *
 *      We cannot override this in XWPFileSystem because
 *      WPFolder overrides this too.
 *
 *@@added V0.9.0
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFile2Page(XFolder *somSelf,
                                           HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFile2Page");

    if (pGlobalSettings->fReplaceFilePage)
        return (SETTINGS_PAGE_REMOVED);
    else
        return (XFolder_parent_WPFolder_wpAddFile2Page(somSelf, hwndNotebook));
}

/*
 *@@ wpAddFile3Page:
 *      this normally adds the second "File" page to
 *      the file's settings notebook; since we
 *      combine the three "File" pages into one,
 *      we'll remove this page, if allowed.
 *
 *      We cannot override this in XWPFileSystem because
 *      WPFolder overrides this too.
 *
 *@@added V0.9.0
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFile3Page(XFolder *somSelf,
                                           HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFile3Page");

    if (pGlobalSettings->fReplaceFilePage)
        return (SETTINGS_PAGE_REMOVED);
    else
        return (XFolder_parent_WPFolder_wpAddFile3Page(somSelf, hwndNotebook));
}

/*
 *@@ wpAddFolderBackgroundPage:
 *      this normally adds the  "Background" page to
 *      the folder's settings notebook. We now use
 *      this method to add the "XFolder" page right
 *      before that by calling XFolder::xwpAddXFolderPages.
 *
 *      This has been changed with V0.9.0 so that the
 *      "XFolder" page no longer sits at the front of
 *      the settings notebook, but together with the
 *      other folder settings pages.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFolderBackgroundPage(XFolder *somSelf,
                                                      HWND hwndNotebook)
{
    BOOL    brc;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFolderBackgroundPage");

    brc = XFolder_parent_WPFolder_wpAddFolderBackgroundPage(somSelf,
                                                            hwndNotebook);
    if (brc)
        _xwpAddXFolderPages(somSelf, hwndNotebook);

    return (brc);
}

/*
 *@@ wpAddFolderSortPage:
 *      this normally adds the "Sort" page to the folder
 *      settings notebook; if allowed, we will replace this
 *      by the new XFolder version of it.
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFolderSortPage(XFolder *somSelf,
                                                   HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFolderSortPage");

    if (pGlobalSettings->ExtFolderSort)
    {
        // extended sorting enabled:
        // check whether the "sort class" of the folder
        // is WPFileSystem (which is the default); only
        // then replace the "Sort" page with ours. Some
        // WPS extensions define their own Details views,
        // and we don't want to mess with that
        if (_wpQueryFldrSortClass(somSelf) == _WPFileSystem)
        {
            PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
            memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

            pcnbp->somSelf = somSelf;
            pcnbp->hwndNotebook = hwndNotebook;
            pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
            pcnbp->ulDlgID = ID_XSD_SETTINGS_FLDRSORT;
            pcnbp->usPageStyleFlags = BKA_MAJOR;
            pcnbp->pszName = pNLSStrings->pszSort;
            pcnbp->ulDefaultHelpPanel  = ID_XSH_SETTINGS_FLDRSORT;

            // mark this page as "instance", because both
            // the instance settings notebook and the
            // "Workplace Shell" object use the same
            // callbacks
            pcnbp->ulPageID = SP_FLDRSORT_FLDR;

            pcnbp->pfncbInitPage    = fdrSortInitPage;
            pcnbp->pfncbItemChanged = fdrSortItemChanged;

            ntbInsertPage(pcnbp);

            return (SETTINGS_PAGE_REMOVED);
        }
    }

    return (XFolder_parent_WPFolder_wpAddFolderSortPage(somSelf,
                                                        hwndNotebook));
}

/*
 *@@ wpAddSettingsPages:
 *      this WPObject instance method gets called by the WPS
 *      when the Settings view is opened to have all the
 *      settings page inserted into hwndNotebook.
 *
 *      This call xwpAddXFolderPages.
 */

SOM_Scope BOOL  SOMLINK xf_wpAddSettingsPages(XFolder *somSelf,
                                                 HWND hwndNotebook)
{
    BOOL            rc;
    // PAGEINFO        pi;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddSettingsPages");

    rc = (XFolder_parent_WPFolder_wpAddSettingsPages(somSelf,
                                                     hwndNotebook));

    /* if (rc)
        rc = _xwpAddXFolderPages(somSelf, hwndNotebook); */

    return (rc);
}

/*
 *@@ wpSetFldrFlags:
 *      overridden for debugging
 */

SOM_Scope BOOL  SOMLINK xf_wpSetFldrFlags(XFolder *somSelf, ULONG ulFlags)
{
    ULONG brc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpSetFldrFlags");

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpSetFldrFlags for %s: 0x%lX",
               _wpQueryTitle(somSelf),
               ulFlags
               ));
    #endif
    brc = XFolder_parent_WPFolder_wpSetFldrFlags(somSelf, ulFlags);
    return (brc);
}

/*
 *@@ wpQueryFldrFlags:
 *      overridden for debugging
 */

SOM_Scope ULONG  SOMLINK xf_wpQueryFldrFlags(XFolder *somSelf)
{
    ULONG ulFlags;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpQueryFldrFlags");

    ulFlags = XFolder_parent_WPFolder_wpQueryFldrFlags(somSelf);

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpQueryFldrFlags for %s: 0x%lX",
                    _wpQueryTitle(somSelf),
                    ulFlags
                    ));
    #endif
    return (ulFlags);
}

/*
 *@@ wpSetFldrAttr:
 *      this sets new container attributes
 *      (those CV_* flags) for the specified folder view
 *      (OPEN_CONTENTS, OPEN_TREE, OPEN_DETAILS);
 *      overridden for debugging
 */

SOM_Scope BOOL  SOMLINK xf_wpSetFldrAttr(XFolder *somSelf, ULONG Attr,
                                         ULONG ulView)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpSetFldrAttr");

    #ifdef DEBUG_SORT
    {
        CHAR szInfo[300] = "";
        _Pmpf(("wpSetFldrAttr for %s", _wpQueryTitle(somSelf)));
        if (Attr & CV_ICON)
            strcpy(szInfo, "CV_ICON ");
        if (Attr & CV_NAME)
            strcat(szInfo, "CV_NAME ");
        if (Attr & CV_TEXT)
            strcat(szInfo, "CV_TEXT ");
        if (Attr & CV_TREE)
            strcat(szInfo, "CV_TREE ");
        if (Attr & CV_DETAIL)
            strcat(szInfo, "CV_DETAIL ");
        if (Attr & CV_MINI)
            strcat(szInfo, "CV_MINI ");
        if (Attr & CV_FLOW)
            strcat(szInfo, "CV_FLOW ");
        if (Attr & CA_OWNERDRAW)
            strcat(szInfo, "CA_OWNERDRAW ");
        if (Attr & CA_OWNERPAINTBACKGROUND)
            strcat(szInfo, "CA_OWNERPAINTBACKGROUND ");

        _Pmpf(("  Flags: %s", szInfo));
    }
    #endif

    return (XFolder_parent_WPFolder_wpSetFldrAttr(somSelf, Attr,
                                                  ulView));
}

/*
 *@@ wpQueryFldrAttr:
 *      this returns the current container attributes
 *      (those CV_* flags) for the specified folder view
 *      (OPEN_CONTENTS, OPEN_TREE, OPEN_DETAILS);
 *      overridden for debugging
 */

SOM_Scope ULONG  SOMLINK xf_wpQueryFldrAttr(XFolder *somSelf,
                                            ULONG ulView)
{
    ULONG ulAttr = 0;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpQueryFldrAttr");

    ulAttr = XFolder_parent_WPFolder_wpQueryFldrAttr(somSelf,
                                                    ulView);
    #ifdef DEBUG_SORT
    {
        CHAR szInfo[300] = "";
        _Pmpf(("wpQueryFldrAttr for %s", _wpQueryTitle(somSelf)));
        if (ulAttr & CV_ICON)
            strcpy(szInfo, "CV_ICON ");
        if (ulAttr & CV_NAME)
            strcat(szInfo, "CV_NAME ");
        if (ulAttr & CV_TEXT)
            strcat(szInfo, "CV_TEXT ");
        if (ulAttr & CV_TREE)
            strcat(szInfo, "CV_TREE ");
        if (ulAttr & CV_DETAIL)
            strcat(szInfo, "CV_DETAIL ");
        if (ulAttr & CV_MINI)
            strcat(szInfo, "CV_MINI ");
        if (ulAttr & CV_FLOW)
            strcat(szInfo, "CV_FLOW ");
        if (ulAttr & CA_OWNERDRAW)
            strcat(szInfo, "CA_OWNERDRAW ");
        if (ulAttr & CA_OWNERPAINTBACKGROUND)
            strcat(szInfo, "CA_OWNERPAINTBACKGROUND ");

        _Pmpf(("  Flags: %s", szInfo));
    }
    #endif // DEBUG_SORT

    return (ulAttr);
}

/*
 *@@ wpAddToContent:
 *      this WPFolder method is overridden to intercept the
 *      notification of the "Added an object to a folder"
 *      event for subclasses that define their own folder view.
 *
 *      From my testing, the standard WPFolder implementation
 *      appears to call the undocumented WPObject method
 *      wpSetNextObject to maintain the order of objects
 *      in a folder. In addition, this inserts objects into
 *      open container views.
 *
 *      We must replace this method completely to be able
 *      to suppress the automatic adding of objects for
 *      folders. For example, the trash can and the font
 *      folder take a long time on open, and we don't want
 *      each object to be added separately. Instead, we want
 *      all objects to be added in one flush.
 *
 *      So... if XFolder::xwpSetDisableCnrAdd has been called
 *      with the disable flag set, this method will instead
 *      call fdrAddToContent.
 *
 *@@changed V0.9.6 (2000-10-26) [pr]: update status bars
 */

SOM_Scope BOOL  SOMLINK xf_wpAddToContent(XFolder *somSelf,
                                             WPObject* Object)
{
    BOOL brc = FALSE;

    XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpAddToContent");

    #ifdef DEBUG_SOMMETHODS
         _Pmpf(("wpAddToContent, folder: %s, object: %s",
             _wpQueryTitle(somSelf),
             _wpQueryTitle(Object)));
    #endif

    if (_fDisableAutoCnrAdd)
    {
        // do not call the parent!!
        // call our own implementation instead
        brc = fdrAddToContent(somSelf, Object);
    }
    else
    {
        brc = XFolder_parent_WPFolder_wpAddToContent(somSelf, Object);
    }

    if (brc)
        _cObjects++;

    if (!(_wpQueryFldrFlags(somSelf) & FOI_POPULATEINPROGRESS))
        fdrForEachOpenInstanceView(somSelf,
                                   STBM_UPDATESTATUSBAR,
                                   fncbStatusBarPost);

    return (brc);
}

/*
 *@@ wpDeleteFromContent:
 *      this method should be overridden to intercept the
 *      notification of the "Removed an object from a folder"
 *      event for subclasses that define their own folder view.
 *      The parent must always be called.
 *
 *@@changed V0.9.6 (2000-10-26) [pr]: update status bars
 */

SOM_Scope BOOL  SOMLINK xf_wpDeleteFromContent(XFolder *somSelf,
                                               WPObject* Object)
{
    BOOL brc = FALSE;

    XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpDeleteFromContent");

    #ifdef DEBUG_SOMMETHODS
         _Pmpf(("wpDeleteFromContent, folder: %s, object: %s",
             _wpQueryTitle(somSelf),
             _wpQueryTitle(Object)));
    #endif

    brc = XFolder_parent_WPFolder_wpDeleteFromContent(somSelf, Object);

    if (!(_wpQueryFldrFlags(somSelf) & FOI_POPULATEINPROGRESS))
        fdrForEachOpenInstanceView(somSelf,
                                   STBM_UPDATESTATUSBAR,
                                   fncbStatusBarPost);

    if (brc)
        _cObjects--;

    return (brc);
}

/*
 *@@ wpQueryContent:
 *      this WPFolder method can be called to enumerate a
 *      folder's contents.
 *
 *      This can be called in various ways:
 *
 *      --  If ulOption is QC_FIRST, the first object in the
 *          folder is returned. "Object" is ignored.
 *
 *      --  If ulOption is QC_NEXT, the object after "Object"
 *          is returned.
 *
 *      --  If ulOption is QC_LAST, the last object in the
 *          folder is returned.
 *
 *      For folders that have the "no auto-add" flag set (see
 *      XFolder::xwpSetDisableCnrAdd), we must override this
 *      to make this still work.
 *
 *@@added V0.9.7 (2001-01-13) [umoeller]
 */

SOM_Scope WPObject*  SOMLINK xf_wpQueryContent(XFolder *somSelf,
                                               WPObject* Object,
                                               ULONG ulOption)
{
    WPObject *pobj = NULL;
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpQueryContent");

    if (_fDisableAutoCnrAdd)
        // do not call the parent!!
        // call our own implementation instead
        pobj = fdrQueryContent(somSelf, Object, ulOption);
    else
        pobj = XFolder_parent_WPFolder_wpQueryContent(somSelf, Object, ulOption);

    return (pobj);
}

/*
 *@@ wpStoreIconPosData:
 *      this method is documented only for Warp 4
 *      (but exists in Warp 3 also, see WPFOLDER.H);
 *      it is called when an open folder in icon or
 *      details view is closed.
 *
 *      The WPS then apparently saves the .ICONPOS
 *      data to disk; we only override this method to be
 *      notified that we need to to invalidate our
 *      internal lists of the config folder contents.
 *
 *@@changed V0.9.0 [umoeller]: now invaliding lists in fdrmenus.c
 */

SOM_Scope BOOL  SOMLINK xf_wpStoreIconPosData(XFolder *somSelf,
                                              PICONPOS pIconPos,
                                              ULONG cbSize)
{
    BOOL rc;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpStoreIconPosData");

    if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // invalidate the content lists for the config
        // folders so that they will be rebuilt
        mnuInvalidateConfigCache();
    }

    rc =  (XFolder_parent_WPFolder_wpStoreIconPosData(somSelf,
                                                      pIconPos,
                                                      cbSize));

    return (rc);
}

/*
 *@@ wpDragOver:
 *      overridden for debugging.
 *
 *@@added V0.9.1 (2000-02-01) [umoeller]
 */

/* SOM_Scope MRESULT  SOMLINK xf_wpDragOver(XFolder *somSelf, HWND hwndCnr,
                                         PDRAGINFO pdrgInfo)
{
    MRESULT mrc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpDragOver");

    mrc = XFolder_parent_WPFolder_wpDragOver(somSelf, hwndCnr,
                                             pdrgInfo);

    _Pmpf(("XFolder::wpDragOver: parent returned MRESULT 0x%lX", mrc));

    return (mrc);
} */

/*
 *@@ wpRender:
 *      overridden for debugging.
 *
 *@@added V0.9.1 (2000-02-01) [umoeller]
 */

/* SOM_Scope MRESULT  SOMLINK xf_wpRender(XFolder *somSelf, PDRAGTRANSFER pdxfer)
{
    MRESULT mrc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpRender");

    mrc = XFolder_parent_WPFolder_wpRender(somSelf, pdxfer);

    _Pmpf(("XFolder::wpRender: parent returned MRESULT 0x%lX", mrc));

    return (mrc);

} */

/*
 *@@ wpRenderComplete:
 *      overridden for debugging.
 *
 *@@added V0.9.1 (2000-02-01) [umoeller]
 */

/* SOM_Scope MRESULT  SOMLINK xf_wpRenderComplete(XFolder *somSelf,
                                               PDRAGTRANSFER pdxfer,
                                               ULONG ulResult)
{
    MRESULT mrc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpRenderComplete");

    mrc = XFolder_parent_WPFolder_wpRenderComplete(somSelf,
                                                     pdxfer,
                                                     ulResult);

    _Pmpf(("XFolder::wpRenderComplete: parent returned MRESULT 0x%lX", mrc));

    return (mrc);
} */

/*
 *@@ wpFormatDragItem:
 *      overridden for debugging.
 *
 *@@added V0.9.1 (2000-02-01) [umoeller]
 */

/* SOM_Scope BOOL  SOMLINK xf_wpFormatDragItem(XFolder *somSelf,
                                            PDRAGITEM pdrgItem)
{
    BOOL brc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpFormatDragItem");

    brc = (XFolder_parent_WPFolder_wpFormatDragItem(somSelf,
                                                     pdrgItem));
    _Pmpf(("XFolder::wpFormatDragItem: parent returned BOOL %d", brc));

    return (brc);

} */

/*
 *@@ wpDrop:
 *      overridden for debugging.
 *
 *@@added V0.9.1 (2000-02-01) [umoeller]
 */

/* SOM_Scope MRESULT  SOMLINK xf_wpDrop(XFolder *somSelf, HWND hwndCnr,
                                     PDRAGINFO pdrgInfo, PDRAGITEM pdrgItem)
{
    MRESULT mrc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpDrop");

    mrc = (XFolder_parent_WPFolder_wpDrop(somSelf, hwndCnr,
                                           pdrgInfo, pdrgItem));
    _Pmpf(("XFolder::wpDrop: parent returned MRESULT 0x%lX", mrc));

    return (mrc);
} */

/*
 *@@ wpEndConversation:
 *      overridden for debugging.
 *
 *@@added V0.9.1 (2000-02-01) [umoeller]
 */

/* SOM_Scope MRESULT  SOMLINK xf_wpEndConversation(XFolder *somSelf,
                                                ULONG ulItemID,
                                                ULONG flResult)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpEndConversation");

    return (XFolder_parent_WPFolder_wpEndConversation(somSelf,
                                                      ulItemID,
                                                      flResult));
} */

/*
 *@@ wpMoveObject:
 *      this is called when the folder is moved to a
 *      different location; we then need to update
 *      the titles of this folder AND of possibly open
 *      subfolders with the full path; we pass this
 *      job to the Worker thread.
 */

SOM_Scope BOOL  SOMLINK xf_wpMoveObject(XFolder *somSelf,
                                        WPFolder* Folder)
{
    BOOL rc;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpMoveObject");

    if (    (pCfg)
         && (wpshResidesBelow(somSelf, pCfg))
       )
        // this was in the config folder hierarchy:
        mnuInvalidateConfigCache();

    // call the parent method first, which will actually move the folder
    rc = XFolder_parent_WPFolder_wpMoveObject(somSelf, Folder);

    xthrPostWorkerMsg(WOM_REFRESHFOLDERVIEWS, (MPARAM)somSelf, MPNULL);

    return rc;
}

/*
 *@@ wpDelete:
 *      this WPObject method deletes an object and
 *      prompts for confirmations, if necessary.
 *
 *      Normally, this method displays confirmations,
 *      if desired, by calling wpConfirmDelete, and
 *      then calls wpFree.
 *
 *      For folders, this apparently calls wpDelete
 *      on every contained object.
 *
 *      This implementation is not desirable if the
 *      trash can has been enabled because we just
 *      want the folder to be moved into the trash
 *      can altogether. So in addition to XFldObject::wpDelete,
 *      we must override this method for XFolder also.
 *
 *      See XFldObject::wpDelete for more remarks.
 *
 *      This must return:
 *
 *      --  NO_DELETE: Error occurred.
 *      --  CANCEL_DELETE: User canceled the operation.
 *      --  OK_DELETE: Object was deleted.
 *
 *@@added V0.9.4 (2000-08-03) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpDelete(XFolder *somSelf, ULONG fConfirmations)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpDelete");

    /* if (pGlobalSettings->fTrashDelete)
    {
        if (cmnMove2DefTrashCan(somSelf))
            return (OK_DELETE);
        else
            return (NO_DELETE);
    } */

    return (XFolder_parent_WPFolder_wpDelete(somSelf, fConfirmations));
}

/*
 *@@ wpSetTitle:
 *      this is called when the folder is renamed.
 *      We then need to update the titles of this
 *      folder AND of possibly open subfolders with
 *      the full path; we pass this task to the Worker
 *      thread, since it may take a while.
 */

SOM_Scope BOOL  SOMLINK xf_wpSetTitle(XFolder *somSelf, PSZ pszNewTitle)
{
    BOOL rc;
    // XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpSetTitle");

    /* if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // invalidate the content lists for the config
        // folders so that they will be rebuilt
        mnuInvalidateConfigCache();
    } */

    rc = XFolder_parent_WPFolder_wpSetTitle(somSelf, pszNewTitle);

    if (_wpFindUseItem(somSelf, USAGE_OPENVIEW, NULL))
        // any open views: update titles
        xthrPostWorkerMsg(WOM_REFRESHFOLDERVIEWS, (MPARAM)somSelf, MPNULL);

    return (rc);
}

/*
 *@@ wpSetFldrSort:
 *      apparently, this method normally gets called by the
 *      WPS every time it tries to sort a folder. That is,
 *      when one of the "Sort" menu items is selected or when
 *      the folder is sorted for another reason, e.g. because
 *      "Always sort" is on and a file in the folder was
 *      renamed.
 *
 *      The WPS ref. says about this method:
 *      "This instance method sets the sort attributes on
 *      the folder window and  saves those values in the
 *      instance data. Note:  This method only rearranges a
 *      folder open in icon view. If (pSortRecord == NULL),
 *      the values are reset to the default sort values."
 *
 *      However, the description of this method in the WPS
 *      ref. is complete garbage. The SORTFASTINFO structure
 *      described there is obviously not used, but some
 *      undocumented data instead. (I guess that's why IBM
 *      uses a PVOID here, so they need not apologize.)
 *      Also, this method rearranges _all_ open folders, not
 *      just icons views.
 *
 *      Anyway, if XFolder extended sorting is enabled,
 *      we can intercept this method call to prevent the
 *      WPS from sorting the container. We will then not
 *      call the default method, but our own one instead.
 *      Since XFolder completely takes over the other sort
 *      functions, this method probably only gets called
 *      when files are renamed any more.
 *
 *@@changed V0.9.4 (2000-06-08) [umoeller]: reversed call order
 */

SOM_Scope BOOL  SOMLINK xf_wpSetFldrSort(XFolder *somSelf,
                                         PVOID pSortRecord,
                                         ULONG ulView,
                                         ULONG ulType)
{
    BOOL    brc;

    XFolderMethodDebug("XFolder","xf_wpSetFldrSort");

    brc = XFolder_parent_WPFolder_wpSetFldrSort(somSelf,
                                                pSortRecord,
                                                ulView,
                                                ulType);
    if (brc)
    {
        PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();

        if (pGlobalSettings->ExtFolderSort)
        {
            HWND hwndFrame = wpshQueryFrameFromView(somSelf, ulView);
            if (hwndFrame)
            {
                HWND hwndCnr = wpshQueryCnrFromFrame(hwndFrame);
                if (hwndCnr)
                {
                    fdrSetFldrCnrSort(somSelf, hwndCnr,
                                      TRUE);  // enfore cnr sort
                    return (TRUE);
                }
            }
        }
    }

    return (brc);
}

/* ******************************************************************
 *                                                                  *
 *   here come the XFolder class methods                            *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpclsQueryConfigFolder:
 *      returns the XFolder Configuration Folder or NULL
 *      if it doesn't exist.
 *
 *@@added V0.9.0 [umoeller]
 *@@changed V0.9.2 (2000-02-26) [umoeller]: object is now always checked for integrity
 */

SOM_Scope XFolder*  SOMLINK xfM_xwpclsQueryConfigFolder(M_XFolder *somSelf)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryConfigFolder");

    if (G_pConfigFolder == NULL)
        // config folder not queried yet:
        // do it now
        G_pConfigFolder = wpshQueryObjectFromID(XFOLDER_CONFIGID, NULL);
                    // changed V0.9.0: the class method doesn't seem to
                    // be working on the new Warp Server

    // in any case, check that object
    if (!wpshCheckObject(G_pConfigFolder))
        G_pConfigFolder = NULL;

    return (G_pConfigFolder);
}

/*
 *@@ xwpclsQueryFavoriteFolder:
 *      This returns "favorite" folders.
 *
 *      If pFolder == NULL, the first favorite folder is returned,
 *      otherwise the favorite folder which comes after pFolder
 *      in the favorite folder list.
 *
 *      This returns NULL if no more folders are found.
 *
 *@@changed V0.9.7 (2001-01-18) [umoeller]: added list notify on deletion, which fixed crashes
 */

SOM_Scope XFolder*  SOMLINK xfM_xwpclsQueryFavoriteFolder(M_XFolder *somSelf,
                                                          XFolder* pFolder)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);

    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryFavoriteFolder");

    return (objEnumList(G_pllFavoriteFolders,
                        pFolder,
                        INIKEY_FAVORITEFOLDERS,
                        OBJLIST_FAVORITEFOLDER));
}

/*
 *@@ xwpclsQueryQuickOpenFolder:
 *      This returns folders which have the "QuickOpen" flag on.
 *
 *      If pFolder == NULL, the first such folder is returned,
 *      otherwise the folder which comes after pFolder
 *      in the quick-open folder list.
 *
 *      This returns NULL if no more folders are found.
 *
 *@@changed V0.9.7 (2001-01-18) [umoeller]: added list notify on deletion, which fixed crashes
 */

SOM_Scope XFolder*  SOMLINK xfM_xwpclsQueryQuickOpenFolder(M_XFolder *somSelf,
                                                           XFolder* pFolder)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);

    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryQuickOpenFolder");

    return (objEnumList(G_pllQuickOpenFolders,
                        pFolder,
                        INIKEY_QUICKOPENFOLDERS,
                        OBJLIST_QUICKOPENFOLDER));
}

/*
 *@@ xwpclsQueryMenuBarVisibility:
 *      this returns the default visibility of menu bars
 *      as specified in the "System" object. Warp 4 has
 *      no method for this, so this has been added.
 *
 *      On Warp 3, this returns FALSE always.
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfM_xwpclsQueryMenuBarVisibility(M_XFolder *somSelf)
{
    BOOL brc = FALSE;
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryMenuBarVisibility");

    if (doshIsWarp4())
    {
        PSZ psz = prfhQueryProfileData(HINI_USER,
                                       "PM_Workplace", "FolderMenuBar",
                                       NULL);
        if (psz)
        {
            if (strcmp(psz, "OFF") != 0)
                brc = TRUE;
            free(psz);
        }
    }

    return (brc);
}

/*
 *@@ wpclsInitData:
 *      this initializes the WPFolder / XFolder class as a whole;
 *      we need to call the parent and then set some XFolder
 *      data.
 *
 *@@changed V0.9.0 [umoeller]: added class object to KERNELGLOBALS
 */

SOM_Scope void  SOMLINK xfM_wpclsInitData(M_XFolder *somSelf)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsInitData");

    M_XFolder_parent_M_WPFolder_wpclsInitData(somSelf);

    {
        // store the class object in KERNELGLOBALS
        PKERNELGLOBALS   pKernelGlobals = krnLockGlobals(__FILE__, __LINE__, __FUNCTION__);
        if (pKernelGlobals)
        {
            if (pKernelGlobals->fXFolder == FALSE)
            {
                // first call:

                // store the class object in KERNELGLOBALS
                pKernelGlobals->fXFolder = TRUE;

                // initialize other data
                G_pllFavoriteFolders = lstCreate(FALSE);    // no auto-free
                G_pllQuickOpenFolders = lstCreate(FALSE);   // no auto-free

                fdrLoadFolderHotkeys();

                // register class for supplementary object
                // windows, which are created for each folder view
                // which is opened
                WinRegisterClass(WinQueryAnchorBlock(HWND_DESKTOP),
                                 (PSZ)WNDCLASS_SUPPLOBJECT,    // class name
                                 (PFNWP)fdr_fnwpSupplFolderObject,    // Window procedure
                                 0,       // class style
                                 4);      // extra window words for SUBCLASSEDFOLDERVIEW
                                          // pointer (see fdrSubclassFolderView)

                // install local hook (fdrsubclass.c)
                WinSetHook(WinQueryAnchorBlock(HWND_DESKTOP),
                           HMQ_CURRENT,
                           HK_SENDMSG,
                           (PFN)fdr_SendMsgHook,
                           NULLHANDLE);  // module handle, can be 0 for local hook

            }
            krnUnlockGlobals();
        }
    }
}

/*
 *@@ wpclsCreateDefaultTemplates:
 *      this WPObject class method is called by the
 *      Templates folder to allow a class to
 *      create its default templates.
 *
 *      The default WPS behavior is to create new templates
 *      if the class default title is different from the
 *      existing templates.
 *
 *      Since we are replacing the class, we will have to
 *      suppress this in order not to crowd the Templates
 *      folder.
 */

SOM_Scope BOOL  SOMLINK xfM_wpclsCreateDefaultTemplates(M_XFolder *somSelf,
                                                        WPObject* Folder)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsCreateDefaultTemplates");

    // we only override this class method if it is
    // being called for the XFolder class object itself.
    // If this is being called for a subclass, we use
    // the parent method, because we do not want to
    // break the default behavior for subclasses.
    if (somSelf == _XFolder)
        return (TRUE);
        // means that the Templates folder should _not_ create templates
        // by itself; we pretend that we've done this
    else
        return (M_XFolder_parent_M_WPFolder_wpclsCreateDefaultTemplates(somSelf,
                                                                    Folder));
}

/*
 *@@ wpclsQueryIconData:
 *      this WPObject class method builds the default
 *      icon for objects of a class (i.e. the icon which
 *      is shown if no instance icon is assigned). This
 *      apparently gets called from some of the other
 *      icon instance methods if no instance icon was
 *      found for an object. The exact mechanism of how
 *      this works is not documented.
 *
 *      We give folders a new default closed icon, if the
 *      global settings allow this.
 *      This is loaded from /ICONS/ICONS.DLL.
 *      Unfortunately, it appears to be impossible to
 *      dynamically load default icons as specified for
 *      the ICONINFO structure in the WPS reference.
 *      ICON_FILE at least doesn't work, and the format
 *      for ICON_DATA is not explained. So we have to
 *      use a DLL here.
 */

SOM_Scope ULONG  SOMLINK xfM_wpclsQueryIconData(M_XFolder *somSelf,
                                                PICONINFO pIconInfo)
{
    ULONG       ulrc;
    HMODULE     hmodIconsDLL = NULLHANDLE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsQueryIconData");

    if (pGlobalSettings->fReplaceIcons)
    {
        hmodIconsDLL = cmnQueryIconsDLL();
        // icon replacements allowed:
        if ((pIconInfo) && (hmodIconsDLL))
        {
            pIconInfo->fFormat = ICON_RESOURCE;
            pIconInfo->hmod = hmodIconsDLL;
            pIconInfo->resid = 100;
        }
        ulrc = sizeof(ICONINFO);
    }

    if (hmodIconsDLL == NULLHANDLE)
        // icon replacements not allowed: call default
        ulrc = M_XFolder_parent_M_WPFolder_wpclsQueryIconData(somSelf,
                                                              pIconInfo);
    return (ulrc);
}

/*
 *@@ wpclsQueryIconDataN:
 *      give folders a new default open icon, if the
 *      global settings allow this.
 *      See the notes for wpclsQueryIconData.
 */

SOM_Scope ULONG  SOMLINK xfM_wpclsQueryIconDataN(M_XFolder *somSelf,
                                                 ICONINFO* pIconInfo,
                                                 ULONG ulIconIndex)
{
    ULONG       ulrc;
    HMODULE     hmodIconsDLL = NULLHANDLE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsQueryIconDataN");

    if (pGlobalSettings->fReplaceIcons)
    {
        hmodIconsDLL = cmnQueryIconsDLL();
        // icon replacements allowed:
        if ((pIconInfo) && (hmodIconsDLL))
        {
            pIconInfo->fFormat = ICON_RESOURCE;
            pIconInfo->hmod = hmodIconsDLL;
            pIconInfo->resid = 101;
        }
        ulrc = sizeof(ICONINFO);
    }

    if (hmodIconsDLL == NULLHANDLE)
        // icon replacements not allowed: call default
        ulrc = M_XFolder_parent_M_WPFolder_wpclsQueryIconDataN(somSelf,
                                                               pIconInfo,
                                                               ulIconIndex);
    return (ulrc);
}




