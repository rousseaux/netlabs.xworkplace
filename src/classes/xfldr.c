
/*
 *@@sourcefile xfldr.c:
 *      This file contains SOM code for the following XWorkplace classes:
 *
 *      --  XFolder class (WPFolder replacement)
 *
 *      XFolder is probably the most complex class of this
 *      package. Not only are context menus manipulated, but
 *      open folder view windows are also subclassed to
 *      introduce additional functionality (fdr_fnwpSubclassedFolderFrame),
 *      and we manipulate folder sorting and add status bars
 *      to open folder views.
 *
 *      Installation of XFolder is now optional (V0.9.0).
 *      However, if any of XFldDisk, XFldStartup, or XFldShutdown are
 *      installed, XFolder must also be installed.
 *
 *      Starting with V0.9.0, the files in classes\ contain only
 *      the SOM interface, i.e. the methods themselves.
 *      The implementation for this class is mostly in filesys\folder.c,
 *      filesys\fdrhotky.c, and filesys\filesys.c.
 *
 *@@somclass XFolder xf_
 *@@somclass M_XFolder xfM_
 *
 *@@changed V0.9.0 [umoeller]: override of wpclsQueryTitle removed
 */

/*
 *      Copyright (C) 1997-99 Ulrich M”ller.
 *      This file is part of the XWorkplace source package.
 *      XWorkplace is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published
 *      by the Free Software Foundation, in version 2 as it comes in the
 *      "COPYING" file of the XWorkplace main distribution.
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

/*
 *@@todo:
 *
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitctm: 2.41
 */

#ifndef SOM_Module_xfldr_Source
#define SOM_Module_xfldr_Source
#endif
#define XFolder_Class_Source
#define M_XFolder_Class_Source

/*
 *  Suggested #include order:
 *  1)  os2.h
 *  2)  C library headers
 *  3)  setup.h (code generation and debugging options)
 *  4)  headers in helpers\
 *  5)  at least one SOM implementation header (*.ih)
 *  6)  dlgids.h, headers in shared\ (as needed)
 *  7)  headers in implementation dirs (e.g. filesys\, as needed)
 *  8)  #pragma hdrstop and then more SOM headers which crash with precompiled headers
 */

#define INCL_DOSEXCEPTIONS
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSERRORS
#define INCL_WINWINDOWMGR
#define INCL_WINFRAMEMGR
#define INCL_WININPUT
#define INCL_WINRECTANGLES
#define INCL_WINSYS             // needed for presparams
#define INCL_WINMENUS
#define INCL_WINTIMER
#define INCL_WINDIALOGS
#define INCL_WINBUTTONS
#define INCL_WINENTRYFIELDS
#define INCL_WINLISTBOXES
#define INCL_WINSTDCNR
#define INCL_WINSHELLDATA       // Prf* functions
#include <os2.h>

// C library headers
#include <stdio.h>              // needed for except.h
#include <setjmp.h>             // needed for except.h
#include <assert.h>             // needed for except.h

// generic headers
#include "setup.h"                      // code generation and debugging options

// headers in /helpers
#include "helpers\cnrh.h"               // container helper routines
#include "helpers\dosh.h"               // Control Program helper routines
#include "helpers\eah.h"                // extended attributes helper routines
#include "helpers\except.h"             // exception handling
#include "helpers\linklist.h"           // linked list helper routines
#include "helpers\prfh.h"               // INI file helper routines
#include "helpers\stringh.h"            // string helper routines
#include "helpers\winh.h"               // PM helper routines
#include "helpers\wphandle.h"           // Henk Kelder's HOBJECT handling

// SOM headers which don't crash with prec. header files
#include "xfldr.ih"

// XWorkplace implementation headers
#include "dlgids.h"                     // all the IDs that are shared with NLS
#include "shared\cnrsort.h"             // container sort comparison functions
#include "shared\common.h"              // the majestic XWorkplace include file
#include "shared\kernel.h"              // XWorkplace Kernel
#include "shared\notebook.h"            // generic XWorkplace notebook handling
#include "shared\wpsh.h"                // some pseudo-SOM functions (WPS helper routines)

#include "filesys\menus.h"              // common XFolder context menu logic
#include "filesys\xthreads.h"           // extra XWorkplace threads

// other SOM headers
#pragma hdrstop                         // VAC++ keeps crashing otherwise

#include <wprootf.h>                    // WPRootFolder
#include <wpshadow.h>                   // WPShadow
#include <wpdesk.h>
#include "xfobj.h"
#include "xfdisk.h"

// implementation includes which require other filesys\ headers
#include "filesys\filesys.h"           // extended file types implementation
#include "filesys\folder.h"            // XFolder implementation
#include "filesys\statbars.h"          // status bar translation logic

/* ******************************************************************
 *                                                                  *
 *   Global variables                                               *
 *                                                                  *
 ********************************************************************/

CHAR                szXFolderVersion[100];

XFolder             *pConfigFolder = NULL;

// "XFolder" key for wpRestoreData etc.
const char* pcszXFolder = "XFolder";

// roots of linked lists for favorite/quick-open folders
// these hold CONTENTMENULISTITEM's
PLINKLIST           pllFavoriteFolders = NULL,
                    pllQuickOpenFolders = NULL;

/* ******************************************************************
 *                                                                  *
 *   here come the XFolder instance methods                         *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpQueryFldrSort:
 *      this returns the folder's sort settings into the specified
 *      USHORT variables. These are set to SET_DEFAULT if no instance
 *      data has been defined; you will then need to query the
 *      GLOBALSETTINGS values.
 *
 *      See XFolder::xwpSortViewOnce for the values of pusDefaultSort.
 */

SOM_Scope BOOL  SOMLINK xf_xwpQueryFldrSort(XFolder *somSelf,
                                            PUSHORT pusDefaultSort,
                                            PUSHORT pusAlwaysSort)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpQueryFldrSort");

    if ((pusDefaultSort) && (pusAlwaysSort))
    {
        *pusDefaultSort = (USHORT)_bDefaultSortInstance;
        *pusAlwaysSort  = (USHORT)_bAlwaysSortInstance;
        return (TRUE);
    }
    else
        return (FALSE);
}

/*
 *@@ xwpSetFldrSort:
 *      this is the new XFolder method for setting the sort data
 *      for a certain folder.
 *
 *      usDefaultSort should be one of the SV_ constants as in
 *      XFolder::xwpSortViewOnce or SET_DEFAULT for resetting the folder's
 *      default sort criterion to the Global Settings's value.
 *
 *      usAlwaysSort can be 0 or 1 or SET_DEFAULT also.
 *
 *      This method updates all open folder views with the new
 *      sort settings.
 *
 *      This method returns TRUE if any visible change occured as
 *      a result to the new settings.
 */

SOM_Scope BOOL  SOMLINK xf_xwpSetFldrSort(XFolder *somSelf,
                                          USHORT usDefaultSort,
                                          USHORT usAlwaysSort)
{
    BOOL Update = FALSE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpSetFldrSort");

    #ifdef DEBUG_SORT
        _Pmpf(("xwpSetFldrSort %s", _wpQueryTitle(somSelf)));
        _Pmpf(("  Old: Default %d, Always %d", _bDefaultSortInstance, _bAlwaysSortInstance));
        _Pmpf(("  New: Default %d, Always %d", usDefaultSort, usAlwaysSort));
    #endif

    if (usDefaultSort != _bDefaultSortInstance)
    {
        _bDefaultSortInstance = usDefaultSort;
        Update = TRUE;
    }

    if (usAlwaysSort != _bAlwaysSortInstance)
    {
        _bAlwaysSortInstance = usAlwaysSort;
        // if _wpRestoreState has found the pointer to the
        // WPFOlder-internal sort structure, we will update
        // this one also, because otherwise the WPS keeps
        // messing with the container attributes
        if (_pFldrSortInfo)
            (_pFldrSortInfo)->fAlwaysSort = ALWAYS_SORT;
        Update = TRUE;
    }

    if (Update)
    {
        // update open views of this folder
        _xwpForEachOpenView(somSelf, 0, &fdrUpdateFolderSorts);
        // save instance data
        _wpSaveDeferred(somSelf);
        // update folder "Sort" notebook page, if open
        ntbUpdateVisiblePage(somSelf, SP_FLDRSORT_FLDR);
    }

    return (Update);
}

/*
 *@@ xwpSortViewOnce:
 *      sorts the content of given folder.
 *      As opposed to XFolder::xwpSetFldrSort, this does not
 *      change the folder sort settings, but only sorts the view
 *      once.
 *
 *      This is used by the context menu entries in the "Sort"
 *      menu and the respective folder hotkeys.
 *
 *      ulSort must be one of the following:
 *      --  SV_NAME
 *      --  SV_TYPE
 *      --  SV_CLASS                (new: sort by object class)
 *      --  SV_REALNAME
 *      --  SV_SIZE
 *      --  SV_LASTWRITEDATE
 *      --  SV_LASTACCESSDATE
 *      --  SV_CREATIONDATE
 *      --  SV_EXT                  (new: sort by extension)
 *      --  SV_FOLDERSFIRST         (new: sort folders first)
 */

SOM_Scope BOOL  SOMLINK xf_xwpSortViewOnce(XFolder *somSelf,
                                           HWND hwndFrame,
                                           USHORT usSort)
{
    BOOL rc = FALSE;
    HWND hwndCnr = wpshQueryCnrFromFrame(hwndFrame);
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xfSortByExt");

    if (hwndCnr)
    {
        CNRINFO CnrInfo;
        ULONG   ulStyle = 0;

        cnrhQueryCnrInfo(hwndCnr, &CnrInfo);

        if ((CnrInfo.flWindowAttr & (CV_ICON | CV_TREE)) == CV_ICON)
        {
            // for some reason, icon views need to have "auto arrange" on,
            // or nothing will happen
            ulStyle = WinQueryWindowULong(hwndCnr, QWL_STYLE);
            WinSetWindowULong(hwndCnr, QWL_STYLE, ulStyle | CCS_AUTOPOSITION);
        }

        // send sort msg with proper sort (comparison) func
        WinSendMsg(hwndCnr, CM_SORTRECORD,
                   (MPARAM)fdrQuerySortFunc(usSort),
                   MPNULL);

        if ((CnrInfo.flWindowAttr & (CV_ICON | CV_TREE)) == CV_ICON)
            // restore old cnr style
            WinSetWindowULong(hwndCnr, QWL_STYLE, ulStyle);

        rc = TRUE;
    }
    return (rc);
}

/*
 *@@ xwpQueryIconPos:
 *      this new instance method retrieves the icon position of an
 *      object in a currently populated folder; you need to initialize
 *      the pICONPOS structure first, whose size you need to pass in
 *      ulICONPOSSize; the ICONPOS data will be copied to pipReturn.
 *      The method returns FALSE if something went wrong.
 */

SOM_Scope BOOL  SOMLINK xf_xwpGetIconPos(XFolder *somSelf,
                                         WPObject *pObject,
                                         PBYTE pICONPOS,
                                         USHORT usICONPOSSize,
                                         PICONPOS pipReturn)
{
    USHORT   usStartPos;
    PICONPOS pip;

    CHAR     szKey[100],
             szPath[CCHMAXPATH];

    HOBJECT  hObject = _wpQueryHandle(pObject);
    PSZ      pszClass = _somGetClassName(pObject);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpGetIconPos");

    usStartPos = 21; // with OS/2 2.1 and above, Henk Kelder says

    /* first step: the icon position of each object within a given
       .ICONPOS EA starts with a string identifying the object; so
       first, we need to compose this string depending on the type
       of the passed object */
    if (IsObjectAbstract(hObject))
        sprintf(szKey, "%s:A%lX", pszClass, LOUSHORT(hObject));
    else
    {   // file system object
        WPFileSystem    *pobjFile;
        if (pobjFile = _wpclsQueryObject(_WPObject, hObject))
        {
            if (_wpQueryFilename(pobjFile, szPath, FALSE))
            {
                sprintf(szKey,
                        "%s:%c%s",
                        pszClass,
                        (_somIsA(pobjFile, _WPFolder) ? 'D' : 'F'),
                        szPath);
            }
            else
                return FALSE;
        }
        else
            return FALSE;

    }

    // now we have the key to search for within the .ICONPOS EA

    if ((pICONPOS) && (pipReturn))
    {
        /* now we go through the .ICONPOS data that was given to us
           and check each item in there if it matches the key we
           composed above */
        for (pip = (PICONPOS)( pICONPOS + usStartPos );
            (PBYTE)pip < pICONPOS + usICONPOSSize; )
        {
            if (!stricmp(pip->szIdentity, szKey))
            {
                *pipReturn = *pip;
                return TRUE;
            }
            pip = (PICONPOS)( (PBYTE)pip + sizeof(POINTL) + strlen(pip->szIdentity) + 1 );
        }
    }

    return FALSE;
}

/*
 *@@ xwpBeginEnumContent:
 *      this begins ordered content enumeration on a folder.
 *      Call this method before any call to XFolder::xwpEnumNext.
 *
 *      The "enum content" methods are similar to wpQueryContent,
 *      but take into account the order of objects in a folder.
 *      This is done by evaluating the .ICONPOS extended
 *      attributes of a folder.
 *
 *      This function returns an enumeration handle if the folder
 *      contains any objects at all. Pass this handle to any
 *      subsequent calls of XFolder::xwpEnumNext, and keep calling
 *      XFolder::xwpEnumNext until NULL is returned.
 *
 *      Then call XFolder::xwpEndEnumContent when you're
 *      done to free allocated resources.
 *
 *      If the folder is empty, NULLHANDLE is returned.
 *
 *      The "enum content" methods replace the following
 *      methods, which were present before V0.9.0:
 *               xfInvalidateOrderedContent,
 *               xfUpdateOrderedContent,
 *               xfQueryOrderedContent.
 *      The new methods do not keep memory allocated, so
 *      this new approach was taken.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_xwpBeginEnumContent(XFolder *somSelf)
{
    PENUMCONTENT pec;

    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpBeginEnumContent");

    pec = malloc(sizeof(ENUMCONTENT));
    if (pec)
    {
        BOOL                 fItemsFound = FALSE;
        WPObject             *pObj;

        memset(pec, 0, sizeof(ENUMCONTENT));

        wpshCheckIfPopulated(somSelf);

        // build new list for ORDEREDLISTITEMs:
        pec->pllOrderedContent = lstCreate(TRUE);       // auto-free list items

        // get the folder's content as the WPS delivers it.
        // This is unsorted. Apparently, the WPS returns items
        // in the following order:
        // a)   first: file-system objects in the order returned
        //      by the file system (i.e. alphabetically on HPFS)
        // b)   then all abstract objects in the order they were
        //      placed in this folder.

        for (pObj = _wpQueryContent(somSelf, NULL, (ULONG)QC_FIRST);
             (pObj);
             pObj = _wpQueryContent(somSelf, pObj, (ULONG)QC_NEXT)
            )
        {
            // create new list item
            PORDEREDLISTITEM poliNew = malloc(sizeof(ORDEREDLISTITEM));
            fItemsFound = TRUE;

            // store object
            poliNew->pObj = pObj;

            // Each ICONPOS struct's identity string has the following format:
            // <class>:<t><identity>
            // with: <class> being the class of the object
            //       <t> == A for abstracts, D for folders, F for files
            //       <identity> for abstract objects: the handle
            //                  for file-system objects: the filename

            // now create the identity string for the search object
            if (_somIsA(pObj, _WPAbstract))
            {
                // for abstract objects, this is the low word
                // of the object handle
                HOBJECT hobjSearch = _wpQueryHandle(pObj);
                sprintf(poliNew->szIdentity, ":A%lX", (hobjSearch & 0xFFFF));
            }
            else
            {
                // for file-system objects, this is the object's real name
                ULONG   ulSize = sizeof(poliNew->szIdentity)-2;
                if (_somIsA(pObj, _WPFolder))
                    strcpy(poliNew->szIdentity, ":D");
                else
                    strcpy(poliNew->szIdentity, ":F");
                // append real name
                _wpQueryRealName(pObj,
                                 (poliNew->szIdentity)+2,
                                 &ulSize,
                                 FALSE);    // file name only
            }

            lstAppendItem(pec->pllOrderedContent,
                          poliNew);
        }

        if (!fItemsFound)
        {
            // folder was empty:
            // cleanup
            lstFree(pec->pllOrderedContent);
            free(pec);
            pec = NULL;
        }
        else
        {
            PEABINDING           peab;
            SORTBYICONPOS        sip;

            // read .ICONPOS extended attributes of this folder
            _wpQueryFilename(somSelf, sip.szRealName, TRUE);
            if (peab = eaPathReadOneByName(sip.szRealName, ".ICONPOS"))
            {

                //  typedef struct
                //  {
                //    BYTE bFlags;
                //    BYTE bNameLength;
                //    USHORT usValueLength;
                //    PSZ pszName;
                //    PSZ pszValue;
                //  } EABINDING, *PEABINDING;

                ULONG ulrc = 0;
                PBYTE pICONPOS = malloc(peab->usValueLength+100);

                if (pICONPOS)
                {
                    ULONG ulICONPOSSize = (peab->usValueLength)-5;
                    memcpy(pICONPOS, peab->pszValue+4, peab->usValueLength-3);

                    // finally, we have the ICONPOS data in _pICONPOS;
                    // now we pass the ICONPOS data to the sort function
                    // defined above

                    #ifdef DEBUG_ORDEREDLIST
                        _Pmpf(("  Sorting..."));
                    #endif

                    sip.pICONPOS = pICONPOS;
                    sip.usICONPOSSize = ulICONPOSSize;

                    lstQuickSort(pec->pllOrderedContent,
                                 fdrSortByICONPOS,
                                 &sip);     // addtl. param passed to sort func

                    free(pICONPOS);
                }

                eaFreeBinding(peab);
            }
        }
    }

    return ((ULONG)pec);
}

/*
 *@@ xwpEnumNext:
 *      this keeps returning the ordered contents of a
 *      folder or NULL if no more objects are found.
 *
 *      Keep calling this function if XFolder::xwpBeginEnumContent
 *      returned a valid enumeration handle, until this
 *      function returns NULL.
 *
 *      Then call XFolder::xwpEndEnumContent when you're
 *      done to free allocated resources.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope WPObject*  SOMLINK xf_xwpEnumNext(XFolder *somSelf,
                                            ULONG henum)
{
    WPObject *pObject = NULL;
    PENUMCONTENT pec = (PENUMCONTENT)henum;

    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpEnumNext");

    if (pec)
    {
        if (pec->pnodeLastQueried == NULL)
            // first call: get first list node
            pec->pnodeLastQueried = lstQueryFirstNode(pec->pllOrderedContent);
        else
            // subsequent calls: get next list node
            pec->pnodeLastQueried = pec->pnodeLastQueried->pNext;

        if (pec->pnodeLastQueried)
        {
            // another item found:
            PORDEREDLISTITEM poli = (PORDEREDLISTITEM)pec->pnodeLastQueried->pItemData;
            if (poli)
                pObject = poli->pObj;
        }
    }

    return (pObject);
}

/*
 *@@ xwpEndEnumContent:
 *      this frees resources allocated when enumerating
 *      folder contents.
 *
 *      See XFolder::xwpBeginEnumContent for how to use
 *      this.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpEndEnumContent(XFolder *somSelf,
                                             ULONG henum)
{
    PENUMCONTENT pec = (PENUMCONTENT)henum;
    BOOL brc = FALSE;
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpEndEnumContent");

    if (pec)
    {
        lstFree(pec->pllOrderedContent);    // this will auto-free the list items
        free(pec);
        brc = TRUE;
    }

    return (brc);
}

/*
 *@@ xwpBeginProcessOrderedContent:
 *      this new instance method uses XFolder::xwpBeginEnumContent etc.
 *      to open all the objects in the given folder. This is used
 *      by the XWorkplace Startup and Shutdown folders.
 *
 *      This method returns immediately; further processing is done in the
 *      background Worker thread.
 *
 *      However, this method returns a handle which may be used in
 *      XFolder::xwpCancelProcessOrderedContent to abort processing.
 *      Upon errors, null is returned.
 *
 *      Parameters:
 *      -- ULONG ulTiming:     the time to wait between starting objects
 *                                  in milliseconds; if set to 0, this function
 *                                  will work in "Wait" mode, i.e. the next
 *                                  object will open the next object only if
 *                                  the previous one has been closed again
 *                                  (e.g. for XShutdown folder).
 *      -- PFNWP pfnwpCallback: a callback routine which will be called on
 *                                  every object which is started.
 *      -- ULONG ulCallbackParam: the first parameter to pass to this proc.
 *
 *      You will be notified of the progress thru the pfnwpCallback function,
 *      which gets passed the the following parameters:
 *      -- HWND  hwnd:     will not be a hwnd, but ulCallbackParam
 *                              specified above (which might be a window though);
 *      -- ULONG msg:      will contain the current object of the
 *                              folder on which this mthd is invoked;
 *                              this must be cast manually to (WPObject*);
 *      -- MPARAM mp1:     contains the current object count
 *                              (starting with 1 and increasing for each
 *                              subsequent object);
 *      -- MPARAM mp2:     the (constant) number of objects in the folder.
 *
 *      This callback func may be used for implementing a progress bar.
 *      You can use ulCallbackParam for the msg window handle and display
 *      the progress according to mp1 and mp2; the object title may be
 *      obtained by calling _wpQueryTitle((WPObject*)msg).
 *
 *      Note that even though the processing of the folder is done in the
 *      Worker thread, the callback func is actually called on thread 1
 *      (Workplace thread), so you can create your window there and have
 *      work done on it without having to worry about thread safety. This
 *      is implemented because wpViewObject is having problems when not
 *      being called in the Workplace thread.
 *
 *      In detail, the thread interaction works as follows:
 *
 *      1)   Calling this function posts WOM_PROCESSORDEREDCONTENT to
 *                the Worker thread (fnwpWorkerObject), which takes over.
 *
 *      2)   The Worker thread then goes thru the (ordered) contents of
 *                the specified folder. For each object found, it posts
 *                T1M_POCCALLBACK to krn_fnwpThread1Object, which will then in
 *                turn call your callback on thread 1.
 *
 *      3)   The Worker thread then either waits for the object to
 *                be closed (in "Wait" mode) or the specified time.
 *
 *      After all objects have been processed, the callback will called
 *      once more with msg == 0 to allow cleaning up. If the folder does
 *      not contain any objects, the callback will only be called this one
 *      time.
 *
 *      If you're running in "Wait" mode, the callback must return the
 *      hwnd of the object which you must have opened with wpViewObject,
 *      so that the Worker thread can wait for this window to be closed.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 */

SOM_Scope ULONG  SOMLINK xf_xwpBeginProcessOrderedContent(XFolder *somSelf,
                                                          ULONG ulTiming,
                                                          PFNWP pfnwpCallback,
                                                          ULONG ulCallbackParam)
{
    PPROCESSCONTENTINFO pPCI;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpBeginProcessOrderedContent");

    pPCI = (PPROCESSCONTENTINFO)malloc(sizeof(PROCESSCONTENTINFO));

    if (pPCI)
    {
        pPCI->ulObjectNow = 0;
        pPCI->ulTiming = ulTiming;
        pPCI->pfnwpCallback = pfnwpCallback;
        pPCI->ulCallbackParam = ulCallbackParam;
        pPCI->fCancelled = FALSE;

        xthrPostWorkerMsg(WOM_PROCESSORDEREDCONTENT, (MPARAM)somSelf, pPCI);

        return ((ULONG)pPCI);
    }
    return (0);
}

/*
 *@@ xwpCancelProcessOrderedContent:
 *      this method cancels a folder content process started with
 *      XFolder::xwpBeginProcessOrderedContent; hPOC must the handle
 *      returned by that function.
 *
 *      Warning: After folder content processing has finished, hPOC is
 *      no longer valid, and calling this function then will simply
 *      crash the WPS. As a result, your callback function MUST keep
 *      track if hPOC is still valid; after the callback func has been
 *      called with msg == 0, calling this function is no longer allowed.
 */

SOM_Scope BOOL  SOMLINK xf_xwpCancelProcessOrderedContent(XFolder *somSelf,
                                                          ULONG hPOC)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpCancelProcessOrderedContent");

    ((PPROCESSCONTENTINFO)hPOC)->fCancelled = TRUE;

    return (TRUE);
}

/*
 *@@ xwpMakeFavoriteFolder:
 *      if fInsert is TRUE, this folder will be made a "favorite folder",
 *      i.e. added to all context menus; if FALSE, it will be removed.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 */

SOM_Scope ULONG  SOMLINK xf_xwpMakeFavoriteFolder(XFolder *somSelf,
                                                  BOOL fInsert)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);

    XFolderMethodDebug("XFolder","xf_xwpMakeFavoriteFolder");

    return (fdrAddToList(somSelf,
                         pllFavoriteFolders,
                         fInsert,
                         INIKEY_FAVORITEFOLDERS));
}

/*
 *@@ xwpIsFavoriteFolder:
 *      returns TRUE if somSelf is on the list of "favorite" folders.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 */

SOM_Scope BOOL  SOMLINK xf_xwpIsFavoriteFolder(XFolder *somSelf)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);
    XFolderMethodDebug("XFolder","xf_xwpIsFavoriteFolder");

    return (fdrIsOnList(somSelf,
                        pllFavoriteFolders));
}

/*
 *@@ xwpSetQuickOpen:
 *      if fQuickOpen == TRUE, somSelf will automatically be
 *      populated at WPS bootup.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 */

SOM_Scope ULONG  SOMLINK xf_xwpSetQuickOpen(XFolder *somSelf,
                                            BOOL fQuickOpen)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);
    XFolderMethodDebug("XFolder","xf_xwpSetQuickOpen");

    return (fdrAddToList(somSelf,
                         pllQuickOpenFolders,
                         fQuickOpen,
                         INIKEY_QUICKOPENFOLDERS));
}

/*
 *@@ xwpQueryQuickOpen:
 *      returns TRUE if somSelf has the QuickOpen feature ON.
 *
 *@@changed V0.9.0 [umoeller]: updated for new linklist.c functions
 */

SOM_Scope BOOL  SOMLINK xf_xwpQueryQuickOpen(XFolder *somSelf)
{
    // XFolderData     *somThis = XFolderGetData(somSelf);
    // M_XFolderData   *somThat = M_XFolderGetData(_XFolder);
    XFolderMethodDebug("XFolder","xf_xwpSetQuickOpen");

    return (fdrIsOnList(somSelf,
                        pllQuickOpenFolders));
}

/*
 *@@ xwpQueryMenuBarVisibility:
 *      returns TRUE or FALSE if Warp 4's folder bar is
 *      currently visible for this folder. On Warp 3, this
 *      always returns FALSE.
 *
 *      Warp 4 does have a method for querying this, but we want
 *      XWorkplace to run on Warp 3 also, so I have rewritten this.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpQueryMenuBarVisibility(XFolder *somSelf)
{
    BOOL        brc = FALSE;
    XFolderMethodDebug("XFolder","xf_xwpQueryMenuBarVisibility");

    if (doshIsWarp4())
    {
        XFolderData *somThis = XFolderGetData(somSelf);
        // to find out whether the menu bar has been enabled,
        // check the FDRLONGARRAY (xfldr.idl) to which we have
        // obtained a pointer using the ugly kludge in
        // XFolder::wpRestoreData
        if (_pFldrLongArray)
        {
            // _Pmpf(("cbFldrLongArray: %d", _cbFldrLongArray));
            ULONG   ulMenuBarVisibility = _pFldrLongArray->ulMenuBarVisibility;
                        // 0 = off, 1 = on, 2 = default
            if (ulMenuBarVisibility == 1)
                brc = TRUE;
            else if (ulMenuBarVisibility == 2)
            {
                CHAR    szTemp[20] = "";
                // default value set: get the default value
                PrfQueryProfileString(HINI_USER,
                                      "PM_Workplace",
                                      "FolderMenuBar",
                                      "OFF",
                                      szTemp,
                                      sizeof(szTemp));
                if (strcmp(szTemp, "ON") == 0)
                    brc = TRUE;
            }
        }
    }

    return (brc);
}

/*
 *@@ xwpSetStatusBarVisibility:
 *      this new instance method sets the status bar visibility of
 *      a folder.
 *      ulVisibility may be:
 *      -- STATUSBAR_ON:        show status bars
 *      -- STATUSBAR_OFF:       hide status bars
 *      -- STATUSBAR_DEFAULT:   use GLOBALSETTINGS for this folder
 *
 *      If fUpdate is TRUE, XFolder will have the Worker thread search
 *      for open folder views and update their frame controls accordingly.
 *      Otherwise the status bar setting will only be changed internally
 *      for the next time the folder is opened. Might lead to errors.
 *      Returns TRUE if successful.
 */

SOM_Scope BOOL  SOMLINK xf_xwpSetStatusBarVisibility(XFolder *somSelf,
                                                     ULONG ulVisibility,
                                                     BOOL fUpdate)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpSetStatusBarVisibility");

    if (_bStatusBarInstance != ulVisibility)
    {
        #ifdef DEBUG_STATUSBARS
            _Pmpf(( "xwpSetStatusBarVisibility: %d", ulVisibility));
        #endif
        _bStatusBarInstance = ulVisibility;

        if (fUpdate)
        {
            // update open folder views in Worker thread;
            // this will call fncbUpdateStatusBars for each
            // open folder window
            xthrPostWorkerMsg(WOM_UPDATEALLSTATUSBARS,
                             (MPARAM)1,      // show/hide flag
                             MPNULL);
            // update "XFolder" notebook page, if open
            ntbUpdateVisiblePage(somSelf, SP_XFOLDER_FLDR);
        }
    }
    return (TRUE);
}

/*
 *@@ xwpQueryStatusBarVisibility:
 *      this new instance method returns the status bar visibility of
 *      a folder:
 *      -- STATUSBAR_ON:        status bars visible
 *      -- STATUSBAR_OFF:       status bars invisible
 *      -- STATUSBAR_DEFAULT:   GLOBALSETTINGS used for this folder
 *
 *@@changed V0.9.0 [umoeller]: function prototype changed
 */

SOM_Scope ULONG  SOMLINK xf_xwpQueryStatusBarVisibility(XFolder *somSelf)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpQueryStatusBarVisibility");

    return (_bStatusBarInstance);
}

/*
 *@@ xwpUpdateStatusBar:
 *      this method gets called when the status bar needs updating.
 *
 *      To be more precise, it is fdr_fnwpStatusBar which calls this
 *      method after it has received STBM_UPDATESTATUSBAR and the
 *      update timer has elapsed.
 *
 *      This method has been introduced for two reasons:
 *
 *      a)   you can call it yourself if you want to update the
 *           status bar;
 *
 *      b)   you can override this method if you wish to have a
 *           different status bar display. This method gets called
 *           using SOM name-lookup resolution, so you can even
 *           override this method if you don't want to derive your
 *           folder class from XFolder. Simply define a method with
 *           the same prototype in your WPFolder subclass, and your
 *           method will get called instead of this default one.
 *
 *           See the XWPTrashCan class (xtrash.c) for how this can
 *           be done.
 *
 *           See the SOM Programming Guide for details about name-lookup
 *           method resolution.
 *
 *      It is the responsibility of this method to completely compose
 *      the status bar text (according to the container contents) and
 *      set the status bar to that text. You can use a simple
 *      WinSetWindowText(hwndStatusBar, ...) for that.
 *
 *      This method calls stbComposeText (statbars.c) per default,
 *      which translates all status bar mnemonics except for the
 *      $x flags (tabulators), which are evaluated during WM_PAINT
 *      of fdr_fnwpStatusBar only.
 *
 *      hwndStatusbar has the HWND of the status bar window (a child
 *      of the folder frame). The QWL_USER window word of that
 *      window points to a STATUSBARDATA structure (statbars.h)
 *      containing more information.
 *
 *      hwndCnr is the container HWND of the folder view to which
 *      the status bar has been added.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_xwpUpdateStatusBar(XFolder *somSelf,
                                              HWND hwndStatusBar,
                                              HWND hwndCnr)
{
    PSZ psz;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpUpdateStatusBar");

    psz = stbComposeText(somSelf,
                         hwndCnr);
    if (psz)
    {
        WinSetWindowText(hwndStatusBar, psz);
        free(psz);
    }

    return (psz != 0);
}

/*
 *@@ xwpForEachOpenView:
 *      this instance method goes through all open views of a folder and calls
 *      pfnwpCallback for each them (as opposed to M_XFolder::xwpclsForEachOpenView,
 *      which goes through all open folders on the system).
 *
 *      The following params are then passed to pfnwpCallback:
 *      --   HWND       hwnd: the hwnd of the view frame window;
 *      --   ULONG      mp1:  the view type (as def'd in wpOpen)
 *      --   XFolder*   mp2:  somSelf.
 *
 *      This method does not return until all views have been processed.
 *      You might want to call this method in a different thread if the task
 *      will take long.
 *
 *      This method returns TRUE if the callback returned TRUE at least once.
 *      Note on disk objects/root folders: the WPS does not maintain an open
 *      view list for root folders, but only for the corresponding disk object.
 *      xwpForEachOpenView will call open disk views also, but the callback
 *      will still be passed the root folder in pFolder!
 */

SOM_Scope BOOL  SOMLINK xf_xwpForEachOpenView(XFolder *somSelf,
                                              ULONG ulMsg,
                                              PFNWP pfnwpCallback)
{
    BOOL brc = FALSE;
    WPObject *somSelf2;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpForEachOpenView");

    if (_somIsA(somSelf, _WPRootFolder))
        // for disk/root folder views: root folders have no
        // open view, instead the disk object is registered
        // to have the open view. Duh. So we need to find
        // the disk object first
        somSelf2 = _xwpclsQueryDiskObject(_XFldDisk, somSelf);
    else
        somSelf2 = somSelf;

    if (somSelf2)
    {
        if (_wpFindUseItem(somSelf2, USAGE_OPENVIEW, NULL))
        {   // folder has an open view;
            // now we go search the open views of the folder and get the
            // frame handle of the desired view (ulView) */
            PVIEWITEM   pViewItem;
            for (pViewItem = _wpFindViewItem(somSelf2, VIEW_ANY, NULL);
                pViewItem;
                pViewItem = _wpFindViewItem(somSelf2, VIEW_ANY, pViewItem))
            {
                if ((*pfnwpCallback)(pViewItem->handle,
                                     ulMsg,
                                     (MPARAM)pViewItem->view,
                                     // but even if we have found a disk object
                                     // above, we need to pass it the root folder
                                     // pointer, because otherwise the callback
                                     // might get into trouble
                                     (MPARAM)somSelf)
                            == (MPARAM)TRUE)
                    brc = TRUE;
            } // end for
        } // end if
    }
    return (brc);
}

/*
 *@@ xwpAddXFolderPages:
 *      this adds the "XFolder" page into a folder settings notebook.
 */

SOM_Scope ULONG  SOMLINK xf_xwpAddXFolderPages(XFolder *somSelf,
                                               HWND hwndDlg)
{
    PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
    memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

    XFolderMethodDebug("XFolder","xf_xwpAddXFolderPages");

    pcnbp->somSelf = somSelf;
    pcnbp->hwndNotebook = hwndDlg;
    pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
    pcnbp->ulDlgID = ID_XSD_SETTINGS_FLDR1;
    pcnbp->ulPageID = SP_XFOLDER_FLDR;
    pcnbp->usPageStyleFlags = BKA_MAJOR;
    pcnbp->pszName = "~XFolder";
    pcnbp->ulDefaultHelpPanel  = ID_XSH_SETTINGS_FLDR1;
    pcnbp->pfncbInitPage    = fdrXFolderInitPage;
    pcnbp->pfncbItemChanged = fdrXFolderItemChanged;

    return (ntbInsertPage(pcnbp));
}

/*
 *@@ xwpQuerySetup2:
 *      this XFldObject method is overridden to support
 *      setup strings for folders.
 *
 *      See XFldObject::xwpQuerySetup2 for details.
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_xwpQuerySetup2(XFolder *somSelf,
                                           PSZ pszSetupString,
                                           ULONG cbSetupString)
{
    ULONG ulReturn = 0;

    // resolve method for XFldObject
    somTD_XFldObject_xwpQuerySetup pfn_xwpQuerySetup2 = SOM_Resolve(somSelf,
                                                                    XFldObject,
                                                                    xwpQuerySetup2);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_xwpQuerySetup2");

    if (pfn_xwpQuerySetup2)
    {
        // call XFolder implementation
        ulReturn = fdrQuerySetup(somSelf, pszSetupString, cbSetupString);

        // now call XFldObject method
        if ( (pszSetupString) && (cbSetupString) )
            // string buffer already specified:
            // tell XFldObject to append to that string
            ulReturn += pfn_xwpQuerySetup2(somSelf,
                                           pszSetupString + ulReturn, // append to existing
                                           cbSetupString + ulReturn);
        else
            // string buffer not yet specified:
            // return length only
            ulReturn += pfn_xwpQuerySetup2(somSelf, 0, 0);
    }

    return (ulReturn);
}

/*
 *@@ wpInitData:
 *      this instance method gets called when the object
 *      is being initialized. We initialize our instance
 *      data here.
 */

SOM_Scope void  SOMLINK xf_wpInitData(XFolder *somSelf)
{
    // PGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpInitData");

    XFolder_parent_WPFolder_wpInitData(somSelf);

    // set all the instance variables to safe defaults
    _bSnapToGridInstance = 2;
    _bFullPathInstance = 2;
    _bFolderHotkeysInstance = 2;
    _bStatusBarInstance = STATUSBAR_DEFAULT;
    _bAlwaysSortInstance = SET_DEFAULT;
    _bDefaultSortInstance = SET_DEFAULT;
    // _ulSBInflatedFrame = 0;

    _pFldrSortInfo = NULL;
    _pFldrLongArray = NULL;
    _pszFldrStrArray = NULL;
    _cbFldrStrArray = 0;
    _cbFldrLongArray = 0;

    _pFldrBackground = NULL;
    _cbFldrBackground = 0;

    _pulShowAllInTreeView = NULL;

    _pszFdrBkgndImageFile = 0;

    _fUnInitCalled = FALSE;
    _hwndCnrSaved = NULLHANDLE;

    _pfnUpdateStatusBar = NULL;
}

/*
 *@@ wpObjectReady:
 *      this is called upon an object when its creation
 *      or awakening is complete. This is the last method
 *      which gets called during instantiation of a
 *      WPS object when it has completely initialized
 *      itself. ulCode signifies the cause of object
 *      instantiation.
 *
 *      We will have this object's pointer stored
 *      in a global list (maintained by the Worker thread)
 *      so that XShutdown knows which objects are currently
 *      awake.
 *
 *      Note: XFldObject::wpObjectReady already does this
 *      for all objects, but on my Warp 4 (FP 10), that
 *      method does _not_ get called for WPFolder instances,
 *      so we override this method for XFolder also.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope void  SOMLINK xf_wpObjectReady(XFolder *somSelf,
                                         ULONG ulCode,
                                         WPObject* refObject)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpObjectReady");

    #if defined(DEBUG_SOMMETHODS) || defined(DEBUG_AWAKEOBJECTS)
        _Pmpf(("xfobj_wpObjectReady for %s (class %s), ulCode: %s",
                _wpQueryTitle(somSelf),
                _somGetName(_somGetClass(somSelf)),
                (ulCode == OR_AWAKE) ? "OR_AWAKE"
                : (ulCode == OR_FROMTEMPLATE) ? "OR_FROMTEMPLATE"
                : (ulCode == OR_FROMCOPY) ? "OR_FROMCOPY"
                : (ulCode == OR_NEW) ? "OR_NEW"
                : (ulCode == OR_SHADOW) ? "OR_SHADOW"
                : (ulCode == OR_REFERENCE) ? "OR_REFERENCE"
                : "unknown code"
             ));
    #endif

    XFolder_parent_WPFolder_wpObjectReady(somSelf, ulCode, refObject);

    xthrPostWorkerMsg(WOM_ADDAWAKEOBJECT,
                     (MPARAM)somSelf,
                     MPNULL);
}

/*
 *@@ wpUnInitData:
 *      clean up when object is deleted or made dormant.
 */

SOM_Scope void  SOMLINK xf_wpUnInitData(XFolder *somSelf)
{
    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpUnInitData");

    // make sure we only do this once, because we
    // seem to get called several times sometimes
    if (!_fUnInitCalled)
        _fUnInitCalled = TRUE;

    if (_pszFdrBkgndImageFile)
        free(_pszFdrBkgndImageFile);

    XFolder_parent_WPFolder_wpUnInitData(somSelf);
        // fixed this (V0.9.0)
}

/*
 *@@ wpFree:
 *      this WPObject method destroys the persistent form of the object
 *      and then frees the memory that represented that object.
 *
 *      For WPFolders, this is called when a folder is actually to be
 *      deleted. We will call the parent method and then also remove
 *      those darn PMWorkplace:FolderPos entries which the WPS never
 *      deletes.
 *
 *      If the folder is somewhere in the config folder hierarchy,
 *      we also invalidate the config folder caches in menus.c.
 *
 *@@changed V0.9.0 [umoeller]: adjusted to new config folder handling
 */

SOM_Scope BOOL  SOMLINK xf_wpFree(XFolder *somSelf)
{
    BOOL        brc;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    HOBJECT     hObj = NULLHANDLE;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpFree");

    if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // invalidate the content lists for the config
        // folders so that they will be rebuilt
        mnuInvalidateConfigCache();
    }

    if (pGlobalSettings->CleanupINIs)
    {
        // "clean up INI files": get object handle for
        // folderpos deletion later. This doesn't hurt
        // because every folder has a handle once it has
        // been opened
        hObj = _wpQueryHandle(somSelf);
    }

    // according to WPS docs, the parent method should be called
    // AFTER additional processing; probably somSelf becomes invalid
    // after this
    brc = XFolder_parent_WPFolder_wpFree(somSelf);

    if (brc)
        // successfully deleted:
        if (hObj)
            // have FOLDERPOS entries
            // deleted by Worker thread; we only pass the
            // object HANDLE and not somSelf because somSelf
            // is no longer valid after having called the parent
            xthrPostWorkerMsg(WOM_DELETEFOLDERPOS,
                             (MPARAM)hObj, NULL);

    return (brc);
}

/*
 *@@ wpSetup:
 *      this instance method is called to allow a
 *      newly created object to initialize itself.
 *      XFolder will examine its setup strings here.
 *
 *@@changed V0.9.1 (2000-01-03) [umoeller]: now processing our own strings first
 */

SOM_Scope BOOL  SOMLINK xf_wpSetup(XFolder *somSelf, PSZ pszSetupString)
{
    BOOL        rc = FALSE,             // processed
                fChanged = FALSE,       // instance data changed
                fCallParent = TRUE;
    CHAR        szValue[CCHMAXPATH + 1];
    ULONG       cbValue;

    XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpSetup");

    rc = (XFolder_parent_WPFolder_wpSetup(somSelf, pszSetupString));

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "SNAPTOGRID", szValue, &cbValue))
    {
        rc = TRUE;
        fChanged = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _bSnapToGridInstance = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            _bSnapToGridInstance = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            _bSnapToGridInstance = 2;
        else if (strnicmp(szValue, "EXEC", 4) == 0)
        {
            fdrSnapToGrid(somSelf, FALSE);
            fChanged = FALSE;
        }
        else
        {
            fChanged = FALSE;
            rc = FALSE;
        }
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "FULLPATH", szValue, &cbValue))
    {
        fChanged = TRUE;
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _bFullPathInstance = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            _bFullPathInstance = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            _bFullPathInstance = 2;

        fdrUpdateAllFrameWndTitles(somSelf);
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "ACCELERATORS", szValue, &cbValue))
    {
        fChanged = TRUE;
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _bFolderHotkeysInstance = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            _bFolderHotkeysInstance = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            _bFolderHotkeysInstance = 2;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "FAVORITEFOLDER", szValue, &cbValue))
    {
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _xwpMakeFavoriteFolder(somSelf, FALSE);
        else if (strnicmp(szValue, "YES", 3) == 0)
            _xwpMakeFavoriteFolder(somSelf, TRUE);
        // fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "QUICKOPEN", szValue, &cbValue))
    {
        rc = TRUE;
        if (strnicmp(szValue, "NO", 2) == 0)
            _xwpSetQuickOpen(somSelf, FALSE);
        else if (strnicmp(szValue, "YES", 3) == 0)
            _xwpSetQuickOpen(somSelf, TRUE);
        // fChanged = TRUE;
    }

    if (somSelf != _wpclsQueryActiveDesktop(_WPDesktop))
    {
        cbValue = sizeof(szValue);
        if (_wpScanSetupString(somSelf, pszSetupString,
                               "STATUSBAR", szValue, &cbValue))
        {
            rc = TRUE;
            if (strnicmp(szValue, "NO", 2) == 0)
                _bStatusBarInstance = STATUSBAR_OFF;
            else if (strnicmp(szValue, "YES", 3) == 0)
                _bStatusBarInstance = STATUSBAR_ON;
            else if (strnicmp(szValue, "DEFAULT", 7) == 0)
                _bStatusBarInstance = STATUSBAR_DEFAULT;
        }
        xthrPostWorkerMsg(WOM_UPDATEALLSTATUSBARS,
                          (MPARAM)1,  // show/hide flag
                          MPNULL);
        fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "ALWAYSSORT", szValue, &cbValue))
    {
        USHORT      usDefaultSort, usAlwaysSort;

        rc = TRUE;
        _xwpQueryFldrSort(somSelf, &usDefaultSort, &usAlwaysSort);

        if (strnicmp(szValue, "NO", 2) == 0)
            usAlwaysSort = 0;
        else if (strnicmp(szValue, "YES", 3) == 0)
            usAlwaysSort = 1;
        else if (strnicmp(szValue, "DEFAULT", 7) == 0)
            usAlwaysSort = SET_DEFAULT;
        _xwpSetFldrSort(somSelf, usDefaultSort, usAlwaysSort);
        // fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "DEFAULTSORT", szValue, &cbValue))
    {
        USHORT      usDefaultSort = 0,
                    usAlwaysSort = 0;
        LONG lValue;

        rc = TRUE;
        _xwpQueryFldrSort(somSelf, &usDefaultSort, &usAlwaysSort);

        sscanf(szValue, "%d", &lValue);
        if ( (lValue >=0) && (lValue <= SV_LAST) )
            usDefaultSort = lValue;
        else
            usDefaultSort = SET_DEFAULT;
        _xwpSetFldrSort(somSelf, usDefaultSort, usAlwaysSort);
        // fChanged = TRUE;
    }

    cbValue = sizeof(szValue);
    if (_wpScanSetupString(somSelf, pszSetupString,
                           "SORTNOW", szValue, &cbValue))
    {
        USHORT usSort;
        LONG lValue;

        sscanf(szValue, "%d", &lValue);
        if ( (lValue >=0) && (lValue <= SV_LAST) )
            usSort = lValue;
        else
            usSort = SET_DEFAULT;

        _xwpclsForEachOpenView(_XFolder,
                               usSort,
                               fdrSortAllViews);
    }

    if (fChanged)
        _wpSaveDeferred(somSelf);

    return (rc);
}

/*
 *@@ wpSaveState:
 *      this instance method is called to allow an
 *      an object to save its state; XFolder will
 *      save its instance settings (NB page) here.
 */

SOM_Scope BOOL  SOMLINK xf_wpSaveState(XFolder *somSelf)
{
    BOOL brc = FALSE;
    XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpSaveState");

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("%s: wpSaveState", _wpQueryTitle(somSelf)));
    #endif

    // we will now save all our instance data; in order
    // not to blow up the EA size too much, we will only
    // save data which is different from the "transparent"
    // (i.e. Global) setting

    if (_bSnapToGridInstance != 2)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 1, (ULONG)_bSnapToGridInstance);
    if (_bFullPathInstance != 2)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 2, (ULONG)_bFullPathInstance);
    if (_bFolderHotkeysInstance != 2)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 3, (ULONG)_bFolderHotkeysInstance);
    if (_bStatusBarInstance != STATUSBAR_DEFAULT)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 4, (ULONG)_bStatusBarInstance);
    /* if (_ulSBInflatedFrame)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 5, (ULONG)_ulSBInflatedFrame); */
    if (_bAlwaysSortInstance != SET_DEFAULT)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 6, (ULONG)_bAlwaysSortInstance);
    if (_bDefaultSortInstance != SET_DEFAULT)
        _wpSaveLong(somSelf, (PSZ)pcszXFolder, 7, (ULONG)_bDefaultSortInstance);

    brc = XFolder_parent_WPFolder_wpSaveState(somSelf);

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("%s: End of wpSaveState", _wpQueryTitle(somSelf)));
    #endif

    return (brc);
}

/*
 *@@ wpRestoreState:
 *      this instance method is called to allow an
 *      an object to restore its state; XFolder will
 *      restore its instance settings (NB page) here.
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreState(XFolder *somSelf,
                                             ULONG ulReserved)
{
    ULONG   ul;
    BOOL    brc;
    XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpRestoreState");

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpRestoreState for %s", _wpQueryTitle(somSelf) ));
    #endif

    // we will now restore all the different XFolder settings
    // into the instance data; note that if _wpRestoreLong
    // returns FALSE (i.e. setting not found), we always use
    // the "transparent" value which makes this folder use
    // the corresponding Global Setting

    if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 1, &ul))
        _bSnapToGridInstance = (BYTE)ul;
    else _bSnapToGridInstance = 2;

    if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 2, &ul))
        _bFullPathInstance = (BYTE)ul;
    else _bFullPathInstance = 2;

    if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 3, &ul))
        _bFolderHotkeysInstance = (BYTE)ul;
    else _bFolderHotkeysInstance = 2;

    if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 4, &ul))
        _bStatusBarInstance = (BYTE)ul;
    else _bStatusBarInstance = STATUSBAR_DEFAULT;

    /* if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 5, &ul))
        _ulSBInflatedFrame = (BYTE)ul;
    else _ulSBInflatedFrame = 0; */

    if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 6, &ul))
        _bAlwaysSortInstance = (USHORT)ul;

    if (_wpRestoreLong(somSelf, (PSZ)pcszXFolder, 7, &ul))
        _bDefaultSortInstance = (USHORT)ul;

    brc = (XFolder_parent_WPFolder_wpRestoreState(somSelf, ulReserved));

    #if defined DEBUG_RESTOREDATA || defined DEBUG_SOMMETHODS
        _Pmpf(("  End of XFolder::wpRestoreState"));
    #endif

    return (brc);
}

/*
 *@@ IdentifyRestoreID:
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

PSZ IdentifyRestoreID(PSZ pszClass,
                      ULONG ulKey)
{
    if (strcmp(pszClass, "WPFolder") == 0)
    {
        switch (ulKey)
        {
            case IDKEY_FDRCONTENTATTR    : // 2900
                return ("IDKEY_FDRCONTENTATTR");
            case IDKEY_FDRTREEATTR       : // 2901
                return ("IDKEY_FDRTREEATTR");
            case IDKEY_FDRCVLFONT        : // 2902
                return ("IDKEY_FDRCVLFONT");
            case IDKEY_FDRCVNFONT        : // 2903
                return ("IDKEY_FDRCVNFONT");
            case IDKEY_FDRCVIFONT        : // 2904
                return ("IDKEY_FDRCVIFONT");
            case IDKEY_FDRTVLFONT        : // 2905
                return ("IDKEY_FDRTVLFONT");
            case IDKEY_FDRTVNFONT        : // 2906
                return ("IDKEY_FDRTVNFONT");
            case IDKEY_FDRDETAILSATTR    : // 2907
                return ("IDKEY_FDRDETAILSATTR");
            case IDKEY_FDRDVFONT         : // 2908
                return ("IDKEY_FDRDVFONT");
            case IDKEY_FDRDETAILSCLASS   : // 2909
                return ("IDKEY_FDRDETAILSCLASS");
            case IDKEY_FDRICONPOS        : // 2910
                return ("IDKEY_FDRICONPOS");
            case IDKEY_FDRINVISCOLUMNS   : // 2914
                return ("IDKEY_FDRINVISCOLUMNS");
            case IDKEY_FDRINCCLASS       : // 2920
                return ("IDKEY_FDRINCCLASS");
            case IDKEY_FDRINCNAME        : // 2921
                return ("IDKEY_FDRINCNAME");
            case IDKEY_FDRFSYSSEARCHINFO : // 2922
                return ("IDKEY_FDRFSYSSEARCHINFO");
            case IDKEY_FILTERCONTENT     : // 2923
                return ("IDKEY_FILTERCONTENT");
            case IDKEY_CNRBACKGROUND     : // 2924
                return ("IDKEY_CNRBACKGROUND");
            case IDKEY_FDRINCCRITERIA    : // 2925
                return ("IDKEY_FDRINCCRITERIA");
            case IDKEY_FDRICONVIEWPOS    : // 2926
                return ("IDKEY_FDRICONVIEWPOS");
            case IDKEY_FDRSORTCLASS      : // 2927
                return ("IDKEY_FDRSORTCLASS");
            case IDKEY_FDRSORTATTRIBS    : // 2928
                return ("IDKEY_FDRSORTATTRIBS");
            case IDKEY_FDRSORTINFO       : // 2929
                return ("IDKEY_FDRSORTINFO");
            case IDKEY_FDRSNEAKYCOUNT    : // 2930
                return ("IDKEY_FDRSNEAKYCOUNT");
            case IDKEY_FDRLONGARRAY      : // 2931
                return ("IDKEY_FDRLONGARRAY");
            case IDKEY_FDRSTRARRAY       : // 2932
                return ("IDKEY_FDRSTRARRAY");
            case IDKEY_FDRCNRBACKGROUND  : // 2933
                return ("IDKEY_FDRCNRBACKGROUND");
            case IDKEY_FDRBKGNDIMAGEFILE : // 2934
                return ("IDKEY_FDRBKGNDIMAGEFILE");
            case IDKEY_FDRBACKGROUND     : // 2935
                return ("IDKEY_FDRBACKGROUND");
            case IDKEY_FDRSELFCLOSE      : // 2936
                return ("IDKEY_FDRSELFCLOSE");

            case 2937:
                return ("IDKEY_FDRODMENUBARON");
            case 2938:
                return ("IDKEY_FDRGRIDINFO");
            case 2939:
                return ("IDKEY_FDRTREEVIEWCONTENTS");
        }
    }

    return ("unknown");
}

/*
 *@@ wpRestoreLong:
 *      this instance method restores a 32-bit data
 *      value from the folder EAs upon object awakening.
 *      We check the "ulKey" value after having called
 *      the parent to be able to intercept the pointer
 *      to certain WPS-internal folder data, which
 *      we cannot access otherwise. That's a real ugly
 *      kludge, but there's no other way to get certain
 *      folder settings. ;-)
 *
 *      On Warp 4, the WPS queries the
 *      IDKEY_FDRTREEVIEWCONTENTS key here, which is
 *      == 1 if the "SHOWALLINTREEVIEW" flag is on.
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreLong(XFolder *somSelf, PSZ pszClass,
                                         ULONG ulKey, PULONG pulValue)
{
    BOOL        brc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpRestoreLong");

    brc = XFolder_parent_WPFolder_wpRestoreLong(somSelf, pszClass,
                                                  ulKey, pulValue);

    if (strcmp(pszClass, "WPFolder") == 0)
    {
        switch (ulKey)
        {
            // Warp 4
            #ifndef IDKEY_FDRTREEVIEWCONTENTS
                #define IDKEY_FDRTREEVIEWCONTENTS 2939
            #endif

            case IDKEY_FDRTREEVIEWCONTENTS:
            {
                // then the pointer given to this method (pValue) must
                // be the pointer to the WPFolder-internal SHOWALLINTREEVIEW
                // flag
                    if (pulValue)
                    {
                        XFolderData *somThis = XFolderGetData(somSelf);
                        _pulShowAllInTreeView = pulValue;
                    }
            break; }
        }

        if (pulValue)
            _Pmpf(("Long %s (%s %d) --> 0x%lX",
                    IdentifyRestoreID(pszClass, ulKey),
                    pszClass, ulKey,
                    *pulValue));        // data returned
    }
    return (brc);
}

/*
 *@@ wpRestoreString:
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreString(XFolder *somSelf,
                                           PSZ pszClass, ULONG ulKey,
                                           PSZ pszValue, PULONG pcbValue)
{
    BOOL brc = FALSE;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpRestoreString");

    brc = XFolder_parent_WPFolder_wpRestoreString(somSelf,
                                                  pszClass, ulKey,
                                                  pszValue, pcbValue);

    if (strcmp(pszClass, "WPFolder") == 0)
    {
        switch (ulKey)
        {
            case IDKEY_FDRBKGNDIMAGEFILE: // 2934
                if ((pszValue) && (brc))
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _pszFdrBkgndImageFile = strdup(pszValue);
                }
            break;
        }

        if ((pszValue) && (brc))
            _Pmpf(("Strg %s (%s %d) --> %s",
                    IdentifyRestoreID(pszClass, ulKey),
                    pszClass, ulKey,
                    pszValue));        // data returned
    }


    return (brc);
}

/*
 *@@ wpRestoreData:
 *      this instance method restores binary instance
 *      data from the folder EAs upon object awakening.
 *      We check the "ulKey" value after having called
 *      the parent to be able to intercept the pointer
 *      to certain WPS-internal folder data, which
 *      we cannot access otherwise. That's a real ugly
 *      kludge, but there's no other way to get certain
 *      folder settings. ;-)
 *
 *      On Warp 4, the WPS queries lots of sort and
 *      folder view settings here, whose pointers we
 *      can store in XFolder's instance data.
 */

SOM_Scope BOOL  SOMLINK xf_wpRestoreData(XFolder *somSelf,
                                         PSZ pszClass, ULONG ulKey,
                                         PBYTE pValue, PULONG pcbValue)
{
    BOOL        brc;
    ULONG       cbOrigValue = 0;
    // XFolderMethodDebug("XFolder","xf_wpRestoreData");

    // get the size of the buffer which was given to us
    if (pValue)
        // pValue given:
        cbOrigValue = *pcbValue;
    // else: caller is requesting the size of the data

    // always call parent, even for the sort data, or
    // the WPFolder original gets confused
    brc = XFolder_parent_WPFolder_wpRestoreData(somSelf,
                                                pszClass, ulKey,
                                                pValue, pcbValue);

    // after we have restored the setting by calling the
    // default WPFolder method, we check for a few flags
    // which we might be interested in; we can then store
    // the pointer to WPS-internal data in XFolder instance
    // data
    if (strcmp(pszClass, "WPFolder") == 0)
    {
        // #ifdef DEBUG_RESTOREDATA
        if ((pValue) && (brc))
            _Pmpf(("Data %s (%s %d) size_in %d -> out %d",
                    IdentifyRestoreID(pszClass, ulKey),
                    pszClass, ulKey,
                    cbOrigValue,    // size in or 0 if size queried
                    *pcbValue));    // size out
        // #endif

        switch (ulKey)
        {
            case IDKEY_FDRSORTINFO:
            {
                // then the pointer given to this method (pValue) must
                // be the pointer to the WPFolder-internal FDRSORTINFO
                // structure (undocumented, I've declared it in
                // xfldr.idl); we store this pointer in the instance
                // data so that we can manipulate it later
                if (cbOrigValue == sizeof(FDRSORTINFO))
                {
                    if (pValue)
                    {
                        XFolderData *somThis = XFolderGetData(somSelf);
                        _pFldrSortInfo = (PFDRSORTINFO)pValue;

                        if (brc)
                            // if the parent method has found sort data,
                            // and the user had set "Always sort" on for
                            // the folder using the regular WPS "Sort" page,
                            // we need to update the XFolder sort data, but
                            // only update this if this hasn't been set
                            // by wpRestoreState yet; as a result, the
                            // XFolder sort settings will follow the WPFolder
                            // sort settings, but can be overridden
                            if (_bAlwaysSortInstance == SET_DEFAULT) // not set yet?
                                _bAlwaysSortInstance = ((PFDRSORTINFO)pValue)->fAlwaysSort;
                    }
                }
                // _Pmpf(("IDKEY_FDRSORTINFO size %d -> %d", cbOrigValue, *pcbValue));
            break; }

            case IDKEY_FDRBACKGROUND:       // size: 2 bytes
                if (pValue)
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _cbFldrBackground = *pcbValue;
                    _pFldrBackground = (PVOID)pValue;
                }
            break;

            /* case IDKEY_FDRCNRBACKGROUND:
                _Pmpf(("%s::wpRestoreString: IDKEY_FDRCNRBACKGROUND -> %d",
                       _wpQueryTitle(somSelf),
                       brc));
                if (pValue)
                {
                    XFolderData *somThis = XFolderGetData(somSelf);
                    _cbFdrCnrBackground = *pcbValue;
                    _pszFdrCnrBackground = pValue;     // buffer
                }
            break; */

            case IDKEY_FDRLONGARRAY:        // size: 84 bytes
            {
                XFolderData *somThis = XFolderGetData(somSelf);
                // store the size of the data returned in
                // folder instance data, in case it is not
                // 84 bytes (as it is with Warp 4 fixpak 8)
                _cbFldrLongArray = *pcbValue;
                if (pValue)
                    _pFldrLongArray = (PFDRLONGARRAY)pValue;
            break; }

            case IDKEY_FDRSTRARRAY:         // size: 400 bytes
            {
                XFolderData *somThis = XFolderGetData(somSelf);
                // store the size of the data returned in
                // folder instance data, in case it is not
                // 400 bytes (as it is with Warp 4 fixpak 8)
                if (pValue)
                {
                    _cbFldrStrArray = *pcbValue;
                    _pszFldrStrArray = (PSZ)pValue;
                }
            break; }

            /* case IDKEY_CNRBACKGROUND:
            {
                XFolderData *somThis = XFolderGetData(somSelf);
                if (pValue)
                {
                    _cbCnrBackground = *pcbValue;
                    _pvCnrBackground = pValue;
                }
            break; } */

            /*
             * the following others were queried for G:\root\test
             * under Warp 4 fixpak 8:
             */

            /*
                IDKEY_xxx (WPObject 11) size 32 -> 32           WPOBJECT_DATA
                IDKEY_xxx (WPObject 12) size 400 -> 400         WPOBJECT_STRINGS
                IDKEY_xxx (WPObject 4) size 8 -> 8              ?!?
                IDKEY_xxx (WPFolder 2924) size 542 -> 542       IDKEY_CNRBACKGROUND
                IDKEY_xxx (WPFolder 2920) size 542 -> 542       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 542 -> 542       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2938) size 8 -> 8           IDKEY_FDRGRIDINFO

            and these under Warp 3, no fixpaks:
                IDKEY_xxx (WPObject 11) size 28 -> 28           (+) four bytes less
                IDKEY_xxx (WPObject 12) size 400 -> 400         (+)
                IDKEY_xxx (WPObject 4) size 8 -> 8              (+)
                IDKEY_xxx (WPFolder 2924) size 542 -> 542       (+)
                IDKEY_xxx (WPFolder 2920) size 542 -> 542       (+)
                IDKEY_xxx (WPFolder 2925) size 542 -> 542       (+)
                i.e. the same, except the grid info

            but if we had a folder background set (Warp 4):
                IDKEY_xxx (WPObject 11) size 32 -> 32
                IDKEY_xxx (WPObject 12) size 400 -> 400
                IDKEY_xxx (WPObject 4) size 8 -> 8
                IDKEY_xxx (WPFolder 2924) size 542 -> 542       IDKEY_CNRBACKGROUND
                IDKEY_xxx (WPFolder 2920) size 542 -> 542       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 542 -> 107       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2920) size 260 -> 260       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 260 -> 107       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2925) size 107 -> 107       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2938) size 8 -> 8
            and on Warp 3:
                IDKEY_xxx (WPObject 11) size 28 -> 28
                IDKEY_xxx (WPObject 12) size 400 -> 400
                IDKEY_xxx (WPObject 4) size 8 -> 8
                                                            no  IDKEY_CNRBACKGROUND
                IDKEY_xxx (WPFolder 2920) size 259 -> 259       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 259 -> 178       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2920) size 260 -> 260       IDKEY_FDRINCCLASS
                IDKEY_xxx (WPFolder 2925) size 260 -> 178       IDKEY_FDRINCCRITERIA
                IDKEY_xxx (WPFolder 2925) size 178 -> 178       IDKEY_FDRINCCRITERIA

            */

            /* this is what we got from the "Programme" folder (Warp 4):

                 Long IDKEY_xxx (WPFileSystem 4) --> 0x0
                 Data IDKEY_xxx (WPObject 11) size 32 -> 32         WPOBJECT_DATA
                 Data IDKEY_xxx (WPObject 12) size 400 -> 400       WPOBJECT_STRINGS
                 Data IDKEY_xxx (WPObject 4) size 8 -> 8            ?!?
                 Data IDKEY_xxx (WPFolder 2924) size 542 -> 542     IDKEY_CNRBACKGROUND
                 Strg IDKEY_xxx (WPFolder 2921) --> NULL            IDKEY_FDRINCNAME
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 542       IDKEY_FDRINCCLASS
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107       IDKEY_FDRINCCRITERIA
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 260       * IDKEY_FDRINCCLASS
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107       * IDKEY_FDRINCCRITERIA
                 Data IDKEY_xxx (WPFolder 2925) size 107 -> 107     * IDKEY_FDRINCCRITERIA
                 Strg IDKEY_xxx (WPFolder 2921) -->                 * IDKEY_FDRINCNAME
                 Data IDKEY_xxx (WPFolder 2938) size 8 -> 8         IDKEY_FDRGRIDINFO
                 Long IDKEY_xxx (WPFolder 2939) --> 0x0             IDKEY_FDRTREEVIEWCONTENTS

                 Long IDKEY_xxx (WPFileSystem 4) --> 0x0
                 Data IDKEY_xxx (WPObject 11) size 32 -> 32
                 Data IDKEY_xxx (WPObject 12) size 400 -> 400
                 Data IDKEY_xxx (WPObject 4) size 8 -> 8
                 Strg IDKEY_xxx (WPFolder 2934) --> F:\OS2\BITMAP\PLASTER.BMP
                                                                    IDKEY_FDRCNRBACKGROUND
                 Strg IDKEY_xxx (WPFolder 2921) --> NULL
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 259
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107
                 Data IDKEY_xxx (WPFolder 2920) size 0 -> 260
                 Data IDKEY_xxx (WPFolder 2925) size 0 -> 107
                 Data IDKEY_xxx (WPFolder 2925) size 107 -> 107
                 Strg IDKEY_xxx (WPFolder 2921) --> F:\OS2\BITMAP\PLASTER.BMP
                                                                    IDKEY_FDRCNRBACKGROUND
                 Data IDKEY_xxx (WPFolder 2938) size 8 -> 8
                 Long IDKEY_xxx (WPFolder 2939) --> 0x0             IDKEY_FDRTREEVIEWCONTENTS

            */

            /*
             *  the following are apperently never queried
             *  (Warp 4 FP 8 German):
             */

            /*
                case IDKEY_FDRSORTATTRIBS:
                case IDKEY_FDRSORTCLASS:
                case IDKEY_FDRINVISCOLUMNS:
                case IDKEY_FDRCONTENTATTR:
                case IDKEY_FDRSNEAKYCOUNT:
                case IDKEY_FDRCNRBACKGROUND:
                case IDKEY_FDRBKGNDIMAGEFILE:
            */


        }   // end switch
    }

    return (brc);
}

/*
 *@@ wpAddFile1Page:
 *      this normally adds the first "File" page to
 *      the folder's settings notebook; if allowed,
 *      we will replace this with our own version,
 *      which combines the three "File" pages into
 *      one single page.
 *
 *      XFolder and XFldDataFile share the same
 *      notebook callbacks for this page, since we
 *      have no class replacement for WPFileSystem.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFile1Page(XFolder *somSelf,
                                           HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFile1Page");

    if (pGlobalSettings->fReplaceFilePage)
    {
        PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
        PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
        memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

        pcnbp->somSelf = somSelf;
        pcnbp->hwndNotebook = hwndNotebook;
        pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
        pcnbp->ulDlgID = ID_XSD_FILESPAGE;
        pcnbp->ulPageID = SP_FILE;
        pcnbp->usPageStyleFlags = BKA_MAJOR;
        pcnbp->pszName = pNLSStrings->pszFilePage;
        pcnbp->ulDefaultHelpPanel  = ID_XSH_SETTINGS_FILEPAGE;

        pcnbp->pfncbInitPage    = (PFNCBACTION)fsysFileInitPage;     // in xfdataf.c
        pcnbp->pfncbItemChanged = (PFNCBITEMCHANGED)fsysFileItemChanged;  // in xfdataf.c

        return (ntbInsertPage(pcnbp));
    }
    else
        return (XFolder_parent_WPFolder_wpAddFile1Page(somSelf, hwndNotebook));
}

/*
 *@@ wpAddFile2Page:
 *      this normally adds the second "File" page to
 *      the folder's settings notebook; since we
 *      combine the three "File" pages into one,
 *      we'll remove this page, if allowed.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFile2Page(XFolder *somSelf,
                                           HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFile2Page");

    if (pGlobalSettings->fReplaceFilePage)
        return (SETTINGS_PAGE_REMOVED);
    else
        return (XFolder_parent_WPFolder_wpAddFile2Page(somSelf, hwndNotebook));
}

/*
 *@@ wpAddFile3Page:
 *      this normally adds the second "File" page to
 *      the folder's settings notebook; since we
 *      combine the three "File" pages into one,
 *      we'll remove this page, if allowed.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFile3Page(XFolder *somSelf,
                                           HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFile3Page");

    if (pGlobalSettings->fReplaceFilePage)
        return (SETTINGS_PAGE_REMOVED);
    else
        return (XFolder_parent_WPFolder_wpAddFile3Page(somSelf, hwndNotebook));
}

/*
 *@@ wpAddFolderBackgroundPage:
 *      this normally adds the  "Background" page to
 *      the folder's settings notebook. We now use
 *      this method to add the "XFolder" page right
 *      before that by calling XFolder::xwpAddXFolderPages.
 *
 *      This has been changed with V0.9.0 so that the
 *      "XFolder" page no longer sits at the front of
 *      the settings notebook, but together with the
 *      other folder settings pages.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFolderBackgroundPage(XFolder *somSelf,
                                                      HWND hwndNotebook)
{
    BOOL    brc;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFolderBackgroundPage");

    brc = XFolder_parent_WPFolder_wpAddFolderBackgroundPage(somSelf,
                                                            hwndNotebook);
    if (brc)
        _xwpAddXFolderPages(somSelf, hwndNotebook);

    return (brc);
}

/*
 *@@ wpAddFolderSortPage:
 *      this normally adds the "Sort" page to the folder
 *      settings notebook; if allowed, we will replace this
 *      by the new XFolder version of it.
 */

SOM_Scope ULONG  SOMLINK xf_wpAddFolderSortPage(XFolder *somSelf,
                                                   HWND hwndNotebook)
{
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    PNLSSTRINGS pNLSStrings = cmnQueryNLSStrings();
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddFolderSortPage");

    if (pGlobalSettings->ExtFolderSort)
    {
        // extended sorting enabled:
        // check whether the "sort class" of the folder
        // is WPFileSystem (which is the default); only
        // then replace the "Sort" page with ours. Some
        // WPS extensions define their own Details views,
        // and we don't want to mess with that
        if (_wpQueryFldrSortClass(somSelf) == _WPFileSystem)
        {
            PCREATENOTEBOOKPAGE pcnbp = malloc(sizeof(CREATENOTEBOOKPAGE));
            memset(pcnbp, 0, sizeof(CREATENOTEBOOKPAGE));

            pcnbp->somSelf = somSelf;
            pcnbp->hwndNotebook = hwndNotebook;
            pcnbp->hmod = cmnQueryNLSModuleHandle(FALSE);
            pcnbp->ulDlgID = ID_XSD_SETTINGS_FLDRSORT;
            pcnbp->usPageStyleFlags = BKA_MAJOR;
            pcnbp->pszName = pNLSStrings->pszSort;
            pcnbp->ulDefaultHelpPanel  = ID_XSH_SETTINGS_FLDRSORT;

            // mark this page as "instance", because both
            // the instance settings notebook and the
            // "Workplace Shell" object use the same
            // callbacks
            pcnbp->ulPageID = SP_FLDRSORT_FLDR;

            pcnbp->pfncbInitPage    = fdrSortInitPage;
            pcnbp->pfncbItemChanged = fdrSortItemChanged;

            ntbInsertPage(pcnbp);

            return (SETTINGS_PAGE_REMOVED);
        }
    }

    return (XFolder_parent_WPFolder_wpAddFolderSortPage(somSelf,
                                                        hwndNotebook));
}

/*
 *@@ wpAddSettingsPages:
 *      this call xwpAddXFolderPages.
 */

SOM_Scope BOOL  SOMLINK xf_wpAddSettingsPages(XFolder *somSelf,
                                                 HWND hwndNotebook)
{
    BOOL            rc;
    // PAGEINFO        pi;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpAddSettingsPages");

    rc = (XFolder_parent_WPFolder_wpAddSettingsPages(somSelf,
                                                     hwndNotebook));

    /* if (rc)
        rc = _xwpAddXFolderPages(somSelf, hwndNotebook); */

    return (rc);
}

/*
 *@@ wpFilterPopupMenu:
 *      this removes default menu entries according to the
 *      Global Settings.
 */

SOM_Scope ULONG  SOMLINK xf_wpFilterPopupMenu(XFolder *somSelf,
                                                 ULONG ulFlags,
                                                 HWND hwndCnr,
                                                 BOOL fMultiSelect)
{
    ULONG ulMenuFilter = 0;
    // XFolderData *somThis = XFolderGetData(somSelf);
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    XFolderMethodDebug("XFolder","xf_wpFilterPopupMenu");

    ulMenuFilter = XFolder_parent_WPFolder_wpFilterPopupMenu(somSelf,
                                                         ulFlags,
                                                         hwndCnr,
                                                         fMultiSelect);
    #ifdef DEBUG_MENUS
        _Pmpf(("XFolder::wpFilterPopupMenu parent flags:"));
        _Pmpf(("  CTXT_CRANOTHER %d", ulMenuFilter & CTXT_CRANOTHER));
    #endif

    // now suppress default menu items according to
    // Global Settings;
    // the DefaultMenuItems field in pGlobalSettings is
    // ready-made for this function; the "Workplace Shell"
    // notebook page for removing menu items sets this field with
    // the proper CTXT_xxx flags
    return ((ulMenuFilter)
            & ~(pGlobalSettings->DefaultMenuItems)
        );
}

/*
 *@@ wpModifyPopupMenu:
 *      this routine allows an object to modify a context
 *      menu. We add the various XFolder menu entries here
 *      by calling the common XFolder function in menus.c,
 *      which is also used by the XFldDisk class.
 */

SOM_Scope BOOL  SOMLINK xf_wpModifyPopupMenu(XFolder   *somSelf,
                                             HWND  hwndMenu,
                                             HWND  hwndCnr,
                                             ULONG iPosition)
{
    BOOL                rc = TRUE;
    HWND                hwndCnr2 = hwndCnr;

    XFolderData *somThis = XFolderGetData(somSelf);

    /* _Pmpf(("wpModifyPopupMenu cbFldrLongArray: %d", _cbFldrLongArray));
    _Pmpf(("  somThis for %s: 0x%lX", _wpQueryTitle(somSelf), somThis)); */

    XFolderMethodDebug("XFolder","xf_wpModifyPopupMenu");

    // call parent
    XFolder_parent_WPFolder_wpModifyPopupMenu(somSelf, hwndMenu, hwndCnr, iPosition);

    // _Pmpf(("wpModifyPopupMenu cbFldrLongArray: %d", _cbFldrLongArray));

    if (hwndCnr == NULLHANDLE)
    {
        // bug in Warp 3: if the popup menu is requested
        // on container whitespace, hwndCnr is passed as
        // NULLHANDLE; we therefore use this ugly
        // workaround
        hwndCnr2 = _hwndCnrSaved;   // set by WM_INITMENU in fdr_fnwpSubclassedFolderFrame
    }

    // call menu manipulator common to XFolder and XFldDisk (menus.c)
    rc = mnuModifyFolderPopupMenu(somSelf,
                                  hwndMenu,
                                  hwndCnr2,
                                  iPosition);

    return (rc);
}

/*
 *@@ wpMenuItemSelected:
 *      process input when any menu item was selected;
 *      we do this by calling the common XFolder function
 *      in menus.c, which is also used by XFldDisk.
 */

SOM_Scope BOOL  SOMLINK xf_wpMenuItemSelected(XFolder *somSelf,
                                                 HWND hwndFrame,
                                                 ULONG ulMenuId)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpMenuItemSelected");

    // call the menu item checker common to XFolder and XFldDisk
    // (menus.c); this returns TRUE if one of the manipulated
    // menu items was selected
    if (mnuMenuItemSelected(somSelf, hwndFrame, ulMenuId))
        return (TRUE);
    else
        // none of our menu items: pass on to parent
        return (XFolder_parent_WPFolder_wpMenuItemSelected(somSelf, hwndFrame, ulMenuId));
}

/*
 *@@ wpMenuItemHelpSelected:
 *      display help for a context menu item.
 */

SOM_Scope BOOL  SOMLINK xf_wpMenuItemHelpSelected(XFolder *somSelf,
                                                     ULONG MenuId)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpMenuItemHelpSelected");

    // call the common help processor in menus.c;
    // if this returns TRUE, help was requested for one
    // of the new menu items
    if (mnuMenuItemHelpSelected(somSelf, MenuId))
        return TRUE;
    else
        // else: none of our menu items, call default
        return (XFolder_parent_WPFolder_wpMenuItemHelpSelected(somSelf,
                                                               MenuId));
}

/*
 *@@ wpOpen:
 *      this instance method opens a new folder view.
 *      This is one of the main hooks where the XFolder
 *      features are inserted into the WPS.
 *      We call the parent method first (which will create
 *      the folder window) and then subclass the
 *      resulting frame window with the new
 *      fdr_fnwpSubclassedFolderFrame window procedure.
 */

SOM_Scope HWND  SOMLINK xf_wpOpen(XFolder *somSelf,
                                  HWND hwndCnr,
                                  ULONG ulView,
                                  ULONG param)
{
    HWND                hwndNewFrame;
    // XFolderMethodDebug("XFolder","xf_wpOpen");

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpOpen for %s: ulView = 0x%lX, param = 0x%lX",
                    _wpQueryTitle(somSelf),
                    ulView,
                    param));
    #endif

    // have parent do the window creation
    hwndNewFrame = XFolder_parent_WPFolder_wpOpen(somSelf,
                                                  hwndCnr,
                                                  ulView,
                                                  param);

    if (   (ulView == OPEN_CONTENTS)
        || (ulView == OPEN_TREE)
        || (ulView == OPEN_DETAILS)
       )
    {
        fdrManipulateNewView(somSelf,
                             hwndNewFrame,
                             ulView);
    }

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("End of XFolder::wpOpen for %s: hwndFrame = 0x%lX",
                    _wpQueryTitle(somSelf),
                    hwndNewFrame));
    #endif

    return (hwndNewFrame);
}

/*
 *@@ wpPopulate:
 *      this instance method populates a folder.
 */

SOM_Scope BOOL  SOMLINK xf_wpPopulate(XFolder *somSelf, ULONG ulReserved,
                                      PSZ pszPath, BOOL fFoldersOnly)
{
    BOOL brc = FALSE;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpPopulate");
    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpPopulate for %s", _wpQueryTitle(somSelf) ));
    #endif

    brc = XFolder_parent_WPFolder_wpPopulate(somSelf, ulReserved,
                                               pszPath, fFoldersOnly);

    /*
        apparently, wpPopulate calls the following methods
        (in this order):

        --  wpQueryFldrFlags
        --  wpSetFldrFlags      0x400 (FOI_POPULATEINPROGRESS)
        --  wpQueryFldrFlags

        Then we have more calls on thread 1:

        --  wpSetFldrFlags      0x58408
                                    (0x0010000  FOI_CHANGEICONTEXTCOLOR
                                     0x0040000  FOI_CHANGESHADOWTEXTCOLOR (Warp 4 only)
                                     0x0008000  FOI_CHANGEICONBGNDCOLOR
                                     0x0000400  FOI_POPULATEINPROGRESS
                                     0x0000008  FOI_CHANGEFONT
                                    )
        --  and some more, but always with FOI_POPULATEINPROGRESS set

        Then we have the Populate thread again

        --  wpclsMakeAwake, for all the objects in the folder,
            which apparently calls
            --  WPFolder::wpAddToContent
            --  WPObject::wpObjectReady (on the Populate thread! Obviously, the object
                               is created here)
        --  wpclsInitData, wpQueryStyle, wpRestoreState, ...

        --  wpSetFldrFlags      0x402
                                    (0x00000400  FOI_POPULATEINPROGRESS
                                     0x00000002  FOI_POPULATEDWITHFOLDERS
                                    )
        --  wpSetFldrFlags      0x003
                                    (0x00000001  FOI_POPULATEDWITHALL
                                     0x00000002  FOI_POPULATEDWITHFOLDERS
                                    )

        End of wpPopulate; returning 1
    */

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("End of wpPopulate for %s --> %d",
                    _wpQueryTitle(somSelf),
                    brc));
    #endif
    return (brc);
}

/*
 *@@ wpRefresh:
 *      this method updates a folder; after doing
 *      this, we will also update the title of the
 *      window and maybe status bars.
 *
 *      Note that this method normally does _not_
 *      get called on thread 1, but some other thread,
 *      so this better be thread-safe.
 */

SOM_Scope BOOL  SOMLINK xf_wpRefresh(XFolder *somSelf, ULONG ulView,
                                        PVOID pReserved)
{
    BOOL        rc;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpRefresh");

    rc = XFolder_parent_WPFolder_wpRefresh(somSelf, ulView, pReserved);

    _xwpForEachOpenView(somSelf,
                (ULONG)2,           // update
                (PFNWP)fncbUpdateStatusBars);

    xthrPostWorkerMsg(WOM_REFRESHFOLDERVIEWS, (MPARAM)somSelf, MPNULL);

    return rc;
}

/*
 *@@ wpSetFldrFlags:
 *      overridden for debugging
 */

SOM_Scope BOOL  SOMLINK xf_wpSetFldrFlags(XFolder *somSelf, ULONG ulFlags)
{
    ULONG brc;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpSetFldrFlags");

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpSetFldrFlags for %s: 0x%lX",
               _wpQueryTitle(somSelf),
               ulFlags
               ));
    #endif
    brc = XFolder_parent_WPFolder_wpSetFldrFlags(somSelf, ulFlags);
    return (brc);
}

/*
 *@@ wpQueryFldrFlags:
 *      overridden for debugging
 */

SOM_Scope ULONG  SOMLINK xf_wpQueryFldrFlags(XFolder *somSelf)
{
    ULONG ulFlags;
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpQueryFldrFlags");

    ulFlags = XFolder_parent_WPFolder_wpQueryFldrFlags(somSelf);

    #ifdef DEBUG_SOMMETHODS
        _Pmpf(("XFolder::wpQueryFldrFlags for %s: 0x%lX",
                    _wpQueryTitle(somSelf),
                    ulFlags
                    ));
    #endif
    return (ulFlags);
}

/*
 *@@ wpSetFldrAttr:
 *      this sets new container attributes
 *      (those CV_* flags) for the specified folder view
 *      (OPEN_CONTENTS, OPEN_TREE, OPEN_DETAILS);
 *      overridden for debugging
 */

SOM_Scope BOOL  SOMLINK xf_wpSetFldrAttr(XFolder *somSelf, ULONG Attr,
                                         ULONG ulView)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpSetFldrAttr");

    #ifdef DEBUG_SORT
    {
        CHAR szInfo[300] = "";
        _Pmpf(("wpSetFldrAttr for %s", _wpQueryTitle(somSelf)));
        if (Attr & CV_ICON)
            strcpy(szInfo, "CV_ICON ");
        if (Attr & CV_NAME)
            strcat(szInfo, "CV_NAME ");
        if (Attr & CV_TEXT)
            strcat(szInfo, "CV_TEXT ");
        if (Attr & CV_TREE)
            strcat(szInfo, "CV_TREE ");
        if (Attr & CV_DETAIL)
            strcat(szInfo, "CV_DETAIL ");
        if (Attr & CV_MINI)
            strcat(szInfo, "CV_MINI ");
        if (Attr & CV_FLOW)
            strcat(szInfo, "CV_FLOW ");
        if (Attr & CA_OWNERDRAW)
            strcat(szInfo, "CA_OWNERDRAW ");
        if (Attr & CA_OWNERPAINTBACKGROUND)
            strcat(szInfo, "CA_OWNERPAINTBACKGROUND ");

        _Pmpf(("  Flags: %s", szInfo));
    }
    #endif

    return (XFolder_parent_WPFolder_wpSetFldrAttr(somSelf, Attr,
                                                  ulView));
}

/*
 *@@ wpQueryFldrAttr:
 *      this returns the current container attributes
 *      (those CV_* flags) for the specified folder view
 *      (OPEN_CONTENTS, OPEN_TREE, OPEN_DETAILS);
 *      overridden for debugging
 */

SOM_Scope ULONG  SOMLINK xf_wpQueryFldrAttr(XFolder *somSelf,
                                            ULONG ulView)
{
    ULONG ulAttr = 0;
    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpQueryFldrAttr");

    ulAttr = XFolder_parent_WPFolder_wpQueryFldrAttr(somSelf,
                                                    ulView);
    #ifdef DEBUG_SORT
    {
        CHAR szInfo[300] = "";
        _Pmpf(("wpQueryFldrAttr for %s", _wpQueryTitle(somSelf)));
        if (ulAttr & CV_ICON)
            strcpy(szInfo, "CV_ICON ");
        if (ulAttr & CV_NAME)
            strcat(szInfo, "CV_NAME ");
        if (ulAttr & CV_TEXT)
            strcat(szInfo, "CV_TEXT ");
        if (ulAttr & CV_TREE)
            strcat(szInfo, "CV_TREE ");
        if (ulAttr & CV_DETAIL)
            strcat(szInfo, "CV_DETAIL ");
        if (ulAttr & CV_MINI)
            strcat(szInfo, "CV_MINI ");
        if (ulAttr & CV_FLOW)
            strcat(szInfo, "CV_FLOW ");
        if (ulAttr & CA_OWNERDRAW)
            strcat(szInfo, "CA_OWNERDRAW ");
        if (ulAttr & CA_OWNERPAINTBACKGROUND)
            strcat(szInfo, "CA_OWNERPAINTBACKGROUND ");

        _Pmpf(("  Flags: %s", szInfo));
    }
    #endif

    return (ulAttr);
}

/*
 *@@ wpAddToContent:
 *      this method is overridden to intercept the
 *      notification of the "Added an object to a folder"
 *      event for subclasses that define their own folder view.
 *      The parent must always be called.
 */

SOM_Scope BOOL  SOMLINK xf_wpAddToContent(XFolder *somSelf,
                                             WPObject* Object)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpAddToContent");

    #ifdef DEBUG_SOMMETHODS
         _Pmpf(("wpAddToContent, folder: %s, object: %s",
             _wpQueryTitle(somSelf),
             _wpQueryTitle(Object)));
    #endif

    return (XFolder_parent_WPFolder_wpAddToContent(somSelf, Object));
}

/*
 *@@ wpDeleteFromContent:
 *      this method should be overridden to intercept the
 *      notification of the "Removed an object from a folder"
 *      event for subclasses that define their own folder view.
 *      The parent must always be called.
 */

SOM_Scope BOOL  SOMLINK xf_wpDeleteFromContent(XFolder *somSelf,
                                                  WPObject* Object)
{
    // XFolderData *somThis = XFolderGetData(somSelf);
    // XFolderMethodDebug("XFolder","xf_wpDeleteFromContent");

    #ifdef DEBUG_SOMMETHODS
         _Pmpf(("wpDeleteFromContent, folder: %s, object: %s",
             _wpQueryTitle(somSelf),
             _wpQueryTitle(Object)));
    #endif

    return (XFolder_parent_WPFolder_wpDeleteFromContent(somSelf,
                                                        Object));
}

/*
 *@@ wpStoreIconPosData:
 *      this method is documented only for Warp 4
 *      (but exists in Warp 3 also, see WPFOLDER.H);
 *      it is called when an open folder in icon or
 *      details view is closed.
 *
 *      The WPS then apparently saves the .ICONPOS
 *      data to disk; we only override this method to be
 *      notified that we need to to invalidate our
 *      internal lists of the config folder contents.
 *
 *@@changed V0.9.0 [umoeller]: now invaliding lists in menus.c
 */

SOM_Scope BOOL  SOMLINK xf_wpStoreIconPosData(XFolder *somSelf,
                                                 PICONPOS pIconPos,
                                                 ULONG cbSize)
{
    BOOL rc;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpStoreIconPosData");

    if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // invalidate the content lists for the config
        // folders so that they will be rebuilt
        mnuInvalidateConfigCache();
    }

    rc =  (XFolder_parent_WPFolder_wpStoreIconPosData(somSelf,
                                                       pIconPos,
                                                       cbSize));

    return (rc);
}

/*
 *@@ wpMoveObject:
 *      this is called when the folder is moved to a
 *      different location; we then need to update
 *      the titles of this folder AND of possibly open
 *      subfolders with the full path; we pass this
 *      job to the Worker thread.
 */

SOM_Scope BOOL  SOMLINK xf_wpMoveObject(XFolder *somSelf,
                                           WPFolder* Folder)
{
    BOOL rc;

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpMoveObject");

    /* call the parent method first, which will actually move the
       folder */
    rc = XFolder_parent_WPFolder_wpMoveObject(somSelf, Folder);

    xthrPostWorkerMsg(WOM_REFRESHFOLDERVIEWS, (MPARAM)somSelf, MPNULL);

    return rc;
}

/*
 *@@ wpSetTitle:
 *      this is called when the folder is renamed.
 *      We then need to update the titles of this
 *      folder AND of possibly open subfolders with
 *      the full path; we pass this task to the Worker
 *      thread, since it may take a while.
 */

SOM_Scope BOOL  SOMLINK xf_wpSetTitle(XFolder *somSelf, PSZ pszNewTitle)
{
    BOOL rc;
    // XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpSetTitle");

    /* if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // invalidate the content lists for the config
        // folders so that they will be rebuilt
        mnuInvalidateConfigCache();
    } */

    rc = XFolder_parent_WPFolder_wpSetTitle(somSelf, pszNewTitle);

    if (_wpFindUseItem(somSelf, USAGE_OPENVIEW, NULL))
        // any open views: update titles
        xthrPostWorkerMsg(WOM_REFRESHFOLDERVIEWS, (MPARAM)somSelf, MPNULL);

    return (rc);
}

/*
 *@@ wpSetFldrSort:
 *      apparently, this method normally gets called by the
 *      WPS every time it tries to sort a folder. That is,
 *      when one of the "Sort" menu items is selected or when
 *      the folder is sorted for another reason, e.g. because
 *      "Always sort" is on and a file in the folder was
 *      renamed.
 *
 *      The WPS ref. says about this method:
 *      "This instance method sets the sort attributes on
 *      the folder window and  saves those values in the
 *      instance data. Note:  This method only rearranges a
 *      folder open in icon view. If (pSortRecord == NULL),
 *      the values are reset to the default sort values."
 *
 *      However, the description of this method in the WPS
 *      ref. is complete garbage. The SORTFASTINFO structure
 *      described there is obviously not used, but some
 *      undocumented data instead. (I guess that's why IBM
 *      uses a PVOID here, so they need not apologize.)
 *      Also, this method rearranges _all_ open folders, not
 *      just icons views.
 *
 *      Anyway, if XFolder extended sorting is enabled,
 *      we can intercept this method call to prevent the
 *      WPS from sorting the container. We will then not
 *      call the default method, but our own one instead.
 *      Since XFolder completely takes over the other sort
 *      functions, this method probably only gets called
 *      when files are renamed any more.
 */

SOM_Scope BOOL  SOMLINK xf_wpSetFldrSort(XFolder *somSelf, PVOID pSortRecord,
                                         ULONG ulView, ULONG ulType)
{
    PCGLOBALSETTINGS     pGlobalSettings = cmnQueryGlobalSettings();

    if (pGlobalSettings->ExtFolderSort)
    {
        HWND hwndFrame = wpshQueryFrameFromView(somSelf, ulView);
        if (hwndFrame)
        {
            HWND hwndCnr = wpshQueryCnrFromFrame(hwndFrame);
            if (hwndCnr)
            {
                fdrSetFldrCnrSort(somSelf, hwndCnr,
                               TRUE);  // enfore cnr sort
                return (TRUE);
            }
        }
    }

    return (XFolder_parent_WPFolder_wpSetFldrSort(somSelf,
                                                  pSortRecord,
                                                  ulView,
                                                  ulType));
}

/*
 *@@ wpQueryDefaultHelp:
 *      this instance method specifies the default
 *      help panel for this instance; XFolder will
 *      return something different for the
 *      Config folder and its subfolders.
 */

SOM_Scope BOOL  SOMLINK xf_wpQueryDefaultHelp(XFolder *somSelf,
                                                 PULONG pHelpPanelId,
                                                 PSZ HelpLibrary)
{
    BOOL        rc;
    XFolder *pCfg = _xwpclsQueryConfigFolder(_XFolder);

    // XFolderData *somThis = XFolderGetData(somSelf);
    XFolderMethodDebug("XFolder","xf_wpQueryDefaultHelp");

    if (wpshResidesBelow(somSelf, pCfg))
    {
        // somSelf is in the config folder hierarchy:
        // display help for config folders
        strncpy(HelpLibrary, cmnQueryHelpLibrary(), CCHMAXPATH);
        *pHelpPanelId = ID_XMH_CONFIGFOLDER;
        rc = TRUE;
    }
    else
        rc = (XFolder_parent_WPFolder_wpQueryDefaultHelp(somSelf,
                                                           pHelpPanelId,
                                                           HelpLibrary));

    return (rc);
}


/* ******************************************************************
 *                                                                  *
 *   here come the XFolder class methods                            *
 *                                                                  *
 ********************************************************************/

/*
 *@@ xwpclsForEachOpenView:
 *      this class method goes through all open folder windows and calls
 *      pfnwpCallback for each open view of each open folder.
 *      As opposed to XFolder::xwpForEachOpenView, this goes thru really
 *      all open folders views on the system.
 *
 *      The following params will be passed to pfnwpCallback:
 *      -- HWND       hwnd: the hwnd of the view frame window;
 *      -- ULONG      msg:  ulMsg, as passed to this method
 *      -- ULONG      mp1:  the view type (as def'd in wpOpen)
 *      -- XFolder*   mp2:  the currently open folder.
 *
 *      This method does not return until all views have been processed.
 *      You might want to call this method in a different thread if the task
 *      will take long.
 */

SOM_Scope BOOL  SOMLINK xfM_xwpclsForEachOpenView(M_XFolder *somSelf,
                                                  ULONG ulMsg,
                                                  PFNWP pfnwpCallback)
{
    XFolder     *pFolder;
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsForEachOpenView");

    for ( pFolder = _wpclsQueryOpenFolders(somSelf, NULL, QC_FIRST, FALSE);
          pFolder;
          pFolder = _wpclsQueryOpenFolders(somSelf, pFolder, QC_NEXT, FALSE))
    {
        if (_somIsA(pFolder, _WPFolder))
        {
            _xwpForEachOpenView(pFolder, ulMsg, pfnwpCallback);
        }
    }
    return TRUE;
}

/*
 *@@ xwpclsQueryConfigFolder:
 *      returns the XFolder Configuration Folder or NULL
 *      if it doesn't exist.
 *
 *@@added V0.9.0 [umoeller]
 */

SOM_Scope XFolder*  SOMLINK xfM_xwpclsQueryConfigFolder(M_XFolder *somSelf)
{
    M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryConfigFolder");

    if (pConfigFolder == NULL)
        // config folder not queried yet:
        // do it now
        pConfigFolder = // _wpclsQueryObjectFromPath(_WPFolder, XFOLDER_CONFIGID);
                        wpshQueryObjectFromID(XFOLDER_CONFIGID, NULL);
                    // changed V0.9.0: the class method doesn't seem to
                    // be working on the new Warp Server

    return (pConfigFolder);
}

/*
 *@@ xwpclsQueryFavoriteFolder:
 *      This returns "favorite" folders.
 *      If pFolder == NULL, the first favorite folder is returned,
 *      otherwise the favorite folder which comes after pFolder
 *      in the favorite folder list.
 *      This returns NULL if no more folders are found.
 */

SOM_Scope XFolder*  SOMLINK xfM_xwpclsQueryFavoriteFolder(M_XFolder *somSelf,
                                                          XFolder* pFolder)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);

    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryFavoriteFolder");

    return (fdrEnumList(pllFavoriteFolders,
                        pFolder,
                        INIKEY_FAVORITEFOLDERS));
}

/*
 *@@ xwpclsQueryQuickOpenFolder:
 *      This returns folders which have the "QuickOpen" flag on.
 *      If pFolder == NULL, the first such folder is returned,
 *      otherwise the folder which comes after pFolder
 *      in the quick-open folder list.
 *      This returns NULL if no more folders are found.
 */

SOM_Scope XFolder*  SOMLINK xfM_xwpclsQueryQuickOpenFolder(M_XFolder *somSelf,
                                                           XFolder* pFolder)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);

    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryQuickOpenFolder");


    return (fdrEnumList(pllQuickOpenFolders,
                        pFolder,
                        INIKEY_QUICKOPENFOLDERS));
}

/*
 *@@ xwpclsQueryMenuBarVisibility:
 *      this returns the default visibility of menu bars
 *      as specified in the "System" object. Warp 4 has
 *      no method for this, so this has been added.
 *
 *      On Warp 3, this returns FALSE always.
 *
 *@@added V0.9.1 (2000-01-17) [umoeller]
 */

SOM_Scope BOOL  SOMLINK xfM_xwpclsQueryMenuBarVisibility(M_XFolder *somSelf)
{
    BOOL brc = FALSE;
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_xwpclsQueryMenuBarVisibility");

    if (doshIsWarp4())
    {
        PSZ psz = prfhQueryProfileData(HINI_USER,
                                       "PM_Workplace", "FolderMenuBar",
                                       NULL);
        if (psz)
        {
            if (strcmp(psz, "OFF") != 0)
                brc = TRUE;
            free(psz);
        }
    }

    return (brc);
}

/*
 *@@ wpclsInitData:
 *      this initializes the WPFolder / XFolder class as a whole;
 *      we need to call the parent and then set some XFolder
 *      data.
 *
 *@@changed V0.9.0 [umoeller]: added class object to KERNELGLOBALS
 */

SOM_Scope void  SOMLINK xfM_wpclsInitData(M_XFolder *somSelf)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsInitData");

    M_XFolder_parent_M_WPFolder_wpclsInitData(somSelf);

    {
        PKERNELGLOBALS   pKernelGlobals = krnLockGlobals(5000);

        if (pKernelGlobals->fXFolder == FALSE)
        {
            // store the class object in KERNELGLOBALS
            pKernelGlobals->fXFolder = TRUE;

            // first call:
            fdrInitPSLI();

            // initialize other data
            pllFavoriteFolders = lstCreate(TRUE);       // items are freeable
            pllQuickOpenFolders = lstCreate(TRUE);      // items are freeable

            fdrLoadFolderHotkeys();

            // register class for supplementary object
            // windows, which are created for each folder view
            // which is opened
            WinRegisterClass(WinQueryAnchorBlock(HWND_DESKTOP),
                             WNDCLASS_SUPPLOBJECT,    // class name
                             (PFNWP)fdr_fnwpSupplFolderObject,    // Window procedure
                             0,       // class style
                             4);      // extra window words for SUBCLASSEDLISTITEM
                                      // pointer (see fdrSubclassFolderFrame)
        }
        krnUnlockGlobals();
    }
}

/*
 *@@ wpclsCreateDefaultTemplates:
 *      this is called by the system to allow a class to
 *      create its default templates. The default WPS
 *      behavior is to create new templates if the class
 *      default title is different from the existing
 *      templates, but since we are replacing the class,
 *      we will have to suppress this in order not to
 *      crowd the Templates folder.
 */

SOM_Scope BOOL  SOMLINK xfM_wpclsCreateDefaultTemplates(M_XFolder *somSelf,
                                                        WPObject* Folder)
{
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsCreateDefaultTemplates");

    // we only override this class method if it is
    // being called for the XFolder class object itself.
    // If this is being called for a subclass, we use
    // the parent method, because we do not want to
    // break the default behavior for subclasses.
    if (somSelf == _XFolder)
        return (TRUE);
        // means that the Templates folder should _not_ create templates
        // by itself; we pretend that we've done this
    else
        return (M_XFolder_parent_M_WPFolder_wpclsCreateDefaultTemplates(somSelf,
                                                                    Folder));
}

/*
 *@@ wpclsQueryIconData:
 *      give folders a new default closed icon, if the
 *      global settings allow this.
 *      This is loaded from /ICONS/ICONS.DLL.
 *      Unfortunately, it appears to be impossible to
 *      dynamically load default icons as specified for
 *      the ICONINFO structure in the WPS reference.
 *      ICON_FILE at least doesn't work, and the format
 *      for ICON_DATA is not explained. So we have to
 *      use a DLL here.
 */

SOM_Scope ULONG  SOMLINK xfM_wpclsQueryIconData(M_XFolder *somSelf,
                                                PICONINFO pIconInfo)
{
    ULONG       ulrc;
    HMODULE     hmodIconsDLL = NULLHANDLE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsQueryIconData");

    if (pGlobalSettings->fReplaceIcons)
    {
        hmodIconsDLL = cmnQueryIconsDLL();
        // icon replacements allowed:
        if ((pIconInfo) && (hmodIconsDLL))
        {
            pIconInfo->fFormat = ICON_RESOURCE;
            pIconInfo->hmod = hmodIconsDLL;
            pIconInfo->resid = 100;
        }
        ulrc = sizeof(ICONINFO);
    }

    if (hmodIconsDLL == NULLHANDLE)
        // icon replacements not allowed: call default
        ulrc = M_XFolder_parent_M_WPFolder_wpclsQueryIconData(somSelf,
                                                              pIconInfo);
    return (ulrc);
}

/*
 *@@ wpclsQueryIconDataN:
 *      give folders a new default open icon, if the
 *      global settings allow this.
 *      See the notes for wpclsQueryIconData.
 */

SOM_Scope ULONG  SOMLINK xfM_wpclsQueryIconDataN(M_XFolder *somSelf,
                                                 ICONINFO* pIconInfo,
                                                 ULONG ulIconIndex)
{
    ULONG       ulrc;
    HMODULE     hmodIconsDLL = NULLHANDLE;
    PCGLOBALSETTINGS pGlobalSettings = cmnQueryGlobalSettings();
    // M_XFolderData *somThis = M_XFolderGetData(somSelf);
    M_XFolderMethodDebug("M_XFolder","xfM_wpclsQueryIconDataN");

    if (pGlobalSettings->fReplaceIcons)
    {
        hmodIconsDLL = cmnQueryIconsDLL();
        // icon replacements allowed:
        if ((pIconInfo) && (hmodIconsDLL))
        {
            pIconInfo->fFormat = ICON_RESOURCE;
            pIconInfo->hmod = hmodIconsDLL;
            pIconInfo->resid = 101;
        }
        ulrc = sizeof(ICONINFO);
    }

    if (hmodIconsDLL == NULLHANDLE)
        // icon replacements not allowed: call default
        ulrc = M_XFolder_parent_M_WPFolder_wpclsQueryIconDataN(somSelf,
                                                               pIconInfo,
                                                               ulIconIndex);
    return (ulrc);
}




