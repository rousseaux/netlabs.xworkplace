<HTML RESID=&ID_XSH_WIDGET_PULSE_MAIN;>
<HEAD>
    <TITLE>
        &xcenter;: Hartslag widget
    </TITLE>
</HEAD>
<BODY>
De
<A HREF="xcenter/xc_main.html">&xcenter;</A>
<B>"Hartslag" widget</B> toont de huidige CPU belasting tezamen met een grafiek van
de CPU activiteit in het verleden. Dit wordt eens per seconde bijgewerkt.
<IFNDEF __EWORKPLACE>
Hij is redelijk overeenkomstig met de betreffende monitor in het &warpcenter;.
</IFNDEF>

<P>Het scherm ziet er ruwweg als volgt uit:
<P>
<IMG SRC="img/xc_pulse.gif">
<BR>
<P>Het groenblauwe deel van de grafiek vertegenwoordigt de "gebruikers" belasting van het systeem,
terwijl het blauwe deel de "IRQ" belasting vertegenwoordigt. Het percentage dat in het midden wordt
weergegeven vertegenwoordigt altijd de huidige gecombineerde "gebruikers" en "IRQ" belasting.
Als u met een multiprocessor systeem werkt, krijgt u een "gebruikers" grafiek voor elke CPU.
Maar ook dan zult u maar ‚‚n "IRQ" grafiek hebben, omdat per definitie &os2; alle interrupts
op de eerste CPU van het systeem verwerkt.
Zie de onderstaande opmerkingen voor details hierover.

<P>Let op dat u op de hartslag widget ook het
<A HREF="glossary/gls_dropfonts.html">slepen en loslaten van kleuren en lettertypen</A>
kunt toepassen.
Verder is het via de
<A HREF="xcenter/xc_main_sizbar.html">aanpassingsschuif</A>
in grootte aanpasbaar.

<P><B>Implementatie Details:</B>

<P>Intern gebruikt de hartslag widget de <CODE>DosPerfSysCall</CODE> API
(zie
<A HREF="cpref.inf#DosPerfSysCall"><CODE>DosPerfSysCall</CODE></A>
in de Toolkit documentatie
<A HREF="_toolkitlink.html"><B>*</B></A>).

Deze API heeft het voordeel dat, om de CPU activiteit te meten, u direct de
prestatie metingen uit de &os2; kernel kunt halen in plaats van een tweede
leeglooptijd thread te laten draaien, die zelf alle overblijvende CPU tijd
(en daardoor extra accu stroom op laptops) consumeert.

<P>Als gevolg hiervan consumeert de hartslag widget <I>geen</I> aanvullende
CPU tijd tijdens het draaien, met uitzondering van de benodigde tijd voor het
tekenen van het widget zelf. Met andere woorden, de hartslag widget berekent zelf
de CPU belasting niet, het raadpleegt alleen de &os2; kernel voor de
huidige belasting en toont dat in een grafiek.

<P>De widget zijn eigen belasting, voor het tekenen, is ook de reden waarom u waarschijnlijk
nooit een CPU belasting van nul zult zien, zelfs als u momenteel helemaal niets aan het doen bent
met uw systeem. Op het systeem van de auteur (een Pentium II-400), komt de CPU belasting nooit
onder de 0.7% met de standaard widget grootte.

<P><B>Benodigdheden:</B>

<IFNDEF __EWORKPLACE__>
<P>De <CODE>DosPerfSysCall</CODE> API is slechts zeer recent ingevoerd en zou wel eens
niet kunnen werken op uw systeem. Hij zou moeten werken met Warp 4 en hoger (of Warp 3
met een vergelijkbaar fixpak niveau; wat dan fixpak 26 zou moeten zijn).
</IFNDEF>

<P>De IBM documentatie voor <CODE>DosPerfSysCall</CODE> geeft aan dat een Pentium
processor nodig is om de kernel prestatie metingen te laten werken.

<P>Als de widget geen grafiek vertoont maar alleen een <CODE>"E xxx"</CODE> (met
<CODE>xxx</CODE> zijnde een standaard &os2; foutcode), dan heeft zich een fout voorgedaan. Het meest
waarschijnlijk is dat u <CODE>"E 182"</CODE> krijgt, wat betekent dat de <CODE>DosPerfSysCall</CODE>
API niet gevonden is op uw systeem. Voor andere foutcodes kunt u proberen <CODE>HELP SYSxxx</CODE>
in te typen op een opdrachtregel.

<P><B>"Gebruiker"</B> en <B>"IRQ" belasting:</B>

<P>Voor elke prestatie meting geeft <CODE>DosPerfSysCall</CODE> waarden terug voor respectievelijk
"gebruiker" en "IRQ" belasting.

<P>De <B>"gebruiker" belasting</B> is de tijd die besteed is in "taaktijd" programmatuur. In
essentie betekent dit dat de CPU drukdoende was met het uitvoeren van een programma van ofwel
een applicatie ofwel de &os2; kernel ofwel een stuurprogramma in de normale uitvoeringsgang
van processen en threads, zoals geregeld door de planner in de &os2; kernel.
(Zie:
<A HREF="glossary/gls_scheduler.html">"Processen en threads"</A>
voor details.)

<P>In tegenstelling hierop vertegenwoordigt de <B>"IRQ" belasting</B> de tijd die nodig was om
interrupts te verwerken. Zoals u wellicht weet zijn interrupts een manier voor apparatuuronderdelen
om de CPU te laten weten dat er een belangrijke gebeurtenis is voorgevallen welke direct afgehandeld
moet worden.
Meest voorkomend zijn interrupts die veroorzaakt worden door harde schijven, geluidskaarten,
netwerkkaarten, en seri‰le en printer communicaties.
Deze apparatuur kan het zich niet veroorloven om te wachten totdat de &os2; planner een proces
tijdsinterval afgehandeld heeft en gereed is om naar een volgende taak over te schakelen. In plaats
daarvan onderbreekt de &os2; kernel, als er een interrupt binnenkomt, de normaal geplande volgorde
en roept een interrupt processor aan, die, in de meeste gevallen, geprogrammeerd is in een soort
stuurprogramma. (In het algemeen kunnen alleen &os2; stuurprogramma's interrupt processors
installeren).
Bijvoorbeeld, als er een interrupt van een harde schijf binnen komt zal er direct programmatuur in de
<CODE>IBM1S506.ADD</CODE> aangeroepen worden om de interrupt te verwerken.

<P>Als u nooit enige IRQ belasting op uw systeem ziet, dan is dat normaal. Dit is waarschijnlijk het
geval als u geen enkele netwerkadapter ge‹nstalleerd heeft en u busmastering geactiveerd heeft
voor uw harde schijven. Als u echter een hoge IRQ belasting heeft, zou u maatregelen kunnen treffen
om dat te verlagen. Activeer busmastering voor uw harde schijven en/of plaats een netwerkadapter
die beschikt over busmastering.

<BR>
</BODY>
</HTML>

